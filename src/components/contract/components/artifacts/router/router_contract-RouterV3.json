{
  "transpiled": true,
  "noir_version": "1.0.0-beta.7+0000000000000000000000000000000000000000",
  "name": "RouterV3",
  "functions": [
    {
      "name": "_addLiquidity",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tokenA",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tokenB",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "sqrtPriceX96",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "liquidity",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "tick",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "isNegTick",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14078072021571061404": {
            "error_kind": "string",
            "string": "Function _addLiquidity can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_addLiquidity"
      ]
    },
    {
      "name": "_getPool",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "tokenA",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tokenB",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "factory::pairV3::Pair",
            "fields": [
              {
                "name": "token0",
                "type": {
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "token1",
                "type": {
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "fee",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "tickSpacing",
                "type": {
                  "kind": "integer",
                  "sign": "signed",
                  "width": 32
                }
              },
              {
                "name": "maxLiquidityPerTick",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "feeGrowthGlobal0X128",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "feeGrowthGlobal1X128",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "slot0",
                "type": {
                  "kind": "struct",
                  "path": "factory::pairV3::Slot0",
                  "fields": [
                    {
                      "name": "sqrtPriceX96",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "tick",
                      "type": {
                        "kind": "integer",
                        "sign": "signed",
                        "width": 32
                      }
                    },
                    {
                      "name": "observationIndex",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 16
                      }
                    },
                    {
                      "name": "observationCardinality",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 16
                      }
                    },
                    {
                      "name": "observationCardinalityNext",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 16
                      }
                    },
                    {
                      "name": "feeProtocol",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    },
                    {
                      "name": "unlocked",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "liquidity",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "protocolFees",
                "type": {
                  "kind": "struct",
                  "path": "factory::pairV3::ProtocolFees",
                  "fields": [
                    {
                      "name": "token0",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 128
                      }
                    },
                    {
                      "name": "token1",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 128
                      }
                    }
                  ]
                }
              },
              {
                "name": "initiated",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "rate",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "rate_mul",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "rate_time",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZjdaiM5EIXfxde5UOmvqvIqQwhO4gwG4wRPsrCEvPuW2jrV9oLEjoe9sb8+bZ0+Jamlbn9tXnZPnz8f98fXt1+b+x9fm6fT/nDY/3w8vD1vP/ZvR1O/NqF9xFQ39/luEzNt7rl92zEFg5INqIF2qNyBo0FtwB0kGUgD2dzH9hvlM6QQAVAICtUOkQBQEpRUOuQAyADtUKCUfvVUcYmKizIMGZcQGAouIc0wGWgGdCWHBJAOBGXJXAxSM+QGrbk20A45AaRDiQDuUKEwmjOaCxSBolC0KyUkQL9EoQioHZZg0kA6LMEWsBjJOqG0YGeoHSoBoLD1WLLaS+vDM0DRBJAz1DYBUm7AHYgAtUOEEqEkKAlKhpJLhxIAuUPFtSpaMVoxFEEr6T7cui7ZCPISozZop6xbuI3pGTJAO2QobUwXWHqsQUWrCh+GwlAEisBH4KxQtCsSMgBKm35n6FeXCCVCSVASlBwB3KFAQXhZhnsBKAgvCC8ILwgvCC8ILwivCK8IrwivCK8IrwivCK8IrwivCK8IrwVKhVKhMAF6OSpQBIpC0a5QCMGpgMg1ci26FldNQZg1RgLKyck1FGLEoOpadY1dY9dQjpGnV9e8Igvt5JpXRF4ReUXkFVFyLa0aqiTcCUaoiEpycs0rIq+IvCJiT+UVxWXm6UIFJK7JqiloWX/qQtopLfUuROTEoBidXEv+u6Xe+v19t8Hm+fhx2u3a3nmxm9oe+7497Y4fm/vj5+Fwt/lre/hcfvTrfXtcvj+2JztrO+vu+GLfZvi6P+wafd+trcO4qXV9zb05parqFtbvVyY0MQkxwiPkeGFBVxZxbGGbEHeLrKG6BfOVQxo7iG2V3UFyHjpMy1BFGUQ6LKP8cRn1/y2jiI+GjEdDJha2GcPCNs1RCB07qD0xdActhf6wDIrjMiaTO4ZQu0UMce3Lcu1Ak3lpd4H3BPF6g5Gma4/JzGQh3B5s2+ewL/LEorZn5LOFPaEMLcq8knV6Z40jk9lqoRq9QxMPO5RnFsJuEehiWMNNKWoapphMTxFCX9jTxlpI1esFa5IihQSLFEoe9ebcQjG5bJsYjmqczc9AOfjdHsNtOezVBjnsVWZokWc56rp42hNFuClHjtiL7IVsuGjEOsvBvO5FrPW2HKGsOYY3SpytoMGmmOfQeNu4FMISaK+jw/5Is3vFNnXf38leRodLx2wxDwEeGi6G9l93S5rNU64JMZjFLXL97xYSsHKQRL7NongKubhnf8ui+jwXHqaYLj7KunanDLtzuoqGdZrr5S6fYvqNWsTXDpHrWh7saPu8P139vfPdvE777dNh1w9fP4/PF2c//n7HGfw99H56e969fJ52zWn9j8g+fkTrhxTCQ3ulWA7DnT2St0NaDqsdysN3C/MP",
      "brillig_names": [
        "_getPool"
      ]
    },
    {
      "name": "_mint_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tokenA",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tokenB",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "tickLower",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "tickUpper",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "isTickLowerNeg",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "isTickUpperNeg",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount0Min",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "amount1Min",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "lte",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "509153103577206836": {
            "error_kind": "string",
            "string": "Tick out of range"
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13265554733035650515": {
            "error_kind": "string",
            "string": "BigNum::validate_gt check fails"
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "emit_offchain_effect_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "notify_created_nullifier_oracle_wrapper",
        "__mul",
        "compute_quadratic_expression_with_borrow_flags",
        "__udiv_mod",
        "compute_quadratic_expression_with_borrow_flags",
        "__validate_gt_remainder",
        "__sub_with_flags",
        "__from_field",
        "__add_with_flags",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "_mint_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "tokenA",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tokenB",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tickLower",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "tickUpper",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "isTickLowerNeg",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "isTickUpperNeg",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "amount0Min",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "amount1Min",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "lte",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "getSqrtRatioAtTickUpper",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "getSqrtRatioAtTickLower",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "3754547823828078727": {
            "error_kind": "string",
            "string": "Function _mint_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5244613806648663532": {
            "error_kind": "string",
            "string": "NOTHING TO MINT"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBeJwAABAMnAg8EDicCEAQAHwoADwAQgE0dAIBRgFEEHQCAUoBSBB0AgFOAUwEdAIBUgFQBHQCAV4BXAS4IgE0AAS4IgE4AAi4IgE8AAy4IgFAABC4IgFEABS4IgFIABi4IgFMABy4IgFQACC4IgFUACS4IgFYACi4IgFcACy4IgFgADC4IgFkADS4IgFoADiUAAADeJQAAAScAIgECAigCAAMEgFsnAgQEAy4CAAKAAy4CAAOABC4CAASABSUAAAVhKAIAAgSAWycCAwQDOw4AAwACKQCAQwT/////KACARAQAAygAgEUBAAAoAIBGBAAAKACARwAAACgAgEgBAAEoAIBJBAABKACASgAAASgAgEsEAAIoAIBMBAAEJiUAAAWnHgIADwAeAgAQADMqAA8AEAARJAIAEQAAAUslAAAF0B4CAA8BHgIAEAAKKg8QESQCABEAAAFnJQAABeInAg8AAi0IARAnAhEEAwAIAREBJwMQBAEAIhACES0KERItDg8SACISAhItDgESJwIRBBItCAASLQoQEy4IgEsAFC4IgEUAFQAIABEAJQAABfQtAgAALQoTDwsiAA+ARwAQCyIAEIBFABEkAgARAAAB3SUAAAgFLQgBECcCEQQDAAgBEQEnAxAEAQAiEAIRLQoREi0ODxIAIhICEi0OAhInAhEEEi0IABItChATLgiASwAULgiARQAVAAgAEQAlAAAF9C0CAAAtChMPCyIAD4BHABALIgAQgEUAESQCABEAAAJOJQAACAUcCgMRBBwKERAALQgBAycCEQQDAAgBEQEnAwMEAQAiAwIRLQoREi0ODxIAIhICEi0OEBInAhEEEi0IABItCgMTLgiASwAULgiARQAVAAgAEQAlAAAF9C0CAAAtChMPCyIAD4BHAAMLIgADgEUAESQCABEAAALJJQAACAUtCAEDJwIRBAMACAERAScDAwQBACIDAhEtChESLQ4PEgAiEgISLQ4EEicCEQQSLQgAEi0KAxMuCIBLABQuCIBFABUACAARACUAAAX0LQIAAC0KEw8LIgAPgEcAAwsiAAOARQARJAIAEQAAAzolAAAIBS8KAA8AAxwKAxEGHAoRDwAcCg8DBicCEQYADCoRAxIkAgASAAADZiUAAAgXLwiASgADHAoFEQAcCgYFABwKBwYAHAoIBwAcCgsI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",
      "debug_symbols": "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",
      "brillig_names": [
        "_mint_public"
      ]
    },
    {
      "name": "addLiquidity_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tokenA",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tokenB",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tickLower",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "tickUpper",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "isTickLowerNeg",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "isTickUpperNeg",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "amount0Desired",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "amount1Desired",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "amount0Min",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "amount1Min",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "lte",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "sqrtPriceX96",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "509153103577206836": {
            "error_kind": "string",
            "string": "Tick out of range"
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3783626534653891156": {
            "error_kind": "string",
            "string": "R: below minimum"
          },
          "4236375919801895216": {
            "error_kind": "string",
            "string": "Input must be non-zero"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13265554733035650515": {
            "error_kind": "string",
            "string": "BigNum::validate_gt check fails"
          },
          "13462284035020069151": {
            "error_kind": "string",
            "string": "Denom must be > 0"
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "13882104877140394469": {
            "error_kind": "string",
            "string": "R: at or above maximum"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "15690125140784469321": {
            "error_kind": "string",
            "string": "bad denominator"
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "jN3LzivJjiXod4nxHsjMaCQtX6UHha6+FBJIVAJ9GR3Uu9d23tYa1uTE54ETtiT9IiW56KZ//fN//l//9f//b//l3//7//2f/+8///a//euf//r//Pt//Me//7f/8h//+X/87//fv//nf//7b//1z+/7n/XWP/+2/vz9565/nvqn1D9v/VPrn1b/9Prni3/u36/+ueqfu/556p9S/7z1T61/Wv3T65+13qr1Vq23ar1V661ab9V6q9Zbtd6q9Vatt2u9XevtWm/XervW27XervV2rbdrvV3rnVrv1Hqn1ju13qn1Tq13ar1T651a79R6UutJrSe1ntR6UutJrSe1ntR6UutJrXdrvVvr3Vrv/l3vfv+U+uetf2r90+qfXv98+U/91T9X/XPXP2s9rfX073r6/VPrn1b/9Prny3/ar/75d733/fO7fefDaUjjNrRhje9e24dX8F9jNb6V/cNpSONb+XtUXBvW+Lvy/iL8Fd6vsRq7cRrSuA1tWKNXfrXy+f0aq7EbpyGN29CGNbzRK69eefXKq1devfLqlVev/NXSvh+s4Y1X+OopsRq7cRrSuI1eeffKu1fevfLplU+vfHrl0yufXvn0yqdXPr3y6ZVPryy9svTK0itLryy9svTK0itLryy9svTKt1e+vfLtlW+vfHvl2yvfXvn2yrdXvr2y9sraK2uvrL2y9sraK2uvrL2y9sraK1uvbL2y9crWK1uvbL3yV4PbP1jDG6/w1WBiNXbjNKRxG72y98reK3uv/NXg+Z6iXw0mduM0pHEb2rCGN15Cfr/GauzGaXwr64fb0IY1vPEKXw0mVmM3TqNXXr3y6pVXr/zVoPw+vMJXg4nV2I3TkMZtaMMavfLulU+vfHrl0yufXvn0yqdXPr3y6ZVPr3x6ZemVpVeWXll6ZemVpVeWXll6ZemVpVe+vfLtlW+vfHvl2yvfXvn2yrdXvr3y7ZW1V9ZeWXtl7ZW1V9ZeWXtl7ZW1V9Ze2Xpl65WtV7Ze2Xpl65WtV7Ze2Xpl65W9V/Ze2Xtl75W9V/Ze2Xtl75W9V/Ze+fXKr1d+vfLrlV+v/Hrl1yu/Xvn1yq9Wvr9fYzV24zSkcRvasIY3euXVK69eefXKq1devfLqlVevvHrlrsHbNXi7Bm/U4P6wG6chjdvQhjW88QpRg4Fe+fTKp1c+vfLplU+vfHrl0yufXll6ZemVpVeWXll6ZemVpVeWXll6ZemVb698e+XbK99e+fbKt1e+vfLtlW+vfHtl7ZW1V9ZeWXtl7ZW1V9ZeWXtl7ZW1V7Ze2Xpl65WtV7Ze2Xpl65WtV7Ze2Xpl75W9V/Ze2Xtl75W9V/Ze2Xtl75W9V3698uuVX6/8euXXK79e+fXKr1d+vfKrlfX3a6zGbpyGNG5DG9bwRq+8euXVK69eefXKq1devfLqlVevvHrl1SvvXrlrULsGtWtQuwa1a1C7BrVrULsGtWtQuwa1a1C7BrVrULsGtWtQuwa1a1C7BrVrULsGtWtQuwa1a1C7BrVrULsGtWtQowb1wytEDQZWYzdOQxq3oQ1r9Mq3V9ZeWXvl+BR4PpyGNG5DG9bwxit8NZhYjV7ZemXrla1Xtl7ZemXrla1X9l7Ze2Xvlb1X/mrw3g+3oQ1reOMVvhpMrMZunEav/Hrl1yu/Xvmrwfs9mF8NfrCvBhOrsRunIY3b0IY1vNErr1559cpfDd734TSk8X2UXx+0YQ1vvMJXg4nV2I3TkEavvHvl3SvvXvmrQZW/+GowsRq7cRrSuA1tWMMbvbL0ytIrS6/81aDeD9K4DW1Ywxuv8NVgYjV2o1e+vfLtlW+vfHvl2yvfXll7Ze2VtVfWXll7Ze2VtVfWXll7Ze2VrVe2Xtl6ZeuVrVe2Xtl6ZeuVrVe2Xtl7Ze+VvVf2Xtl7Ze+VvVf2Xtl7Ze+VX6/8euXXK79e+fXKr1d+vfLrlV+v/Gpl//0aq7EbpyGN29CGNbzRK69eefXKq1devfLqlVevvHrl1SuvXnn1yrtX3r3y7pV3r7x75d0r715598q7V9698umVT698euXTK59e+fTKp1eOGrQP3niFqMHAauzGaUjjNrTRK0uvLL3y7ZVvr3x75dsr31759sq3V7698u2Vb6+svbL2ytora6+svbL2ytora6+svbL2ytYrW69svbL1ytYrW69svbL1ytYrW6/svbL3yt4re6/svbL3yt4re6/svbL3yq9Xfr3y65Vfr/x65dcrv1759cqvV3618vv9GquxG6chjdvQhjW80SuvXnn1yqtXXr3y6pVXr7x65dUrr1559cq7V9698u6Vd6+8e+XdK+9eeffKu1fevfLplU+vfHrl0yufXvn0yqdX7hp8XYOva/B1Db6uwdc1+LoGX9fg6xp8XYOva/B1Db6uwdc1+LoGX9fg6xp8XYOva/B1Db6uwdc1+LoGX9fg6xp8XYOva/B1Db6uwdc1+LoGX9fg6xp8XYOva/B1Db6uwdc1+LoGX9fg6xp8XYOva/B1Db6uwdc1+LoGX9fg6xp8XYOva/B1Db6uwdc1+LoGX9fg6xp8XYOva/B1Db6uwdc1+LoG16+L8K/WaI/+rm6/kIzuSEc28tFrfeVYWqM9mow1GWsy1mR8VWkr5KPX+gqztEZ7dEYyuiMdTcaejD0ZZzLOZJzJOJNxJuNMxpmMMxlnMs5kyGTIZMhkyGTIZMhkyGTIZMhkyGTcybiTcSfjTsadjDsZdzLuZNzJuJOhk6GToZOhk6GToZOhk6GToZOhk2GTYZNhk2GTYZNhk/EVtN2QjXz0Zfinr6hLa7RHZySjO9KRjXw0GW8y3mS8yXiT8SbjTcabjDcZbzJeZ6zfb7RGe3RGMrojHdnIR5OxJmNNxpqMNRlrMtZkrMlYk7EmY03Gnow9GXsy9mTsydiTsSdjT8aejD0ZZzLOZJzJOJNxJuNMxpmMMxlnMs5kyGTIZMhkyGTIZMhkyGTIZMhkyGTcybiTcSfjTsadjDsZdzLuZNzJuJOhk6GToZOhk6GToZOhk6GToZOhk2GTYZNhk2GTYZNhk2GTYZNhkzF1vqbO19T5mjpfU+dr6nxNna+p8zV1vqbO19T5mjpfU+dr6nxNna+p8zV1vqbO19T5mjpfU+d76nxPne+p8z11vqfO99T5njrfU+d76nxPne+p8z11vqfO99T5njrfU+d76nxPne+p8z11vqfO99T5njrfU+d76nxPne+p8z11vqfO99T5njrfU+d76nxPne+p8z11vqfO99T5njrfU+d76nxPne+p8z11vqfO99T5njrfU+d76nxPne+p8z11vqfO99T5njrfU+d76nxPne+p8z11vqfO99T5njrfU+d76nxPne+p8z11vqfO99T5njrfU+d76nxPne+p8z11vqfO99T5njrfU+d76nxPne+p8z11vqfO99T5njrfU+d76nxPne+p8z11vqfO99T5njrfU+d76nxPne+p8z11fqbOz9T5mTo/U+dn6vxMnZ+p8zN1fqbOz9T5mTo/U+dn6vxMnZ+p8zN1fqbOz9T5mTo/U+dn6vxMnZ+p8zN1fqbOz9T5mTo/U+dn6vxMnZ+p8zN1fqbOz9T5mTo/U+dn6vxMnZ+p8zN1fqbOz9T5mTqP+SP/hWR0RzqykY9e66vz0hrt0WTcybiTcSfjTsadjDsZOhk6GToZOhk6GToZOhk6GToZOhk2GTYZNhk2GTYZNhk2GTYZNhk2GT4ZPhk+GT4ZPhk+GT4ZPhk+GT4ZbzLeZLzJeJPxJuNNxpuMNxlvMl5nxOBSaY326IxkdEc6spGPJmNNxpqMNRlrMtZkrMlYk7EmY03Gmow9GXsy9mTsydiTsSdjT8aejD0ZezLOZJzJOJNxJuOrc1+hO9KRjXz0Wl+dl9Zoj85oMmQyZDJkMmQyZDLuZNzJuJNxJ+NOxp2MOxl3Mu5k3MnQydDJ0MnQydDJ0MnQydDJ0MnQybDJsMmwybDJsMmwybDJsMmwybDJ8MnwyfDJ8MnwyfDJ8MnwyfDJ8Ml4k/Em403Gm4w3GW8y3mS8yXiT8TojhqNKa7RHZySjO9KRjXz0ZXxnNWJMqrRGX4aHzkhGd6QjG/notaLOU2s0GXsy9mTsydiTsSdjT8aejDMZZzLOZJzJOJNxJuNMxpmMMxlnMmQyZDJkMmQyZDJkMmQyZDJkMmQy7mTcybiTcSfjTsadjDsZdzLuZNzJ0MnQydDJ0MnQydDJ0MnQydDJ0MmwybDJsMmwybDJsMmwybDJsMmwyfDJ8MnwyfDJ8MnwyfDJ8MnwyfDJeJPxJuNNxpuMNxlvMt5kvMl4k/E6IwawSmu0R2ckozvSkY18NBlrMtZkTJ3r1LlOnevUuU6d69S5Tp3r1LlOnevUuU6d69S5Tp3r1LlOnevUuU6d69S5Tp3r1LlOnevUuU6d69S5Tp3r1LlOnevUuU6d69S5Tp3r1LlOnevUuU6d69S5Tp3r1LlOnevUuU6d69S5Tp3r1LlOnevUuU6d69S5Tp3r1LlOnevUuU6d69S5Tp3r1LlOnevUuU6d69S5Tp3r1LlOnevUuU6d69S5Tp3r1LlOnevUuU6d69S5Tp3r1LlOnevUuU6d69S5Tp3r1LlOnevUuU6d69S5Tp3r1LlOnevUuU2d29S5TZ3b1LlNndvUuU2d29S5TZ3b1LlNndvUuU2d29S5TZ3b1LlNndvUuU2d29S5TZ3b1LlNndvUuU2d29S5TZ3b1LlNndvUuU2d29S5TZ3b1LlNndvUuU2d29S5TZ3b1LlNndvUuU2d29S5TZ3b1LlNndvUuU2d29S5TZ3b1LlNndvUuU2d29S5TZ3b1LlNndvUuU2d29S5TZ3b1LlNndvUuU2d29S5TZ3b1LlNndvUuU2d29S5TZ3b1LlNndvUuU2d29S5TZ3b1LlNndvUuU2d29S5TZ3b1LlNndvUuU2d29S5TZ3b1LlNndvUuU2d29S5TZ3b1LlPnfvUuU+d+9S5T53HNNlbIR3ZyEev9dV5aY326IxkNBlrMtZkrMn46vztT1+dl9Zoj85IRnekIxv5aDLOZJzJOJNxJuNMxpmMMxlnMs5knMmQyZDJkMmQyZDJkMmQyZDJkMmQybiTcSfjTsadjDsZdzLuZNzJuJNxJ0MnQydDJ0MnQydDJ0MnQydDJ0MnwybDJsMmwybDJsMmwybDJsMmwybjq/OnoTXaoy8jquKr89Id6chGPnqtr85La7RHk/Em403Gm4w3GW8yXmfEsFppjfbojGR0RzqykY8mY03Gmow1GWsy1mSsyViTsSZjTcaajD0ZezL2ZOzJ2JOxJ2NPxp6MPRl7Ms5knMk4k3Em40zGmYwzGWcyzmScyZDJkMmQyZDJkMmQyZDJkMmQyZDJuJNxJ+NOxp2MOxl3Mu5k3Mm4k3EnQydDJ0MnQydDJ0MnQydDJ0MnQyfDJsMmwybDJsMmwybDJsMmwybDJsMnwyfDJ2Pq/E2dv6nzN3X+ps7f1PmbOn9T52/q/E2dv6nzN3X+ps7f1PmbOn9T56/rfP+6zvev63z/us73r+t8/7rO96/rfP+6zvev63z/us737zcZazLWZKzJWJOxJmNNxpqMNRlrMtZk7MnYk7EnY0/Gnow9GXsy9mTsydiTcSbjTMaZjDMZZzLOZJzJOJNxJuNMhkyGTIZMhkyGTIZMhkyGTIZMhkzGnYw7GXcy7mTcybiTcSfjTsadjDsZOhk6GToZOhk6GToZOhk6GToZOhk2GTYZNhk2GTYZNhk2GTYZNhk2GT4ZPhk+GT4ZPhk+GT4ZPhk+GT4ZbzLeZLzJeJPxJuNNxpuMNxlvMqbO19T5mjpfU+dr6nxNna+p8zV1vqbO19T5mjpfU+dr6nxNna+p8zV1vqbO19T5mjpfU+dr6nxNna+p8zV1vqbO19T5mjpfU+dr6nxNna+p8zV1vqbO19T5mjpfU+dr6nxNna+p8zV1vqbO19T5mjpfU+dr6nxNna+p8zV1vqbO19T5mjpfU+dr6jzm4f4+BYIHFPCCChro4Bt+9d5cINKi5C0kozvSkY189FpR8qk12qPJsMmwybDJsMmwybDJ8MnwyfDJ8MnwyfDJ8MnwyfDJ8Ml4k/Em403Gm4w3GW8y3mS8yXiT8TojRuNKa7RHZySjO9KRjXw0GWsy1mSsyViTsSYjdpz6nhG559RvB+OpKEEBL6iggQ6+Yew9VVzgBpEmSBOkCdIEaYI0QdpF2kXaRdpF2kXaRdpF2kXaRdpFmiJNkaZIU6Qp0hRpijRFmiJNkWZIM6QZ0gxphjRDmiHNkGZIM6Q50hxpjjRHmiPNkRb7Xv3iaRY7XxUdfMP3Axf4peXTM7aOKwp4wS9txfM3tpErfmnrBl8zxteaC9zgAQW8oIIGOoi0hbSFtNhzbmnwgAJeUEEDI82Dbxh70RW/tL2CGzyggBdU8EvbcXtjj7riG0bXKEZa3LLYr654wLjpLxiLfX/jGFj7+2of/P6zs4MHFPCCChr4rXsiLZpCMppCcYGRFrchmkLxS/v2XNkxvtZU0EAH3zCagkhwgRs8YKTFwxdNoRhpcSOjKRQdfMNoCjeCoykUN3hAAS/4pd24OdEUig6+YTSFGzcymkJxg3Hf4tkXTaF4wTeMmr9xL6K6bzwJoqTr3363TONGRkkXHXzNmFRrfrfsu9B+x6xa84ACXlDBSPOgg28YJV2MtBfc4AG/NItbFiVdVPBLsx380uwEv7TveqAd02vNBW7wgAJ+aR4RUdJFAx18wyjp4gI3eEABkXaQdpB2kBY173GPo+aLBxTwgjqMgvR4oKIgixERf0LFTVfcdMVNjxLxeKCiRIoCXlBBAx18wyiR4gKR5khzpDnSHGmONEdavEK6BmMFC8YK8ZSLwika6OBrxuhXc4EbPKCAF1TQQAeRtpC2kLaQtpC2kLaQtpC2kLaQtpC2kbaRtpG2kbaRtpG2kbaRtpG2kXaQdpB2kHaQdpB2kHaQdpB2kHaQJkgTpAnSBGmCNEGaIE2QJkgTpF2kXaRdpF2kXaRdpF2kXaRdpF2kKdIUaYo0RZoiTZGmSFOkKdIUaYY0Q5ohzZBmSDOkGdIMaYY0Q5ojzZHmSHOkOdIcaY40R5ojzZH2kPaQ9pD2kPaQhl5y0UsueslFL7noJYpeouglil6i6CWKXqLoJYpeouglil6i6CWKXqLoJYpeouglil6i6CWKXqLoJYpeouglil6i6CWKXqLoJYpeouglil6i6CWKXqLoJYpeouglil6i6CWKXqLoJYpeouglil6i6CWKXqLoJYpeouglil6i6CWKXqLoJYpeouglil6i6CWKXqLoJYpeouglil6i6CWKXqLoJYpeouglil6i6CWKXqLoJYpeouglil6i6CWKXqLoJYpeouglil6i6CWKXqLoJYpeouglil6i6CWKXqLoJYpeouglil6i6CWKXqLoJYpeouglil6i6CWKXqLoJYpeouglil6i6CWGXmLoJYZeYuglhl5i6CWGXmLoJYZeYuglhl5i6CWGXmLoJYZeYuglhl5i6CWGXmLoJYZeYuglhl5i6CWGXmLoJYZeYuglhl5i6CWGXmLoJYZeYuglhl5i6CWGXmLoJYZeYuglhl5i6CWGXmLoJYZeYuglhl5i6CWGXmLoJYZeYuglhl5i6CWGXmLoJYZeYuglhl5i6CWGXmLoJYZeYuglhl5i6CWGXmLoJYZeYuglhl5i6CWGXmLoJYZeYuglhl5i6CWGXmLoJYZeYuglhl5i6CWGXmLoJYZeYuglhl5i6CWGXmLoJYZeYuglhl5i6CWGXmLoJYZeYugljl7i6CWOXuLoJY5e4ugljl7i6CWOXuLoJY5e4ugljl7i6CWOXuLoJY5e4ugljl7i6CWOXuLoJY5e4ugljl7i6CWOXuLoJY5e4ugljl7i6CWOXuLoJY5e4ugljl7i6CWOXuLoJY5e4ugljl4Sc2rrGybcMajW3OB3c1781EIUZPGCChro4BtGQRYXuEGkGdKiIOPrlphbaxro4BtGQRb/pu344i6m15oHFPB+3EEFDfSPccti6/tk/ABFMdIkuMEDChhpNxjravA1Y3KtucBY14Ox7gt+665f8IIKGvilxZn/GGErxk9SFBf4pa38dY2IuMGIiJsTv0kR58xjfm3v/M8cfMP4bYriAjd4wC9t7+AFv7Q4JR6TbE0H3zB+r6K4wC/txOMQv1pRFPCCX9qJmxO/XlF08EuL0+cx1tZcYKRJMNLiNsRvWRQvqKCBDkba96yOAbfmAjd4QAEvqKCBDiJNkaZIU6Qp0uI3L048J+NXL4oKxt8tf4LFwTeM378oLnCDX5rE4xu/g1G8oIIGOviG8ZsYxQVuEGmONEeaIy2aguRvyPzABW7wgAJeUEEDHey0E8NvzQVu8IACXlBBAx1E2kLaQtpC2kLaQtpC2kLaQtpC2kLaRtpG2kbaRtpG2kbaRtpG2kbaRtpB2kHaQdpB2kHaQdpB2kHaQdpBmiBNkCZIE6QJ0gRpgjRBmiBNkHaRdpF2kXaRdpF2kXaRdpF2kXaRpkhTpCnSFGmKNEWaIk2RpkhTpBnSDGmGNEOaIc2QZkgzpBnSDGmONEeaI82R5khzpDnSHGmONEfaQ9pD2kPaQ9pD2kPaQ9pD2kMaesnKXiLBBW7wgAJeMCJ+QQffMBtIcoEbPKCAF1QQaQtpC2kbaRtpG2kbaRtpG2kbaRtpG2kbaQdpB2kHaQdpB2kHaQdpB2kHaQdpgjRBmiBNkCZIE6QJ0gRpgjRB2kXaRdpF2kXaRdpF2kXaRdpF2kWaIk2RpkhTpCnSFGmKNEWaIk2RZkgzpBnSDGmGNEOaIc2QZkgzpDnSHGmONEeaI82R5khzpDnSHGkPaQ9pD2kPaQ9pD2kPaQ9pD2lv0vbvBy5wgwcU8IIKGugg0rKXWHCBG4w0Dwp4QQUNdPBLu5GWP6+XXGCkveABBbygggZ+ad+PXpydP7gXzJ/cSy5wgwcU8IIKGoi0gzRBmiAtf4pvBw8o4AUVNDDSbvAN86f5kpGmwQ0eUMBYN/6w+RN88RfKH+FLbvBbQeMvFP2heMHv9n6/anFihLDp4BtGf9C4Q9Efihs8YKwbD1/U/Dcac2IssLnAuL0RETVfFPCCChro4BtGzWs8vlHzxQ0eUMALKmigg6+ZP5VZXOAGDyjgBSNNg28Y1V1c4AYPKOAFsW5Ud9FBpG2kbaRtpG2kbaRtpG2kbaRtpG2kHaQdpB2kHaQdpB2kHaQdpB2kHaQJ0gRpgjRBmiBNkCZIE6QJ0gRpF2kXaRdpF2kXaRdpF2kXaRdpF2mKNEWaIk2RpkhTpCnSFGmKNEWaIc2QZkgzpBnSDGmGNEOaIc2Q5khzpDnSHGmONEeaI82R5khzpD2kPaQ9pD2kPaQ9pD2kPaQ9pL1Jk98PXOAGDyjgBRU00EGkoZcIeomglwh6iaCXCHqJoJcIeomglwh6iaCXCHqJoJcIeomglwh6iaCXCHqJoJcIeomglwh6iaCXCHqJoJcIeomglwh6iaCXCHqJoJcIeomglwh6iaCXCHqJoJcIeomglwh6iaCXCHqJoJcIeomglwh6iaCXCHqJoJcIeomglwh6iaCXCHqJoJcIeomglwh6iaCXCHqJoJcIeomglwh6iaCXCHqJoJcIeomglwh6iaCXCHqJoJcIeomglwh6iaCXCHqJoJcIeomglwh6iaCXCHqJoJcIeomglwh6iaCXCHrJRS+56CUXveSil1z0kotectFLLnrJRS+56CU3e4kHF7jBAwp4QQUNdPANN9I20jbSNtI20jbSNtI20jbSNtKygVhwgwcU8IIKGujgG2YDSSJNkCZIE6QJ0gRpgjRBmiDtIu0i7SLtIu0i7SLtIu0i7SLtIk2RpkhTpCnSFGmKNEWaIk2RpkgzpBnSDGmGNEOaIc2QZkgzpBnSHGmONEeaI82R5khzpDnSHGmOtIe0h7SHtIe0h7SHtIe0h7SHtDdp+vuBC9zgAQW8oIIGOoi0hbSFtIW0hbSFtIW0hbSFtIW0hbSNtI20jbSNtI20jbSNtI20jbSNtIM09BJFL1H0EkUvUfQSzV7ygl/ad4nHiQnM5htGLykucIMHFPCCCiJNkCZIu0i7SLtIi17yXYdyYgKzeUEFDXQw0r4TFDGBuT25wA0eUMALKmigg29oSDOkGdIMaYY0Q5ohzZBmSDOkOdIcaY40R5ojLbrGt0HuianKbRJcYKxwgwcU8IIKGhi3N5590R+CMVXZXOCX9n7BAwr4pX0TNSemKpsGfmnfnksnpiqL0R+KC4y0E4x1JaiggQ7Gut8bl5if3N9ozIn5yf1dTH9ifvLvOZzg+Ri37OsE5xfBXydoKmigf4xb9nWC4tcJmguMtBuMiLg5JyLi5pyIiMf3K/+z4uZ85f/3JE/wDb/yby5wgwcU8EtbcRu+8m96P7liUrIYNV9c4AYPKOAFFTQQaRdpGncoHhJd4AbjDsUDpQJeUEEDHXxD+4EL3CDSDGlfzZ8dt/er+aaBDr7hV/PNL23Ho/7VfPOAAkZaPH9dQQMjLW6ZT4eJScnmAjd4QAEvqKCBDk6a/37gAjd4QAEvqKCBDiJtIW0hbSFtIW0hbSFtIW0hbSFtIW0jbSNtI20jbSNtI20jbSNtI20j7SDtIO0g7SAtGsh3DfSJScnm9yw5+X8w0ME3jAZyTnCBGzyggBdU0MBIk+Ab5vuHG4x3QfH/zU8dyVg3/w8KGujgG0bXKC4w7oUFDyhgpHlQQQMjTYNvGF2jOF9leH7qSB5QwAsqaKCD88WJ44uTHNyMr39ycLMY9yL+8tEfigY6+IbvBy7we8xkBQ8o4Jf2DXyd2ISwaeCXFt9OxjhnMsY5m/N1VY5zFg8o4AUVNNDBN1w/MO7FCQp4QQXjXkjQwTfcPzDmii24wQMKeEEFDXTwDXM3hGTci7hDUfPFCypooIPfvYivJGNas7nADX5p8QVoTGs2L/il3XgcouaLDkbaVyIxrXnimRrTmue7Wv/EtGbzgAJeUMEvLb6+jGnN5htGJygucIMHFPCCCiJNkaZIM6QZ0uL9Q3wXGtOaTQEjLR6deP9QNNDBN4z3D8UvLT4lxbRm84ACfmnfz4eemNZsGvilxaevmOH8+w7pY/SH4gI3eEABL6iggZEWz4foDx8lZjjP96tTEjOczQ0e8Ev73i5KzHA2FTTQwTf8+kNzgV/at02AxAxnM9JO8IIKGujDuLziFyvsiJDgBg8o4AUjIh6d+KhRdPAN46NGcYFf2ov7Fg2kKOAFv7QXtzcaSNHBL+3FfYsGUlxgpN1gpGkw0uLmRAMpKmigg2+Yg92hM5LRHenIWl8Fy/fRTmJysvmGXwU3F7jBAwp4QQWRZkgzpDnSHGmONEeaI82R5khzpDnSHGkPaQ9pD2kPaQ9pD2kPaQ9pD2lv0mJysrnADR5QwAsqaKCDSFtIW0hbSFtIW0hbSFtIW0hbSFtI20jbSNtI20jbSNtI20jbSNtI20g7SDtIO0g7SDtIO0g7SDtIO0g7SBOkCdIEaYI0QZogTZAmSBOkCdIu0i7SLtIu0i7SLtIu0i7SLtIu0hRpijRFmiJNkaZIU6Shlyz0koVestBLFnrJQi9Z6CULvWShlyz0koVestBLFnrJQi9Z6CULvWShlyz0koVestBLFnrJQi9Z6CULvWShlyz0koVestBLFnrJQi9Z6CULvWShl2z0ko1estFLNnrJRi/Z6CUbvWSjl2z0ko1estFLNnrJRi/Z6CUbvWSjl2z0ko1estFLNnrJRi/Z6CUbvWSjl2z0ko1estFLNnrJRi/Z6CUbvWSjl2z0ko1estFLNnrJRi/Z6CUbvWSjl2z0ko1estFLNnrJRi/Z6CUbvWSjl2z0ko1estFLNnrJRi/Z6CUbvWSjl2z0ko1estFLNnrJRi/Z6CUbvWSjl2z0ko1estFLNnrJRi/Z6CUbvWSjl2z0ko1estFLNnrJRi/Z6CUbvWSjl2z0ko1estFLNnrJRi/Z6CUbvWSjl2z0ko1estFLNnrJRi/Z6CUbvWSjl2z0ko1estFLNnrJQS856CUHveSglxz0koNectBLDnrJQS856CUHveSglxz0koNectBLDnrJQS856CUHveSglxz0koNectBLDnrJQS856CUHveSglxz0koNectBLDnrJQS856CUHveSglxz0koNectBLDnrJQS856CUHveSglxz0koNectBLDnrJQS856CUHveSglxz0koNectBLDnrJQS856CUHveSglxz0koNectBLDnrJQS856CUHveSglxz0koNectBLDnrJQS856CUHveSglxz0koNectBLDnrJQS856CUHveSglxz0koNectBLDnrJQS856CUHveSglxz0koNectBLDnrJQS856CUHveSglwh6iaCXCHqJoJcIeomglwh6iaCXCHqJoJcIeomglwh6iaCXCHqJoJcIeomglwh6iaCXCHqJZKHv4AI3GCdrQzK6Ix3ZyEevlZdchNZojyZDJkMmQyZDJkMmQybjTkaWtQQ3eMB4CDV4wXgIX9BAB98wyzq5wA0eUMALIk2RpkhTpEVZr/iDRVkXN3hAAS/4pX1fL0tMTzYdjK+lPuW8QmiN9uiMZBQrxtMlivTbR0FiFlJWPN5RpMUDChi3NP4KUaRFAx18zZqFDK1RZFnwgAJG1gsqaOCX9X15KzEJWYwS/XZnkJiEbG4wvngKyeiOdGQjb8VL+k5+t3RL8Lul8ZSOucamgQ7GLY07GDVdXOAGDxinqkN3pKM44x/y0WvllwuhNdqjCPGggBf0YRTsjgc/CrYY34SEZHRH3yNy4k8T1Vp08HtE8uGNai1+UblCVGvxu7F5u6Na8+5HtZ54nKJavy+1JEYVmw6+YVRrcYEbPOCXJnF7o1olnkpRrRK3N15uJW5kvNxK3Mh4uS1u8IACXlCHUagSdzMKtbjBAwp4QW3G8KB8VyFKDA82Bbxg/GcejEfyBePJEHqtrLjQGu3RGcnojnRko8lYk7EnY0/Gnow9GXsy9mTsydiTsSdjT8aZjDMZ8U75u6hSNN8ph2zko9fKd8mhNdqjM5LRHU2GTIZMhkzGnYw7GXcy7mTcybiTcSfjTsadjDsZUWs3HoWoteIFv4VuPFmi1r4vIiVG+eTG8yaq6sbzJirlu3BRYhBPNP6/8bpWfMOo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H873+g/ne/2H873+w/lezzlk8Xi+5eejspBnnt9zDrlt5Ly/O/zg/HxUzvNp6U0+5Mw94UtWcj7O8XfP9xvlB+f7jfIib/IhC/mS5zyk51xxnCf0nCtuH7KQL1nJRnbynIf0hTk9X5jT84XrIDzniuOcoedccfuSlWxkJz94/chzHtLX2uRDFvIlK9nITn7wnvOQnnPF7U0+5DkP6TlX3FaykZ384PMjL/Imz3lIz7ni9iXPeUjPueK2kx8sP/Iib/Ihz3lIz7nitpKN7OQH3x95kTd5zkP60jkP6UsXeZMPWciXrGQjO3nOQ3rOA7cXec5Des4Dt4V8yUo2spMf7HMe0nMeuL3JhyzkS1aykZ085yE954Hbi7zJcx7Scx64fclKNrKT5zyk5zxwe5HnPKTXPHBZyHMe0vdPyUZ28oPXj7zImzznIX0vIV+yko3s5AfvH3mRs/9HbvaTspKN7OQHZz8pL/ImHzLlHso9lHso91DuoVyhXKFcodzsJ/G6n3O/8uK+Zz/5vof1nPuV732y59xv28kPzn5SXuRNPmQhXzLlXsq9lHspVylXKVcpVylXKVcpVylXKVcpVynXKNco1yjXKNco1yjX5no9z5nhtpMz9+sVOTPcXuRNPmQhX7KS8/5GvWdfKj84+1J5kTf5kIV8yZkbz8PsS2Unv3HODLcXeZMPWchzvYDnzHDbyJnr4QdnXyov8iYfspAv+cu9307enjPDbSc/OPpSe5E3+ZCFfMM3rOTM1XDmxuOz5/oIP3UdaHqRN/mQhXzJSjaykylXKDf3NY33gTkz3D5kIV+yko3s5AffHzlyv93LPWeG24cs5EtWOPdB/fbj9pwBbh+ykC9ZyXH747U1Z4DLuU9pvDfLGd32g3Of0ngPkzO67U0+ZCFfspKN7OQHP8rNfUqzvnKf0vIhC/mSlWxkJ79xzvHeeK+Sc7z32z/Yc463fchCvmQlG9nJD15zPZHLWuRNzty0kC9ZyUZ28oOzP5Tj/sb7lpzjbR+ykC9ZyUZ28oPPnIf03Je4jPleF+w74YJ9J5zme53me53me53me53me53me53me53me53me53me53me53me53me53me53me53me53me53me53me53me53me53me53me53mez3ne/OcoaiTcR6S5nud5nud5nud5nud5nu95nvjXGLN95aN7GSc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QNXF9g52q3/tHeybK/js8yZ7B/tmr3ntHexWn9o72Hd/BCdwxviC/gqGXz+/nHKG3wK/pl1Xvrq066pnl3Z9cQYXcAU3cAdbzavPuV5g01TreTDtuupi065bXWzadauLTbtudbFp163mNe365g4ezs1rXtOub47gBLb9ZT0DrYBtf9lsyq/qX9Oubx7OVgMqfzPtutW/pl3fnMBnnzeZdt3qWdOu7/6G/o7+4f3j8v4R0G+1tq5/eM27tOuLC7iCG7iDz/5yWtp11bxLu744ghPY/A5xActvN5vyq7rYtOtW/5p2fXG4wGefN5l23epZ067v/oz+gv6K/ob+jn6reef3W6LXvKZd3xzBCZzBBVzBVvPq3mMHm6Z6fnemXbe62LTrVhebdt3qYtOuW11s2nWreU27vrmCG9hr3qVdN84XOIBtf7mKE9j2l2XT9gTtO83nHHFa2vXFHXz2edPSritWLO366o/oT+jP6C/or+i3fFLXVrzmLcVr3lIvcABHcAJncAFXcAPDr9WDqouL1YOqi4vVg/qdKs1r3tISOIMLuIIbuIO95i1+fjkVP7+cSoffDr/r/LI+24777bjf7rm6vXd98bjAAew179KrL87gArbaU/NxNLDVvHr+x9FUp6VX13O+9OqLIziBM7iAK7iBO9hr7aVXVxxeevXFEZzAGSy/irFLr77Ya94aOng4xwvsNW+NEZzAGew179KuL27gDvaa17TrmwM4gm1/WZ9PymCreXWPqYK95jXt+maveU27vjmAIziBM7iAK9hrXtOubx7O5QIHsO0vN3ECy28yLmD5zcYNbNpmfY9lOFefR7UGcAQncAYXcAV7zbu064uHc7vAVvNe4gi2mlfPUstgr3mXdn1xA3ew7y8v7friAPaad2nXF2dwAVdwA3ew17xLu744gCM4gc2vrs10C6qLq+kWVAvX0cBe8y7tunhp1xcHcAQnsNe8pl23+tS065sbxnT0e81r2vU1JgT0R3DCmIx++F3nl7vYa17Trm/2mte065sDOIITOIMLuILhN3rN2+JwThc4gOVXtbBp1zebplr3btp11QhLu764geVX9e/SrhvnCyy/qovtvetWz9p71zdncAFXcAN3sNe89t71zQEcwba/rOsvGWz7y7JpNaDqYnvvutW/9t71zcO5+j6vvXd9cwRbzWvjM/oLuIIbxnf0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7ase5tW+6mFe7aueov1u0X63pCnFein5JyUpS7FeSq5Sk7oU66XkKYV7zauUcK95lRLrpZQsFSn2l1Jifymla21obWot9pdS416q1KS1HKtH+92i/W6pqpeqeqmql6p6qXEvVZrqpSUpx+ppJVZPq7F6WovV03qsHu13i/a7paleuuqlq1666qUXSfXSVS9d9dKHpHrp8d5hGb9YPSPF6hmql6F6GVWK/aWM2F/KGFqbWlN/meovM2kta63E6tF+t2i/W6bqZapepuplql7WT1K9rCyVWD2rxupZLVbP6rF61ojVo/1u0X63/n5SkrJUpCrFeqm/Lg1pSrFeavpJ8V5zTfFec02xXmqqUpNif6kp9peaptZif6k59peak9ay1orW4r3mqv1u1X635iFNKdZLLT8pSbFeailSvNdcS7zXzLzaVz3Mq33Vw7zaVz1V+92q/W6tqpeqeqmql6p6qU1SvVTVS1W91PjevjbVS0tSvNdcW7zXXJvqpaleWpdif6kt9pfaYn+pPfaX2pPWstaK1qrW4r3mqv1u1X63dtVLV70M1ctQvYwsqV5GleK95jrivWbm1W71jHivmXm1Wz3a71btd+tUvUzVy1S9TNXL7JLqZapepupl/STVy8pSvNdcV7zXXJfqZale1pDUX1bsL+0X+0v7Ja1lrRWtVa01rcV7zU373ab9bvvFemnpJyUpS0WK9dJSk+K95pbivWbm1b7qYV7tqx7m1b7qadrvNu13Wy5SlZrUpSHFemk51ksrPylJsV5aKVK819xKvNfcSqyXVoY0pdhfWo39pdWktay1orWqtaa1rrV4r7lpv9u0321N9dJUL0310lQv8RzZak310roU7zW3Fu81M692q6fHe83Mq93q0X63ab/buuqlq1666qWrXuI5stW66mWoXobqJZ4jW22oXkaV4r3mNuK95jZUL0P1MuK9oDbVX6b6y1R/meovU/1lqr/MrrWhtXivuWm/27TfbUv1slQvS/WyVC/xHNlqS/WyhhTvNbcV7zUzr/ZVD/NqX/Uwr/ZVT9d+t2u/239N6tKQphT3Uj3FeukpSVkqUqyXnpoU7zX3FO819xTrpadYLz3/pNhfeo79peeitaq1prWutaG1qbV4r7lrv9u13+0lS0WqUpO6FOullynFe81nXu2rnhrvNZ95ta96arzX3LXf7drvnnm1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",
      "brillig_names": [
        "discover_new_messages",
        "emit_offchain_effect_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "notify_created_nullifier_oracle_wrapper",
        "__from_field",
        "__validate_gt_remainder",
        "__mul",
        "compute_quadratic_expression_with_borrow_flags",
        "__udiv_mod",
        "compute_quadratic_expression_with_borrow_flags",
        "__add_with_flags",
        "__sub_with_flags",
        "__mul",
        "__sub",
        "lte_hint",
        "field_less_than",
        "decompose_hint",
        "largest_power_of_two_divisor",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_invert",
        "directive_integer_quotient",
        "directive_to_radix"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkAAAAA//////////8ABgXOnigDlPSb2Ie0\nSWDAmRoUJ8yUEXLwJDXHJW7XyrwtbBsZf4zvUYvnB2xOQ0B+8XTQ94uo5BaPxEo0azl6IRUquIwb\n8dR5vknU1yxVyikhInDPS0gMDV71cBK3ztUSGQ9ozi2CwfGbL5fwhP5ir67DDI2LWd47xICgvgRc\nmsYnFofTDIOFSKYt8fSofuLEw/nVN9CcmJvm0Hdm36SvAhsp3Rs01JwYUAXOYePvnup5ZsN06D4M\nzRPrEdCZbWNdDpPS05VutJB5ytxNbCcpy98fLGzXcT8ACob9yeOmRjUaJnfl60MbPDlAH/8SCauH\nDCJjDpwgAn5kylpqTusHdyZ5kYRB4dajvkQvQiPPQg5fVKpCuHP++le9WHXLqIbgD9cxRlRxj0gA\nwx4/Havc9F+a3LXgz5tVJSVGOo3/8OsUmjReLrlzoBc7o6M0B2F7UYiB9ItEpQCdxdMjooR9sil3\nbDbC1321jYye14A1SAqRb9rbEl54kRz+fu6cYO0hEabVvIpfVK1Cmo0sICvRD9kVavxZhNfishhT\njnOjarMEaHGye2msWK1jh5dtDtpyAx4+e0Dduaitynb2eIOYxRyTB3PuIeL1vbZ/SYnq4B8zMhHJ\nX62YjDiEJssAOVLBEmzKdRYfyHWhoRoHRp7ovl6SDS1TEwRlZ2pnYiGJ4xMvAkPP+obQvkE9LM4H\nSjaWr3mJIydK1HwJWb3tg4M9UQmxUWR961tgujy7byOdcbhKl3et2pYeLFuj+DyQ9AVLBvH4khYk\np1p1IsuoP0LquZlIGRxCCt7NLj0YpGHJRyIsF3S1rZXD+kuMySvQY1ZyvQ1HlHvW+u8BfIzcR9Iw\nVSHrSJuRmKhkLL92LlSOA5ve52T8+85x9jwkt2+sZv9oEf1BtfmTbZMquuTG6TPg05wk6o4uDu5w\nKlMm81nJR8AUoX18ClXS1F7o7fbsFlwRPSgrmEfVYv1BQCIOR+GCrxpw0tC/U/KBmNxua015bsn0\nE4YWuRKVxKct3D6sKlhhJBevJqfy7UhSRvifA5dEGXjkS1proJ5uJ+Em/rS5SUseRtqP5iACRDVV\narWkelhlmgpWSvz+9Vwp/ENuxY+t9Se1mBSDQEz54rmtOhRvdcVfewKI6AXsULCgKPFCXLqQJ/7I\nGAAzqcZA0BPclEHQu5Hf74M7YN7MA4NqqHOOc2cG/trlyNWumD+2KcQfRAbVZ3BykalJe4y5fFc8\n/Z0r4Bbbs7IP4J8KijKDhwHBJaERKe66OUEXTsABB+x3wHdfGgmBRvwQLe+pZbvUu6RYh7XWRkSC\nmJ1GmXAn0FBYy/8FsvvJjfD4Uc9UmuGaw+H0m9ERD28dmzLFjpEi1YUqXyLjJ4dBgM/j1/ioompi\n2T1ScXBw1P/vunlT0MGNq5VFCRUQRcQZIL8SNwRLvNaXHjNZv6hkgHO4lPEvy52waIglO7KX3TUx\n51EG3C0s3ab7xBXODSFpoxTQem8zz77Nhg4vgDD+EZNQ3+uzdK6ca4eqdn+lXyrCV6ixC4KG5bZa\nH4+fazmTnZrFzLuMf0pgqCwKc9uhNjaZzp8it9S7nS0jvTeaMN1OTYTseyc7vfRZhN7RYXybwAFj\nQkiLXoXN+wXoWGxKxQkPOJ0pwNphdQSv7+GEXRLEKdcQ3nbyYUcbCZ/dp3g0NPAd4FWEdCs807MG\nze25/MzBU70NRZRnepYdcgc6x1LviWm4Ke0BHq7HZon4AsKCeM78NJLnxFtI7QLZsew5Wgdm+P/t\nHw3DsMg//jEQohPddOgSzXGLTtXFFm+a3dvg6liQw5tY+p+cYMhALPifYcDGjTGag/UsXtMt7OtS\nYOMSvkPHX4AyqKOEWgJZhrwfznRHI8VZC9LX5irJ5GLg0ncG0EgnIbvgWU9P4LDwKSNgZuzK7l4E\npgp0IpDzGlNBOclUUBPM0GRnY69z1oYKWVwfBibWnyjQEYomqxUq5N34wb+H+u+xFBjSswM+29JI\nd3c7XRCqJaGk+gpCySzRFdSTZkRZiE2PRhseMje0UYseXh6hHMNC+ynJE2pXasUaYDSGbg1Wx6IS\noC50JuENWm138WIwa64v9iEQcowMvKp6U6hu7N0paot5UNdGPqta7qMD4e3PsJCLji3ONIbDGGEh\nt4VquKJONJuzwTnMEQdaTUBCLiWICI0nI4XZZQud3aNAI9YzW1IPyVwOizyk8U4szsxqbVhzQ7oA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAACDLMihR1RFF/iL9haFYM8lM9p7RaiU8ldzmejtVweajAMC2AgqggeNAveEXVjOg4NO5RD\nhqSh/GBsgSEQ+D132QDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04sAZaN5cMk\ngqp9HQoJ1xeOyTuteFj5bmTwtI0T/DBF7F3IrJuupLmeobqEaLN+EOCE3rvz8G891XJ5kBMevpRD\n0wjG1j0HkTruZrSFZmQJ4zJievrMBCtdWDUY"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "_factory",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "currentTick",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "tokenA",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tokenB",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "signed",
            "width": 32
          },
          "visibility": "public"
        },
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgQEAycCBQQAHwoABAAFgEQdAIBGgEYELgiARAABLgiARQACLgiARgADJQAAAF4lAAAAaC4CAAGARygCAAIEgEcnAgMEATsOAAMAAikAgEME/////yYlAAACxx4CAAQAHgIABQAzKgAEAAUABicCBAEBJAIABgAAAJElAAAC8CcCBAABLwoABAAFHAoDBAApAgADACDHc9UnAgcEBCcCCQQDACoHCQgtCAEGAAgBCAEnAwYEAQAiBgIILQ4HCAAiCAIILQ4HCCcCCAQDACoGCActCgcILQ4DCAAiCAIILQ4BCAAiCAIILQ4CCAAiCAIILQ4ECCcCAQQEACIGAgQtCwQDJwIHBAIAKgQHAjkDoIBDgEMABQADAAIgAgABIQIAAicCAwQALQgBBQAiBQIILQsIBycCCQQCACoICQYiOgACAAMABi0KAgcnAgkEAwAqBwkIAAgBCAEnAwUEAQAiBQIJLQ4HCQAiCQIJLQ4HCS0KBwQGIgQCBCQCAAEAAAHAIwAAAZctCwUBACIBAgEtDgEFACIFAgYtCwYCJwIHBAIAKgYHATwOAgEjAAABwCcCAgQVCioEAgYkAgAGAAAB2ycCBwQAPAYHAScCBAAALQgBBicCBwQWAAgBBwEnAwYEAQAiBgIHJwIIBBUAKggHCC0KBwkMKgkIChYKCgokAgAKAAACJS0OBAkAIgkCCSMAAAIGLQgBBAAAAQIBLQ4GBCcCBgQBLQoDASMAAAJADCoBAgMkAgADAAACeCMAAAJSLQsEAScCAgQJACoBAgQtCwQDHAoDAgQcCgIBABwKAQIELQoCASYnAggEAwAqBQgHACoHAQgtCwgDLQsEBy4CAAeAAygAgAQEABYlAAADAi4IgAUACAAiCAIJACoJAQotDgMKLQ4IBAAqAQYDLQoDASMAAAJAKACABAR4AA0AAACABIADJACAAwAAAu8qAQABBfeh86+lrdTKPAQCASYqAQABBb4eP/8+pPb6PAQCASYuAYADgAYLAIAGAAKAByQAgAcAAAMdIwAAAyguAIADgAUjAAADjy4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAN7LgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAANKKAGABQQAAQMAgAYAAoAGIwAAA48m",
      "debug_symbols": "tZfRbiIxDEX/ZZ55iBM7TviVVVXRdlohIYoorLSq+Pd1IHcGKiXaUu0LnPFM7jiO7WQ+h5fx6fj2uN6+vn8My1+fw9N+vdms3x4378+rw/p9a9bPwZUfcnlY8mIg4mGp5d+uyRl4NSCD4CuwA4hBNBAHiAbJINKw9OUZdQCpkGBJkyVXyAyoFu8YkCpQAGgF7wGwBALUV3h2AAgyXiEQFLwiFsFQQCsoLBorJALAcvZZFkNwRVALlOHZgDwgVvAEkArBAWBhDBcMF1giLBEWhUXxioRXJAie42zAZ8dsmZgIECt4cyNQAQHkCoEBsLBFLNjcucTwArDEWEEJUAQtxbgkwAUYkCtkWHK1iGMALAQLpQo+ALRCEABGMUYxLIJRAp0SumArKGc3YoFyy8ISy5peAJayphfQCh6WUikhF9AKDAvDIgSQy7tiKZkLpAoaALlCYgAsGc/kohxPp8WA6n487MexFPdVuVsT2K324/YwLLfHzWYx/F5tjueHPnar7fn/sNrbXSv9cfti/yb4ut6MhU6LebRrD6UgketwCjHnScK6y40IdUSc99Bw7K8k6EbCtyUsrbRKcHZxklC9UQhthcQBcUjMTYXuNHLGNKynNqchP55G/L/TkDStRmqvRupIiAokYqCWE7mtkMXBiSxCP5wG+fY0OsntOWEaXpxMEnKrQJ28tCqYImH74+xFDrcanczURCgPTSE0Y8EdiVg28YtEFNeUkP5M5vTm7Fsi3YAqTQGl2AyodtzICRXinaOrZXV3eXHVbr560UnPlAixSIl1koj5tmF1vLCjAySCE25Fsy+RkVzBa3NVfS8/nR3xpmq3I9hdftgZBX7YmaQpwT0/4tw8nXp3lx/ssRcF5mbT8LHnh+q8F2mO9/nhZPajWSi+10GdpdjkR/b3rYsQWmCQdjxCb3+3TX3a38lOlc3W0WvmzkEju6ul/VItoZenGgPcUE2TBMd/l0gOnYOS1/skZPIiXdXstyTilOdJm150m0/WPIczNcPZ7aJuTvN8vcsHH74xlzT1jpRu5/JgV6vn9f7m+/NUtPbr1dNmrJevx+3z1d3Dnx3u4Pt1t39/Hl+O+7EozR+x9vOLOC0o5gf7iDxfWkMl5nJJ57til/pwKs78BQ==",
      "brillig_names": [
        "currentTick"
      ]
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+29CZSc13Ue+FdXdwNdQKOL2MEVIECCi0jV1ptkSdBCiZIokRJ3kRJR3VVFcRFBEiDFRRJLEsV9A0hC3BdJpD3OOBlnjiexHY994hln8YyPEyfxSXzGGSVxksl24qNZ7Bk7GTyybtVXX93//X913deoBvqdA/Rf/3vvu/fd99599233z0Tvh6uP/cu0nkdbf9e0/rr3p0TdQdLua/0tDBaKhliFUDxmVgCPIyuAx+wK4HF0BfA4tgJ4HF8BPK5ZATyuXQE8TqwAHnMrgMd1K4DH9SuAx8kVwOOGFcDj1ArgMR+AxxB8nrJC+NxoyCfazaH43RQNfxvdvAJ43LICeNy6AnjctgJ43L4CeNyxAng8dQXweNoK4PH0FcDjGSuAxzNXAI9nrQAed64AHnetAB7PXgE87l4BPO5ZATyeswJ4PHcF8Lh3BfB43grg8fwVwOMFK4DHC1cAjx9YATxetAJ4vHgF8PjBFcBjYQXwWFwBPJZWAI/lFcBjZQXwOL0CeJxZATzOrgAe51YAj/MrgMcPrQAeP7wCePy5FcDjR1YAjx9dATx+bAXwuG8F8PjxFcDjJ1YAj59cATx+agXweMkK4PHTK4DHz6wAHi9dATx+dgXw+LkVwOPnVwCPl60AHr+wAnj84grg8fIVwOMVK4DHL60AHr8cgMcQfF65Qvi8aoXweXUgPqNriOmRY//cpSh36chd6nGXZtylFHfpw12qcJcW3KUAd+jeHWp3h8bdoex89P7FPHdY1x2AdQdM3QFOd0DSHUB0B/zcATp3QM0dAHMHrNwBJndAyB3A2Xns365j/9wBDXcAwh0wcBv4boPcbUC7DV63geo2KN0GoNtgcxtYboPIbcC4UrkNBLdA7xbA3QKzW8B1C6RuAdIt8LkFNLdA5RaA3AKLW8BwCwQyAXcTSDdBcxMgN8FwBrwzkJ0B6gw8Z0A5A8UZAG6AdQOYGyCcAnYKzikQ10Fd43cN6+ooPkgDyZ7//t+J1u8RiDe8nFacILqW+HOFRmNCKZ8h/+WJFubaIPjTM4I/EYb/glxg/W+aHXwsi9DNtv7+WrMjy19rdvMkaf4C0vwFpZHyhKnv6nxYeRXfuzCDMoqgLEI7F4Z2KUP0sF4wTujnopBt8/3LvkhP+GH5iO6YlDTNDj8Zihtt9pZD4sYgTurX0bkA0nHbWktxwosL0n4nQTYSfr0VJ3U6Cph27XVhMWx7rRSOX3utFE/E9jpKcaPN3nL0216xbXF7HYs6QXSpxI1D3F9S3BqI+y/NDu1p4OO/az2H1cnvj8HY96zHsE0K/0jLhTXNjjykDWbh3RjI7z35YHqKm4C40WY3nVzr9yjQQSzhY4zSV1q/p1p/xyGP5M8r9MeJfhffyjuWy4SSfkJJ79raRa1nZ2dLe/5ks4Nn6RBA8D8VBr9td14SBr8k+J9udmTZwW5UZsu12erM4sJcbaG8WKnOzVaqs9Xp+ZlisVYt1ObnCwulxUJ1tjE3PTddbxQX6vXi4ny1UZibrpYF+zMqdrm+MFsoT1dn5haKjepMo7BQmZ0rVxuzs7Vqbb5Sn50u1IqLM8XFUrExN1ednq4uTs8Xi436/HRjbkawL1Wx63Nzi/MLs41Co9qYL1ULpUJpYbHWmC7MHKPRqC9ONxrlynxhujxXqy7WZheL84vluVJjsT7fKMy3+f6sil0rTVcbi7XaQqXQmC/PVmfnjslmfnbhGMBcsTxTrC7OH5NZo1ivLs4uLlTrxxRLuV6s1maLtdnytGB/rtmpzxDzlM8Hwe/wf1kQ/GK7P30hDP8Lgv/FZqTU7VyxeqyN12qV4lxtsVYu1MuNY617rlqpzRTnXPMszy3UytOz9WOdojhXnS1N16dnqtVj7bS6WGzL/nIVu16arVTK88XZSnF2plaeqdcKc4uNuVq5WC0WF4q1WqNxrG8tHGv4jZnZ+ZljbbO+WJ+tzy3MHOsA7TZ5hYo9WBDsLynYxblyqTRbnp8tzM/VCsVKbbE0Vyq5xn9MMIul+nylON+olCrlxdoxJVGZqxZdp1ucb8x1Y395cL6LcXxf2QzRVjq68aow+BXBvzoMfrvNXAP4mche11wbBr/N/3Vh8Nv1e30Y+bfXdL4ShP9yewy8IQj/5Xb7vLGFH9nJpj2OfDUee8mqR7C/pmCXquXFwrFRvjp9TH3X56aP6eVj5kt9Ya7emClVFxYrhVKtWCzWK8f+K9VrlfmFY6p/YaZ+TNUvHCPX1jk3BZF5cVHw9xvjz1QL8/WZmVnBrxrjLyzMzFaPyVPwF4zxy4sz9UZ5tt1nF43xq9OVRmO6XBX8mjH+dLFQny7Ntttm3Rh/fuHYIuwxq1fwG8b4x2zwcm2+2rafbraWz0K9sFgrzsvc9estfKHhgtC+xZh2K8ynWQdC+jniNcQ6ENJDflA+vA50a7OX17wShzqG47LKO6GjYVUNsRYMsRYNsWqGWHVDrIYhlvTrsH2t0h5Hbw2CX54T/NuC4Bfqgn97CPxiZ27zDcCP7Phv498B+JkA+AfCyL+Nf2cY+bTnNne18ENg322P3baPDoaRe9u+OxQGvz2nuScMftv+vTcMflvvfDMM/rzg3xcGv23/3h8Gv20/PhAGv23/PhgGvyb43wqC31lD/HYY/Lb8vxMGvz2/eQjw7caVUlvvN4Pw38H/bhj8dv1+Lwx+W/9/P4z82+3/4SD45bb8fxAGvy3/R4LgV9r4j4bBb6+JPhYGv73m93gY/Lb98EQY/Lb98GQY/Lbd/1QQ/Ol2+386DH5bPz8TBH+m3f6fDYPf1m/PhcFv96/DYfDb/etIGPx2/3o+DH67f70QBr9tn78YBr9tnx8Ng9+2z38YBr9tv70UBr9tP78cBr9tP7wSBr+tn18Ng9/Wn68FwZ9t6//Xw+C39ecbYfDb+vPNMPht/flWGPy2/nw7DH5bf/4oDH5bf/44DH5bf/4kDH5bf74TBr+tP98Ng9/Wbz/fwo8iszNv7br9BRV7oDNvFXdW0p21/VlrU8vdT9rQwr65fugTtx9YvO2L93xjoX437oRlou5T0PgeT6lLWN/610K96pZv1A8eqn7jTs47EYM5GoO5sYP5yQN3HLq7unjo47Xa3fWDBxkhpyBHMai5Duo19bsP3nLgDkZbtzS0T369essdn60x2vqUaHJ2epLya39d0PYwcQ8IsVBGQmeDQkfOSk/Be8N1pFqaciD9HPFqy0/nTP4U8cPyGSHZ5RVe8xTnAs8n8wqdvEJHwzpiiPW6IdbzhlivGmJZlvFlQ6yjhlivGGK9YIj1kCGWpewt+9AbQ4r1jCGWZZuwlL1l+zpsiGXZty3bxHOGWJY6+m1DrGEdH3/SwpqIem0H67MTDnNjGPyyyOIUjyyQvthKaFtlYv4KFscJrRxhGZet6Csb8s/1fArwgzKIwzqlT6wJJS5EneY95Wb6cek1e1nSb/LgY/qpqLcNbyJZbA4ji5Kv3jYBTaHv5nUyS67VF+65+bIDN0cUsiQHkdvplE7OU41EvfLeGIMV0e/T6V0W8DA4vkX2jfqhxa9fVb355nrtGPcHKWVP1k839fe+rh5Y7aV2SyD0l0uV+LqUC9LkXXXIgsPtB6q1T1bvPHjP7fUREiXOgFmcCMfF5qrKAEv4LkfppKolyM1Gbf0HcbKRXwNOKZjS67FMp8TkY03D70aU9HnCyiv5hPesJz9iYD5uSoOOfFKOKOqMDlr506zkhOl2xfJSu13olZy0I1PYkbVYSmMFIL9SlxuVOB5FxwAL058CZeRRC0fgMXq3t1VhecJ0QW6mZpS4rPJO5Otu7O/KdJcN64bbaZh6SO8FhC3NQMOV19LUZhRhrfpKIU29Ir9Sl5uUOMESCwnbKabfCGXE9Pgs+fHdNLVTbNPcTjWLE99hO/0gtVOsG26nYeqhuJi2nQr9XBSy33TaqdYutFmM1i4kr1ZfvDKetr40rNcNsV41xHrOEOuIIdYbQ4p11BDrFUOsFwyxHjLEeskQy7LdD6u8fmSIZdlW3zTEetEQy1L2lmV8xhBrWNvqO4ZYDxtiyQkbnq8IvgsTUa8tYD23QnpSDnyH9HNRSNutYytpctXmRmFXMottfjYr/GxW5CN1uUWJE6ytrd9o02P6zVBGTI/Pkh/ffadVYXnCdIFt+i1KefAd2vT3tXC5Lbqwr/V3QE9olbD1OD07ocjZsh9NKHVluUYk+NvC4Lflvz0M/rTg7wiD3/aufGoY/Hb7OS0M/pzgnx4Gv+1N+Yww+FXBPzMMfk3wzwqDXxf8nUHwS+3+uysMfrv/nh0Gv91/d4fBb/ffPWHw2/33nDD47f57bhj8dv/dGwa/3X/PC4O/IPjnh8Fve9++IAx+W/9cGAa/rX8+EAa/7bn5oiD45faJmYvD4BcF/4Nh8Nv2WyEMflv/F8Pgt/VnKQx+W3+Ww+C39VslDH5bv02HwW/rn5kw+G39MxsGv61/5sLgt/XPfBD8Sls/fCgMfls/fDgMfls//FwY/LZ9+JEw+G378KNh8Nv67WNh8Nv6bV8Y/LZ9+PEw+G39+Ykw+G39+ckw+G378FNh8Nv6+ZIw+G39/Okw+G39/Jkw+G39fGkQ/Om2ffjZMPht/f+5MPht/f/5MPht/X9ZGPy2/v9CGPy2/v9iGPwZtw796611aDnjiPdq8Uyf+yf3Y2WN3QX0tLgW4jH9b7QiHL3fbNFL8+WliSDlLqbyuIv0l+vLSxPED8uHz7KsU3jNU5wL7zQ76Tguq7wb8WC9a4j1kCHWa4ZYRwyxXjHEOmyIddQQy7KMLxhiDWv7esYQ63VDrDcNsSzbl6W8XjLEsmxfln3oVUMsyzZhqVflXN+kEsd2BHq4MBy3U5/zEPq5qHfcDmFHrI/SyTXl1R40w1icCMfFRrFgXJbe8dWezzS7fy/lag9eqdBEwFd7sEwbYvKhLCLl3YiSfj1hrVfyCe9ZT/4oCt6ci2Gdq3Quc2p1g2US+pNRr8wzMX8Fi+OEVi7SZb7PSHa+siH/rNLwuhHKIA5rQ59YE0pciDpd7yk30p/08KqVYx3JRBsytCmSpJ/y8IXppxTakjfwJeeST4baJeelXOwVuW2ndKIHRyK/HkSsiH5vp3fZSL/Y65vyp+nPwqcLeQVLliJWTYJ2WDUJTmyTQFO13JQmot6y7mv9LQwSip0dyPUq9kDfNS251cK9rYakqWdcjUNViSeANyiyHaP0dVidvLBFz5VHbjsu3HP7bV+uH7r7lvq9dc0JQVLbxW++uiDfafW1XRd85s+wqrHQ5pWv7bvQpxrjJhRajUnVS7BSYxMKZho1htW1VqEr70aU9D41xgvlWU9+FyaVd9zUA1mwqZs6zyRCzcJ89YzyGbCpozgRjot9PEdszXhfr2D6jHdf84yUd0mGsG8UysbQ2+Chx3tlmHeM0l7aqqTAXaKA95C4DKujUjusjkon9qiUVfJxUxp0jUrK4UI+ii//RNQrj32tv4VCvTRbqZTni7OV4uxMrTxTrxXmFhtztXKxWiwuFGu1RqNSnV2o1GcbM7PzM9PlufpifbY+tzBTKjYqWrfNRHbXBJxhfYPHkOfJJBvyLuAxgw0Qj+nvbNFw9G4CQ16uz9xbvf2WWvVQ/ZI77rqnfk+99sUDh+oHP35H7ZJ763cc6tusv7TZ/fuzzd58WtAOWogb7LAHHwrVyZiyRJF+qGAtxWHvkM+zs1tw1ETaah8fYuDVZoxDJzejFIercWMUhwPYOMXhxdE18MyB6xHrxcnlz3MdXE4nYV3Uqe8vKTgiqy/D7yyld0G0p6S/svV+POrwiWkk7xilv2ekw//HWrcGNa0j/ExSfomPok5bvYp439f6XRgspB7shX6OeA012F9F/LB8+hzssVmwOBGOi81NdjkH+6shThMBD/ZYpqtj8nGT53cjSvqrCOsqJR8P9lp+xMB83JS4++FK05cV2tz9HoHu94kd8XS/HPXKgbvgWoWedNerKa0L0l2voTLta/0uDBSmZ9N2V6GfI15DdddriB+WT5/dFZsYwl9DcJIG02K4BljC9Dn6zdX+RSUfBxHlZNQrAm4O11Kefa3fhYFCehcYQj8XhWyeneZwLfHD8hkh+VwXRj5tfq5T+LlOkY/U5fVKnGB9pfUb1RKmvw7KiOnxWfLju9daQskTpgvsAuN6pTz4TuTrLJejI930pG/9Etjxb9C8AfsftpU4dX6VQjuv5Jd0Gp38gHTyCh3NNeo3mt1xU544tH6vIUx06cJ7ouhm5AqKQzch7Pbzcg/mFQqmq7uPj3bw3L+vQTpNFbPZ8FXgB/Pi7zFK68Jdze44Sfsb0K7+OrUrHIa4vq9O4NtX35JOZIXthOsU+zPXKeoJlr/WHyXuK0q5JO4GD+aNCqaT29xodzqUO48tX4P3hqbGTNqxRejnot72FGJs0do3yofHlpvCyGc6Q/jIz02KfKQu9ytxglVt/caxBdPfBGXE9Pgs+fHd79LYsh/S8tiyXykPvsOx5X8e6S4b6w/tr+DyO+7fKBupX83Wkj7l+Pn9ke6ySD6UJ45HX4B4TP9l2Kz+A48O4/r7KpUxSfdeo5QxrR6/krC+6uHrpgSsqwkL899EWPsTsK4iLMy/n7CqCVgHCQvzVwlrIQHrEGFh/gXCWkzAuoewMP8iYdUSsO4lLMxfI6x6AtY3CQvz1wmrkYB1H2Fh/gZh3ZyAdT9hYf6bCevrCVgPEBbm/zph3ZKA9SBhYf5bCOvWBKzbCAvz30pYtyVgXU9YmP82wro9AesywsL8txPWNxKwvkVYmF/yTipYoudlTL4D3h+P+bDQzxGvtvx0bJY7ol65onx4tf6AwmteieO52QGFzgGFjob1VUOsrxli3WSItd8Qq2qItWCItWiIVTPEqhtiNQyxbjbE+roh1i2GWLcaYt1miMXjj89+ds/iAnUq6tV/X6V8qIN4vZPnjZgeMeLsc9ym+FoCz1uJ56Xa6e55G2Et1U53z9sJa6l2unveQViYn/XkQgLWqYSF+fux093zaYS1VDvdPZ9OWEu1093zGYQ1iJ3+7WY31iB2+k2EtVQ73T2fSWVcqp3uns8irEHs9O80u7EGsdObhDWInf5dwvLZ6XckYH2PsDD/HYR1wIPlnndG3ViY/wBh3ZmAtYuwMP+dhHVXAtbZhIX57yKsuxOwdhMW5r+bsA4mYO0hLMx/kLAOJWCdQ1iY/xBh3ZOAdS5hYf57COveBKy9hIX57yWsbyZgnUdYmP+bhHVfAtb5hIX57yOs+xOwLiAszH8/YT2QgHUhYWH+BwjrwQSsDxAW5n+QsL6VgHURYWH+bxHWtxOwLiYszP9twvpOAtYHCQvzf4ewHkrAKhAW5n+IsJoeLBduaHZjYf4mYX03AevzhIX5v0tY34v8ZSxSGTH/9wjr+wlYJcLC/N8nrIc9WC7c2uzGwvwPE9YPEvgqE1+Y/weE9UgCVoWwMP8jhPWoB8uFLzS7sTD/o4T1WAJf08QX5n+MsB5PwJohLMz/OGE9kYA1S1iY/wnCejIBa46wMP+ThPWUB8uFW5rdWJj/KcJ6OoGveeIL8z9NWM8kYH2IsDD/M4T1bALWhwkL8z9LWM8lYP0cYWH+5wjrcALWRwgL8x8mrCMJWB8lLMx/hLCeT8D6GGFh/ucJ64UErH2EhflfIKwXE7A+TliY/0XCOpqA9QnCwvxHCeuHCVifJCzM/0PCeikB61OEhflfIqyXE7AuISzM/zJhvZKA9WnCwvyvENarCVifISzM/yphvZaAdSlhYf7XCOv1BKzPEhbmf52w3kjA+hxhYf43COvNBKzPExbml7yTClam9Vf2jN6C93Z7NOk/DSz0c8SrLT+dPaO3ol65onx4z+hthde8Esdrjm8rdN5W6GhYNxli7TfEqhpiLRhiLRpi1Qyx6oZYDUOsmw2xvm6IdYsh1q2GWLzmOAjW7YZYdxhiHTDEutMQ6y5DrLsNsQ4aYh0yxLrHEOteQ6xvGmLdZ4h1vyHWA4ZYDxpifcsQ69uGWN8xxHrIEKtpiPVdQ6zvGWJ93xDrYUOsHxhiPWKI9agh1mOGWI8bYj1hiPWkIdZThlhPG2I9Y4j1rCHWc4ZYhw2xjhhiPW+I9YIh1ouGWEcNsX5oiPWSIdbLhlivGGK9aoj1miHW64ZYvOaYdE7ustaz75yc5NsPcXyXLkt5MD1ixJ3DywLP+xN4/gLxrNHU7jfe2eyOw/uNfCYf7zzz3Ue8w8z3rfB+I6/Z3gBxfNftRoiT8mj3Gzd4yjMFGHyvF+/n8h1u9E5zHcWhd5rrKQ7v536F4i6HuBso7gqIuxHKKvdzx6isn2q9D+zhRXUz57sfnYn5G0W96+IucL9FL0Q5onOVIR3E+kyzm87VhnQQi70xXWNIB88as9yuU+hIu8F+a9huUt+lEfq5qFfHhNgX0XwfXKfINaWrEXbvgOJEOC42igXjsvQuhGcgdCOhiYCvmWKZvhKTD2URKe9GlPTXE1ac24xsDD2tKjEfN6UMvY/zDHQtxGP6/S2V6273XrKjkz6OFsqDnYMJ73HOwZgHSV8DHj62Q8ccjSnXdTGY3xzt8HLzqI4ZKZhaub5C5WIericeJP1tUK5LyevSV5T8Ucy7TNTtdQnz8m+tzXyZ0t+QUB6uJ0l/l6eerlV4wD7JMmUeOM1XYni4R+EB1drigTvvb6m1iMIoPLMa0kTOHpCuVXDigojBFU+aYpZwWUUxHfm9VuHJFVn8/9Xqt9cP1WMKzbo6F0NsJNIDm9CSz4WwrorSD7dCPxfpbXGfDT9e10koHz6GoLlCyitx2DC4AfrorI86DjIPHjpwd1xbSDsOZxR+OH9EWBnlnQur7Wfp7SelucbNBsWJcFzsuCpLaiYys5CwFHPNZ+YgpphrPhMLq+tKha68G4nizSnNFGMnjD5zDDEwnzYs8hCrDcHo6BHTPw/Dnzhy5DwSfr7ZiWNHjcs/eyqmPlV2gs6e8gQnaTAthjywhOl9jhpdEOcWabpjWIdQMwV28IRB4qpAmxesFiCOF6wWIQ5dR3PIKmWX8rpu9PkdHVxOx7xi165SHHabBYpDC32R4nCxsEZxuFhYpzi8NN2gOFx8lQNj7BP2v6XFtkCjnrrYJrSmol654gJmnBWkuT3OK/mv9NDZPCCdzQqdwLIshu2vnY8q+iwUpM/9QuK1v4LFcWx9hXaj7RuyXeB61laDfFjX9YkV2Aous8mhlVvTrxqvWjl49UM2J+ZavvHdFPhvezY32PyYCiKHcmrnjUI/R7yGao9TxA/Lh2eTpyi8su5z4YlmJx3HZZV3Ix6sVw2x3jLEesUQ67Ah1kOGWJZltKxHyzI+Z4hlWcaXDbFeM8R6yRDriCHWm4ZYRw2xLNuEZX+07EOWbcJSXi8YYr1hiGUp++cNsSxl/7ohlqW8LHXhM4ZYlvIaVl1oKS9LnXMy2EyWbcJy3LaU/Y8MsSzbvaXsXzTEspS9ZRkt9YSlDWApr3cMsd4lrLTzekm/SUmvrUvJWiauq0peWUPBtUnrHdU4OeEBUqHvtkzk+EKtvnDPzZcdQH+L7fwoB5HbNKWTLcER4gFlwVgR/Z6md1nAw4AfDk2zZRZmPbacegdb6C/Xlpl22Fxb99Q+8CF58xTnwqPNTjqOyyrvRjxYrxpivWyI9Zoh1kuGWEcMsd40xDpqiGXZJl4xxHrIEMuyTVjK6wVDLEt5PW+IZSmvtwyxLNvqYUOsk6EeXzfEspSX5Tj0jCGWpbyGdRyylJelvrdsX5Y6x7I/WrYJS5vJUvY/MsSybPeWsn/REMtS9pZltNQTw2p/vdO0w5I1GO3CMB+T9n2kUqOD+W9KgaXNhyX9gpLet9ZThfySV9YeFiHOYe1r/S4MFkq++lgAmkJ/KWs9IrcipeO1nv2QrxqDFdHvIr3LRvpaD59b+iutc0si30Dn0dRzkXxeEc9CnULl09YX8V3cWiWm0z74LPwELn8tQ/SkHHEyySkyMeSnvbZ1ZUq5Bj63t5iJevVIVqEp/Epd+nTe/tZvvHaA6flD7fshbj/wMUbv/larz+SjXn3IH9NNq3fdGuz/MNZdtqWeM0VcTZ+n6Q9LpYNY8mFertsxwHoA0vAHCEVOo/Ae24d82HuM0v9OS45OP/91OO/u0lyr8Odk/3fH/LxiXuSVbxjPwoeDf7eFqV3rkfrQ6odvzU0pdDVM1pn9ntc9ReHBh4X1tZHSowMMLT3fZJb0/xjq7tIdOmZc+2GehR62H/zgOrcfSf9Pl9B+/mjMzyu3n42RXv4d0H7+mNoPytjXfjZSHLYfkZE25vIdgX7HXMw/5aFzNcUh79dQ3NVKuTIUh/xd7eFvo8KDjGt498RuXJtu8DiFQdsv2kxxVYi7nOLQLr2C4tBOZn2PjqN5PEVH0Oz8Bh07s/MbdNS8keLQ8TJf18SQpd9YL65b/Eofd5ew3eynOOyHKF+UFXpg0Po829F/Aef//9l4Nz2fvYkOheza3Uw5zfiN9JfL3ryc+InTKZpTJcmbpzgXHml20nFcVnk34sF6yBDrNUOsZwyxXjfEetMQ66ghlqW8XjLEsmxfrxhivWqIZdkmjhhhuef1kQ2WC28Y8eWCZZt4zhDLsk28bIhlqVct+7ZVW3VhWPWqZZuw1F+WfciyTVjK6wVDLEt5HTbEsmyrlnytjtvHT16W9qqljra0Ad4yxLLUX8PaJiz1xLCOQ5ZzGMsy/sQQa1Wvnhj6y7IenzXEspTXsOqcFwyxLOvxeUMsy/5oOdZa1uOw2qvfN8Sy5MtSr75oiGWpJ4ZVR1vyZSn7YdUTljb5yTCvtRy33zbEsuTLcl5rWY+W/dFyDmO57muJZdkmuA/Jvie6YpezKy7IB3PGKP0/be1DTxCNTGS611zxnVcT2jcEop0helGk73PzeQXkh89cYtzoALzO12eny6V6rVhdnFuoL7TPON5AvPK7EaDv/t2opPed0fxqGFmX5NxFttnBvxHk6sIoxN1AcWMQJzy6cx0XEP9hzuLMlNLIH+nnlfR8vjNtXW6Mutsa9kftzAiek+C+FKYfl1OfGRH6OeLVlp/OmRFNl16uyHjSI+N81KujHmt20nFcVnk34sE6aoj1hiHWc4ZYrxpivW2IdcQQ6/Uh5euwIRbbiYNgvWOI9bAh1ruGWJbyesUQy7I/vmmIZdnuLXWhZT0+b4hlWY+W+stSXq8ZYj1jiGUpL8s+ZGlPWMrrJUOsVb16/PSqpex/ZIhl2e4tZf+iIZal7C3LaKknXjDEGlZ79QeGWGKv8lqhe8b7J2HX0wqlsGtIne9zaGtaWCb+ADnKKhPzV7A4Tmgt1zdXtLL52gGud6EM4rBu7BMr7Lpap05v8JQb6U96eNXKcYWhTK4nrLRrS/3W7VTUW5+SN3Afa69zXu+RE9Jfii8LkVuJ0l3Z7MiB5X1DDFZEv0v0Lgt4GETGuP54DWFpOnkjvONPL2Jbu5KwrknAupKwrvTwdX0C1tWEhfm5Dd+QgHUVYWl14mvfiHWQsLT2LVhfTcA6RFha2xSsmxKw7iEszM/+a/YnYN1LWJh/P2FVE7C+SViYv0pYCwlY9xEW5l8grMUErPsJC/MvElYtAesBwsL8NcqHd4/Rp4B2Vxbv19+7ppsnzT8D3l2N+wL8f7+mg3n/mm6+Mb/4rp6i3+75KuIZZSE6SnT8JnhvreORXhTpto/QzxGvxvy0bZ9NxA/LR8bHlJ8XZZcWKE6E42KjWDAuS+/4avYGyreUr/1uhrg0Qw6WaXNMPpRFpLwbUdJvIqxNSj7hPevJjxiaG3IuP7q2kPdfVmiPUfonW93RmSKXkOsPjRbKQ2TK7UTcj3Aa5kHSPws8fGyHjjkaU66NMZjvgMo5skbHjBRMrVybqVzMwybiQdIfhXJdSl9SxvbKfeCuZjdvlyu0oph3iI15Oc5HNymve/4SPHOc1m6/TOlxGz5Ne5X0b3rayikKD1herlfmgdNsjuHhxwoPqFoXD9x5f0u1RhTwNJGmCrkquQpOUXDigojBFU+6A+PIb1/zQxW2UaGxMYZHzOvEIydSavXb64fqMQLisWUqhthIpAf+hKXkc2EiCjocpzYPhH4u0tvtPht+iqzHhR+WDx/l2KzwmlfisGH0Q2d91HEJcPDQgbvj2kJau0Ebrzh/RHkzyjsX8LMcmrsvdofUr7svzM9uoUK7FdPobB6QzmaFDmNp0wUXbml24jH9b4J+PbBbxxyJwZQpvKRvKOXR3FVJ+puV9A2ljCJLdN10c5RMG2XJ49HX++T1FiU9un1qEK/I3y198nrlMvN6ncLrpEKbdTuW63jodqGfU8oYQrf75OpCn1M/bOosToTjYqNYMI5V+OWU7tJm9++lTP1uhThNBDz1wzLdGpOPuwS/G1HS30JYtyj5hPesJz9iYD5uSlo+F36h2ZsnTde5lfD3tX4XBgrF6bRdR+gvV9dJajdsFt2m8JpX4nC6hnFI5zaFjob1FUOsuiHWFYZYVxpiXWOIdb0h1g2GWDcaYn3VEOsmQ6z9hlhVQ6wFQ6xFQ6yaIdbNhljXGWJtMsT6GmFp0544M2opU1dex7klhv5mJX9EeTP0Ls0UDm0ZnnYI8+ORf8ozRunXt7avcXkzS2mYnzRfumRbaV/rd2GwkNqEF/rL9aXLpKkX2yE3K7zmlTge7+sp6Vi0cRfEts8o/HD+iLAyyjuM09o4LgNIG+cdTsyLO5zabrjYJdru9hTxo+2UY/prKf1+4EFLL3j8FYSzlD6n7XKfEkMP+cN3vuWj/TFYmpd1F77V1Hk/B3jnZZ2qwp+2dCjptV37KqQRfjTZ8BheVcqD9fkAlUfSX6iUx3dbc6L1dxTiDPVJzfFxN/DBch1rdpfbJ0MXWOaLSnqUJX91F+2b/RSHNn+V4rQvLwgP2kkZbHvc77Hf4dcR/ijFVyK0kyjc7/cr/GB67vdV4EFLL3jc1j6i9Htf+0WZyKkTxtzn6Y9a29BO+6VtG9wfsa+yHbyglGc/4HN/lPSfTtkfpa6PR39EuXJ/9MnQBZa5dkLI1+dwjsB9DvvjAsVhm+c5njYOp+2POA7zl2D4FBtiuXie5+N4qY2nX4R4TH+Npw/sj3rL5lvirirp90Ma/ooMyrJKcci7zFW0tizpwrbl6RmtLe+POoHbsk8WLvQ7nkt956PkcQfndvuJjnY6Ek+YcnvFdiZ5XXv9fdoixK1IOdW7uhXdDn1vRafcruDhmHeAB92uyFG6zzS7fy9lu8J3wgsxtQ8QbYrJh7KIlHcjSvqNhLVRySe8Zz35ESPuY4JYfjzZI+83KLTHKP29oKo/sSOeLp8mZPm68PPNXnrH72BpsZi2u67wg6XcXQU+T3CSBtNiyANLmD5Hv7naL2v25uMgogz7bcrptv+mqxQetO8pcTPFkYm//YRW1jp45pBVyi7ldd3s8318+wm7+9UUh93mGorD1ctrKQ530q6jONyBup7i8HAif08LDxnKrgyrmudaqkbaQKDvM6nfZ+V6XrUeThjr4YvN7t9LsR60q1VprYcrY/KhLCLl3TBYD1o+93u9kidN1wl0HTW1Oy+hv1xdJ6nd8CbDVQqveSUuB88Yh3SuUuhoWLzBl2QpD7phwebCxhj6I0r+iPKyTuAJ7ilKWbQNC9ZF45G/f/B9jl/ybMpp+V1YHWp6+0u/Z6a1Q/J5JY7HnKmUdCzauAsyBmUUfjh/RFgZ5Z2GJTjuHc7GuI1LOcej/maCv660cZH1WiW/w99LCzZXKulYh+HYe6WnHFdTOTjNlVQOSf+3oRwfo3IgT3z1ERchuZ9eQ7zva/0uDBZS91OhnyNeQ/VT7Xq4tkib0iSMu32eITgudlzXSOqOn252/16KSYjr7ZoI2CTEMl0bk4+bPL8bUdJfQ1jXKPmE96wnP2JgPm5K3P1wQUkzX7j7/YFnQQnp8gxd64KbFHra18u5u4Y5WzI9l7a7Cv0c8RqquybtF/XZXXkbSOCvJThJg2kxYDfA9GwhcrUnHdeSdC5+jHj+D/DR+f+t9ax9gJ1vOfX7AfYNCv8anfyAdPIKHekCayGfOFGXuAmlrBK3DvIdoHzrIe4KirtcKRcvHGmYX/JgflmJc3V3ba5DK06NaVuiWh3Etec4LHZ+gvn56OX1CVjs/ATz81HoryRg+Zyf8JH2GxKw2PkJ5k/jSAWx2PlJv45UEIudn/gcqXwtAYudn2jbv4J1UwIWOz/B/GmcsiAWOz/p1ymLdgxlqU5ZEIudn2B+Pt61mID1IGH165QFsW4jLMzPR7TrCVjXExbm56OdjQSsywgL8/OVr5sTsL5FWJifj45/3YPlnrdE3ViYv5+rS2Fu/RVTr+YN660/kd2tCq95JQ7HIoxDOrcqdDSsawyxrjPEut4Q6yuGWDcYYt1oiPVVQ6yvGWLdZIi13xCraoi1YIi1aIhVM8SqG2I1DLF4LPPZ9e55a+vZZ9dLPtRnvKyhLZ9o84C4eQMujVyXwPM24nmp8wf3vJ2wljp/cM87CGup8wf3fCphLXX+4J5PI6ylzh/c8+mEtdT5g3s+g7AGmT98u9mNNcj84SbCWur8wT2fGXVjYX7WuQsJWGcRFubvd/7wnWY31iDzhyZhDTJ/+C5hDTJ/+B5hLXX+4J53Rt1YvvnDLQlYuwjL5+Hk1gSsswlLcxMhWLclYO0mLMx/G2HdnoC1h7Aw/+2E9Y0ErHMIC/N/g7DuSMA6l7Aw/x2EdSABay9hYf4DhHVnAtZ5hIX57ySsuxKwzicszH8XYd2dgHUBYWH+uwnrYALWhYSF+Q8S1qEErA8QFuY/RFj3JGBdRFiY/x7CujcB62LCwvz3EtY3E7A+SFiY/5uEdV8CVoGwMP99hHW/B8uFG5rdWJj/fsJ6IAHr84SF+R8grAcjfxmLUTcW5n+QsL6VgFUiLMz/LcL6tgfLhVub3ViY/9uE9Z0EvsrEF+b/DmE9lIBVISzM/xBhNT1YLnyh2Y2F+ZuE9d0EvqaJL8z/XcL6XgLWDGFh/u8R1vcTsGYJC/N/n7AeTsCaIyzM/zBh/cCD5YJ4pJtS8v+AsB5J4Gue+ML8jxDWowlYHyIszP8oYT2WgPVhwsL8jxHW4wlYP0dYmP9xwnoiAesjhIX5nyCsJxOwPkpYmP9JwnoqAetjhIX5nyKspxOw9hEW5n+asJ5JwPo4YWH+Zwjr2QSsTxAW5n+WsJ5LwPokYWH+5wjrcALWpwgL8x8mrCMJWJcQFuY/QljPJ2B9mrAw//OE9UIC1mcIC/O/QFgvJmBdSliY/0XCOpqA9VnCwvxHCeuHCVifIyzM/0PCeikB6/OEhflfIqyXE7AuIyzML3knFaxM66/sP70C7+32eyqp74UJ/RzxastPZ//plahXrigf3n96VeE1r8TxmuOrCp1XFToa1vWGWF8xxLrBEOtGQ6yvGmJ9zRDrJkOs/YZYVUOsBUOsRUOsmiFW3RCrYYh1syHWLYZYtxpi3WaIdbsh1jcMse4wxDpgiHWnIdZdhlh3G2IdNMQ6ZIh1jyHWvYZY3zTEus8Q635DrAcMsR40xPqWIda3DbG+Y4j1kCFW0xDru4ZY3zPE+r4h1sOGWD8wxHrEEOtRQ6zHDLEeN8R6whDrSUOspwyxnjbEesYQ61lDrOcMsQ4bYh0xxHreEOsFQ6wXDbGOGmL90BCL1xyTzsl9ofXsOycn+XDdia8KZikPpkeMuHN4WeA56TzeF4nnQc7jbSYs7Tyedm/szmZ3HN4b47sC6PSI76KhxxB2RnQ5xPH67xUQx86I0OEQOyNCh0NSVrw3NkZl/UrrfeAb3arzIZYHyj8T8zeKetekXeA+gzfzc0TnGkM6iHVjs5vOtYZ0rvWU5zpDOogl18W1fsguvzU9dL2HDua/PgZLrli7IHcnsb+NUfrbW4Jxdf/Y7m5MTedMwLvPecoqeaWP3ABxlvsdgv/VMPhlkYV27hjLJPQnFdn1076QVi7q1b8h9oq0siH/3A5xTwNlEId1Y59YE0pciDq9wVNupD/p4VUrR1zfRDo+1/lf9fCF6X3n0kWGuM9jKMOST4ba2XY3psv4Uqsv3HPzZQfwGHI7P8pB5HYapRO9MxL1tsEbY7Ai+n0avcsCHgZNt22M4VPoJulxzM+2yPXEl/ZX6PA7pqPxrHmokXHC2TxP0F15aXfougPz8qckJP1Pcx3Mp1vPIku0C7mvaC5E0McAe/aR/HGefeLGvSMw7vFXqtdRmbGczCNijka9dF0QfwrMww/Jjgyk51U7UmhNEb+ZqNNPp+i3exbbLaztOz2v9QcJk4q81lHcDUp5ND0+QXGou3hegrp0PcXhHvjlFLcf4q6guCrEfYniFiAO5ygcsvQb68WV/c9zHVxOJ0Gra/4kBPZbnl+tV3CljeCczXoM4nJo9pTQzxGvxvy07anLiR+Wj+jplC50sGuyOBGOi81NJQMs4TueQk5QvqV4vEIXLpoIeOqAZboiJh+rVX43oqS/nLAuV/IJ71lPfsTAfNyUMvQ+zuMVD0uS/ldhWLqEhiWNlm9oFN7TDo2S/jc8Q6OkGY0p1/oYzD8Ac+C3cjpmpGBq5bqCysU8XE48SPr/CcolTgmjqLe9ch+4q9nN25cUWlHMO8TGvBzno5uU1z2zVzyM09rtVZRehpc4mXJbkfT/awozCnnA8nK9Mg+c5ooYHv6BwgOq1sUDd94f44tzFJ41VchVyVWwTsGJCyIGVzzpDowjv33ND1XYeoXG+hgeMa9LI9ZArX57/VCcs1IeW9bGEBuJ9KC5CWPzINBwnNo8EPq5SG+3+2z4KbIeF35YPnw09wqF17wShw2jHzpLdVwbZzdo4xXnjyhvRnnngussv57pTqctS2reNCW9TAVwLMapwxaIx/R/AnqFvzylLXNhp02zpIPTEJ6OaUuL2nIPLh+8h93sxC3PVw2LJe3LU1jesWa3LDRXCZieZae5Q8CpmNR9ntKjHLUlEV6yxWk9bgM9AdN0F0abnXRWcpydKxTa/aSFj8sPGEYhHtP/WYtPdPguf0cH4LMxWy02ytVGdbpaq1UWq7yc4ILUmdMvrj38jJZ8WKfKM+skn57KK/nXxWDFbYOMQnwXndaDtg2i6VGsF57LaPODqUgf65LoaNNGTQ68HOGbjk8SD/tavwsDhfSfSBL6yzUdn0wpV5HPhjDyKWQIH/nZoMhH+zIy1p37l2/9xrEN02+AMmJ6fJb8+G5TqxHnCdMFca2aUeKyyjuRr9Olk+u6y4Z1k4n5K7j8jvsDyob7A9jbXcvd29d1l0Wbt2NecdPI8/aLdnQwT2thTlF+rf60OT1OJtiWkfxxcyTWb5J+J+g3nqeNUpmxnMwjYuJyN/LMy92S/pwWD2H7mb7czW6LeeKHfAXRj8XGkvXjaAh+EvQjymdZ9GOxsaL0Y9mjH+9odvPQj368aJn0o9Svrz8slQ5iia4VXYj1yB8m8tW7RgfzS7rQbXQSMLmMrv4+RuOJ1DO2P81uG6P0/9f2DuYnaDxBfSx1OhXF1/FU1KtHWKdjnfl0QF7JPxqDFWeDT0I8pv+cxwZPsuHYBkeeWCfg+KWVX/rviAcrUt5JerT/ed1ritJOKmknFFr7Wn8LA4ViUWjlSSaaDg37bcViUfuolQT+1CvyzB90cuFLzU46DjyHxjK5tvYkrF1wOuYH62tjDKbWZnktX8qstYMpwuX+gvISW5xtrVtbjcnpj5vW6Xg85rkgxzEniJZx3Ze4fjFw/bJ8OGj1K3y7+v21PuoX63ATxSEd/kQGjkWC4WR/iGzeYetLS+kvvzZgf9HkyUfHtTmTJk8+Uruv9bswUJiuaB/Vs8OfLY6RDLav75TxPuqvkoZtUBd4Li5tdlTJ7wLPzST9t2DsHd+j0/fpi4jwJC3WIx/B3hx153VB5L6F6O9r/S4MFMr1NDYt0s8Rr7b8dOZgW4gflg/vCW1VeM0rcdw/tip0tip08krci007rCOGWA8ZYlmW8agh1iuGWG8aYlnK/h1DrNV67A/rXUMsyzZx2BDrVUMsS/31hiGWpewt26ql7IdVf1m2Vcv29bIhlmU9WrYvyz5k2b5eN8R6xhDLsozDastZltHSnhjWehxWW+7HhljDaudY2pir9sSJ0Ycs9YQlX1btyz3z+togfL3VtMOylL2lDSBjreCJ/Hg9LxP1rhtK2i2ttcawa22V4qTCfybqpr0tEO0M0RNZ4zukP6nwI3znlLhBzlNOF2dnSzOV2nRjYWZuerqeIXzhld/xudjtSnptzVBkvSMKIetyTTt7vB3k6sIoxG2juDGIEx7dOvQFxP/2QPynkT/Szyvp72520vVTl3mFDp+LGAQrv0SsjVGvrhY9oZ1N4f0w7byg29t4GTbtUUel2S/A/V7WI2HW58up9YjQz0W6Ht5nwk9nv2Az8cPy4f2CLQqveSWO9wu0fYktCp28EsdzpkGwjhhiPWSI9Zwh1kuGWM8YYh01xHrZEMuyTRw2xHraEOsNIyy0/yz4et2ILxfeNMSy7NvvGGJZ6kLL/viKIZZlPb5riGXZJixlb9W3I+MyWraJVw2xhlVPWPJ1MthMq2Pa8ZO9ZX983hDLsow/HlK+LO0JyzLKWCt4vKaI8908xUnao7SmGGg+XplU+M9E3bS3BqKdIXoia3yH9H1n9XJK3CBrirXpSrHSmJ9eqDXK9dpsI0P4wiu/4zVFbX1IW1cIvCZX0NYUed1wFOK2UtwYxAmP2ppimPXnciGN/JG+ttbPa4qD7LPwmuIgWPklYsmaIo7foie0NUU+Ez6llAfXFPkOxGukk1AGhmty6n1TvDPM/LrwpWYnzncniHHwXdwdJ74DLOl/AmfM36Z1WMRy4QqFPz63j/kc5rvr49NNKenWw/ub64eu/Hr17nrtyvri3fVD2UhnL4p0sbTVRRQfpGiMNUG/+coWY8pSd1qfT/IXseKulPHxfEn/iy2RORU20TqeP0H8Cq19rb+FAYN2TYOH2jCuJEpLviqdDcKP/6o0yoeHxzDXfUoFt0wvqhnb4e3NXtkwH+wpNcTVX63dCF1NBUp/ZrcsfwdU1t9c30nP/VSrC74SmlN40fqQ+7ev9bswUJgraO0m4+FH4lBdaun5SqCk/03QE+LiUDOlslB+F0Ypbp9J+UtFzTUU6m400+LqFNNLneajXrlJObW2iMOvtCmtXaS5Fq+1GUOZpXZbJ/SXy02EVjc+NxEhx4Y4Xaxdp9bMR+5vOK3NKunjrszis+THd/+k1dbyhOnCIG4ifp9MLc294lJ1OMrG50KApxT9uhDw9TvU4+he4Y/X6zQ19wouNJudeEz/r8G9wk9JH6CMsA29V65mJ26ZdKjqXg/lyjoU9aVWD99tpc8r6b9Ccb62oE0DMlFvHfjsJJ/dMKXk+3pz6XQ4v6RLY+eGmTqmd5km9JfLzs2llGvYsbDjMs3nIhD51a6ds57SXLJo48ZI1DsOoD5m2+svSdfj+ITuT5LGLqHtgtNP/w/pep77an8Fl9/5dHCa/rBUOoh1b/P9v+K+Uua8a1oCcGUem4zP/81mJ53k0dzfoH7mPuP+7Wv9LgwW5rQxGMesdZPddLX2p9mx3L5+CcasDVRurS/45j2+fo7vfLYB9yutTaNMpN58bvE029GuropzXAfrlHJzHbggS5GnQhvd3nrWxmSs/zOo/lGX+2xNxsW8iMs87gIezyIe49wg7mmlC2e7z733f5J7jz0kK7Stsx55SPqNgKWlj9u+Oq9FN2nejOsGLow2reX0XjstWtt80vc0vY8ycUHa0UehHRVI32i2+1J1ilafvrEurM1RmE9rk/H8O9D2Qt/z77i+44LYv1r6jQq+Vm9u7ZHHHW0+jF8S2kjvfHaadoQcddXHJ3UMLJ+G8T0FI42L1n7bs1amYeg3adq1Rsc3Tw+17iD1prlhMuxbFZH9JuBTG5P5mNFmKANvk2vp88Q/42+m9JIfP7OD/Vn6A49jPwCdfRWNpb4yunBVUy+j8MxpeBtYtnXHY3i+iniW9NfD2MuuibV1OTyOwO6YJf2NgMmfbtCOyvj0qLa9jVvYws9U1CuXrZQPt9G5zjVsPsqi4WwhHC7nCNFgbO0oh/u3r/W7MGAQPDnqgG43tyv8jFH6W6kdnxp1y9QnM/dvh0L31Khbrkh3B9F1bWj9nm5M4Q3nD1jvW0i2+TCyrbAcx6Ledsv9CNPfBfriAI2raA/g+PvNGBsd5zPbFFkwX8irduRujNLfA/UxtUfnFflBXjVbXvr88bDlu/YMmt3y0fQTpl+qfvJdv/bNCzJRr45MM4ZhPWjp+ZiKpP++MhfzrUc7/B+QPefb61kHZfCNg9r8G/ewH5/UcXGsQpnd1uwur6R/A9Z1nqI+6PtsVpizBennP0J/uT6bpe2P+T6blVd4zUe9/Yn34bQ1B63/rWINF9Y1RljSfl1IWtv7cYq1Xcx7ZbMTj+mvAR3wboq1Xct5njZXZl3DstnX+l0YKKQ/54U2RkDdV/S1HW0vPuz8tNS2nbW1mTSu0bVxXMZpbU6FuCNR77iO187H6N3foD0bnKdxP9+klEc7Zu76wy/TmIh1s9Q2r/V5qV/NhuA1obRnNbQ1IT5O6+t3gdY9Uo/xQn+5+p3WzrUx3teOJj3pNbcJWr3hGifayBHRxTXOzfROs6m57uPGlb/bp22Je6qY/gIYV37Xs+bJ+sNnd4Y517X0z8eFtjuT9jWX58xv5yyET/cgv5odzHoMr3pp6xh8NQH1EfZVXof8ZzQWWNh8rg3/I8/a/6Bjge/s4PLPw9L3h2Gdh4W1HTv9wdd+NJ27UYnj8QT7g2ZnjVB6fJb8+O7fU3/AvsP9wWfrCW0XXH/4E+oPmi2x1P6Q9s4Ajlv/uc9xi9fvJf06GLd+lmKvTpsrsT3nOxOW9jxWPgUPSGf9gHS0T335dN+w6qQwNoNfJ2lyXdVJnXcTrW/kWeuk7IbusoXSSXHnpFxAnbRhQ3dZ8GxXGp0k6f98WwfzlBam1uf7md8Faoer6yp+dlbUuspO6qdW6yqnUj8Nva4SUh+4wJ8axXqMm/cInTh9ps0N+DNmcXrnwg06zbR6R9L/FPTOxR69kyeetXmfJjehm2bvrN91L589pl3nXyodbY2lX9vAp6N8a1Bpz82xDhEMF8K6TSkOrRtTba9b01fro06dVesHi6W5T9UX777/zkNcGQLIymwzAUr6iH5zPscUH9SbUmi4gN9M5w6J73lBkfHT8JSUNileUyCbKG2/k5W473Xi77hvAuPgiek/3VJ42jeBtY6NjYcvgGtGmm8BjWWNC49aPuxQ+BvLLDxpZZY0XxigzFdSmbMpy5yN9DLL+7VRbxtAjOM2KS3WC2mV20k5KS3WGr6BbdgmpTcFmpRev8yT0qCbJcfqNMn4rJPxqR2k1ZzQ8GGs3wPj8+tkfOLiFLedDcDXoPLdAGl4QW29Ui6WOaYXPkcVTBfYAY+kv6vFRNiJu+5Liieh2mVpVz8HNyTLxlfnkv63oM7v9dQ51gvXeTbqlS3bXmk3Enz6y2do8/fZXZD6C2LY9jEWCf1c1Ks7Q4xF2sa3pitTG9oC+M8z3ULeRICSPqLfnE8ztDfE0Ijr1Gz8sgGeZGhrdOLS9mtoI898OyQL+bPKO1aI3FhcCOupoNRzEz8b6atcPJNfD2XgTq6l1wxRxOcBAJ3habLjmzKS/gkwsjfSaXLMz4oj0C2/RlrFcXJ6gijUuf0hP74TkuuVONYvOEBievYEgQMeDnZj9O4lMmJxEETHihznGzTdYHyEjNiV7glC+mZYL2z1ouCvD4JfLQj+hiD4pXltAm2HvzAX9pbSwoy2ummHP1fUPmRnhz89pzmWNsSvac6IDdvPXNgbfuWy9oE5w/7b5v/UIPiVNv5pQfAX2v339CD48+32f0YQ/Ma04J8Zhv92+zkrDP9t/bwL8C1tY8HfHQS/UBZ5nB11QlYpk9CXcXsnpO9n3EZaOcIKZWdqZdsJ79iOOBv4QRnEYZ3dJ9aEEheiTnd5yo30Jz28cjlceLhpIxMXDhtiPWmI9boRlmZ7DsLXD5p2fK034kuzTwfBmjLCcuGpph3W40ZYmajXHh4Ea/OQYm0xxNpqiLXNEGu7IdYOQ6xTjbBc+EnTjq/TDPl6rWnH1+mGfD3atOPLauxwz2cYYp1piHWWEZYLvJE7LFhyg1y7TcBr9r51SI0O5k/jkQI3ycWLNa9jubCv9bcwSCh2PDPGbSiPTHXzrK2dap4yeG30TthcHGth9uvFNEtxWYVuhuKiKN3eyjqFDmPhXoPmUTPsemNlPqyX1HI17HpmpRZ2PXO6HHY9szKrnU43xF88fidFK/UM0YsifX1g2D94r3layytx3EeX+mE0F/jDuYNgvW2I9Ywh1kuGWEcNsQ4bYj1kiPWyIdYRQ6w3hhTLsq2+YIhlJXtt3B6WtmrZH980xBrW/viWIZZlHxpW2b9oiGWpJyzHWksdbSl7S3kNa/uytE0s69FS9ieDnnjHCMs98xx2EL4eN+RryogvSywXHmna8ZU35MtK9i48bYhl2SbiPCX3i+XCU0Z8uWDVJlx40hDrMUMsy/ZlyZdVWx1mXXiKIV+WbdWyHi316rDKy7Kt8trqsPRtS/31riGWpf31vCGW5ZqCpU1uOVewXHtk+17WruO+rM4XFiX977SMQu1stN36/HRhUilDJuqmvS0Q7QzRiyJ9r0LoTyr8CN85JW50AF6nZxvFwszMbLlRqs7Vp2cyhC+88rsRoO/+bVfSa/se2hlsw32hmqxZ4hc0toNcXRiFuG0UNwZxwqO7e3UB8b89EP9p5I/080r6u5qddP3UpYb1uSVibYx6x0rp28drPzzOqUcO4jH9/9LSTZqDC82DFZ6rYKceyNMmysd7khJ4D9WFfa2/SS2pkRCEntTJGoUXdvwhaf8A5LJlT3dZtK9xiY7KemhEyrtMFC87/louyqZUqc0sVAuzjdlqda5RqCyUasf+zDRmZxvTpep8ebFamZ2rLdSrC+XF+dJirVQr1+eO7cfXy/Mz9XqlxrIZ8ZRNK/eWmHJnY8qdRnZTCjb3Gc1LEb7z9RlJN6nk43FyK/G5r/W7MFhIvafPY2EYm6Gzp781pVzD2hGF1GOD8Ct1qX29TLBkjMPzUZh+G5QR0+Oz5Md3/6GlI/KE6QLfLdVsB3wn8nVnsf71VHfZNHsuTTtCXN8aV9J5sz+l82aSL8573oPNTjym/xqcN/s/6bwZ2tRcfzzu4XjmAo/f/PVDTsNjoaT/c9D5/PXDHJUZy+nTU9qXQV3guYKk/y80Vwikh1TnJix3vM8vX+xDnf7J5vLwGtYe7dz/0XQOlglt7LjxI61+F1rLpd+1svnGTU3XptHNabECjyPlNOMa08f0cXY093NNr6MuZBtZm98wVpyTOqEtWDhO8X7FDoUvfMd1hPklXdi7xNOlsHeJp2fC3iWuNNiPyU9bytGNO9vy3TRF3nG69FPN9/+OUfpf2djBPLVPzEtiMBv5DuYZrecJwLWX1fT0JPEQAS2hzetqNrSLc2l1stDPEa+hdLL2FU+UD5+jHVN4zStxXIdjCp0xhU5eieNztINg/bD5/t9h4+tVQ6wfGWJZlvEhQ6yXDbHeMMR6wRDLUl5vGmL9xBDrNUOsI4ZYlrI/aoh12BDLsozvGGI9bIgle6phx/dC2+fKeBj8sk8WWCahPwnyiyBe+ytYHCe0clHvmB7CFtHKhjzG1TPLYJA2g1gTSlyIOh31lBvp92uDxe3PIB3N1pP04x6+MP2UQlvyigzXEF/7Wr8Lg4WST4bYF4W+u98lX+Ss1RfuufmyAzdHFOLkto3Sybx4JOptg2MxWBH93kbvsoCHYRwYSOOXMoweKtbS6g6hv1x+KbW2qu1jiuzWKLzmKc4FPje5RqGzRqGjYb1uiPWqIdZzhlhHDLHeGFKso4ZYrxhivWCI9ZAh1muGWJZ9yLIe3zbEesYQ601DLMu+bdm+LPmyrEdLviz1hGWbsKzHlw2xLPU969W0toak13xma/teYkfjV+Qlb1g/Dx07WpMT+loR+kuxo0Vup1M62dsaiXpts7UxWBH9Pp3exdnR2tyAz4VxnXKdTykYozFl1WhKWV3IK/l5Dj9OZXMh7LxqbjpD9KQc+A7p5xSZhLDz16SUq8hurcJrXoljvx9rFTprFTp5JY519SBYbxtiPWOI9ZIh1lFDrMOGWA8ZYr1miPW6IZal7Ie1rb5piHXEEMuyfVnyZVmPlnxZ6lXLNmFZjy8bYlnK/o0hxbLUEy8YYlnJ3j2zf6BhaavDak9YYq3aAKs2QEi9umoDrNoAqzbAqg2QhGUpr2Ftq28ZYlnKa1j1xIuGWJZ9aFjHjmG1fYe1fVna0Zb1aCn7k0FPvGOI9ZQRlnvmOz2DYFmt37vnU42wXHikacfXKYZ8PW7ElwtPG2JZ8WVdj5byetIIy7pNWNWje95gxJd7njLEyhthuWDZ7h81wnLPfNfwRGyrq/3x+JVxGNuXC6vj0Gq757gnjLDcs+UZEcv2tdGQr8cM+bIat12wtE0s5TWM/dGFdw2xLOeizxtiWe5bWa5PWK6bWJ5nkrUO8cUgvj5+v6W8A58pnJ1UeMpE3bRzgWhniJ7ID98h/UmFH+E7p8QN4hu0VG1UFhfLheJ8cbpRLc9nCF945XcjQB/HJ0yvnY3UvhdoKOuK5ht0PcjVhVGIy1HcGMTJOyd79g26PhD/aeSP9PNKevYNmrYuNazPLRFLfIPi2Cd9e7nOMPuwND+eGeJzXEmPeGOU/g9busyV+dId3fS0O3+R8m6E0rvw5eb7fyeVONZhKG+7dlmopNVhrKcC3b0t+sYk7W6FT6dq7Z79Fw7Sh0JgHb/xrJD6fL7Qz0VB22bRJ1fNPhHZrVd4zVOcC1x/2li3XqGzUrBQ//jufaSpd42Odhfep8uWSke7u+PrJ0ulg1hyf4j1iwUdzV9msO9uF8oLYW2zQl1ktCHqDRKH83Zuk7h+zu0I14C47nHOzTY23r/C/sAhS79RTo7e9j0dXE4nYUqhw3ZPv314VOFf8zWH/mwnN+o00Z8t2vf8/XRJ/zr45stv7C4j5s/FlBF5R17ZN6yk39KiEbidqr5hhdaEUj5D2os8NmGYVMrNfQT3vriPYN/iPoJ9C+uLg9YPRBYO80t99IMRpRxaH+F5w6RSDm2s8Y0PPH9C22SS4lAP39nspEN6Lmj9lf2f+socej4U2B9O3213lOI2KHJL2walTK4eH0/RBtnOYd5YhkuZN3Ia1qOSfmZjh3f2u70G8gjmA4DJ7UTaMb5HG4t1q6T/MOnWQHMHVbfymHwc5jSlDNGLopU1p3F9TtrX7QeqtU9W7zx4z+31ERIldn1N1XN6TBspcVl6x+k+2+z+Ld2BuzBjZwEPu5wmAlaxWKZ1Mfm4W/C7ESV9jrBySj7hPevJjxjalEUwJpR8+1p/C4VaabraWKzVFiqFxnx5tjo7N1dbmJ9dKM+V5orlmWJ1cb5cm20U69XF2cWFar3QaJTrxWpttlibLc+wfCKlTMhPHP84BHE9rI3B5SFCw7qSsLSlT8GaTMC6mrAwP6v8DQlYVxEW5udjR1MJWAcJC/Pz9mU+AesQYWF+PnZ0SgLWPYSF+XmrfWMC1r2Ehfl5K3RTAtY3CQvzbyKszQlY9xGW9rkiwdqSgHU/YcV9Jsj925qA9QBhYf6tMfnQDHBB+5wJD6NhPlVRLKcdRvnzPqFco/rkjvLhpUHtkw15JS5Dz4N8GiJriLXWECtniLXeEGvSEGuDIdaUIVbeEOsUQ6yNhlibDLE2G2JtMcQaN8QaMcQaM8SaIKwRBUvTueujjl44eOjA3fXW3CWi4JtruOd1MfQ3KvkjDxbm8ZUF5w+8FCC0xiPd1hc8/hzlEVgK4C3krJLfheP3aZH00+YT5dMiPEZnU9KxaOMuyHw6o/DD+aMELPmN7p21eQ0vMWnzLXznW4psH7OJuu2BH0G758+w+rYnXODP7Un6dwDzwO7kMmi6SdJv8JQZ+dHmmJJ3dXut88zBYnuN24vgcnsRXc16E/PiNlkal+dh3PSXUh+74c8lZIPw4/9cAsqH9eu4witv2bjwVLOTjuPSbHtg3OuGWK8aYj1niHXEEOuNIcU6aoj1iiHWC4ZYDxlivWaI9YwhlmV/fNMQy7J9WcrrJUMsy/Zl2Ycs9aplm7DUq8Paty37o2UfetsQy7I/ngzt62VDLEsbgMfatPanpNeOifvc4Gv7sstxBCFOTtpe6lLc4IvcdlM6doOP9vqaGKyIfu+md1nAwzAVddeXe+Y1Bm1dRatfbY0hbo0Gj9DI/rKLl3VDXguSeBfCftpqvpghelGkz/OEfo54NW6L3k9baZ+y6+fTVu6Z94GG5fMkw/opnZcMsSw/PXTYEGv1s08nRls9GT77ZKlzLD+ndzLI3vJTTSfDJwMt+/YLhlhWsnfPfBZkWNrqsNoAlljDOm5byt7SBrDU0Zb2xLC21dVx+/iNaas2eX9Yqzb58Wtfq3bh8Wtfw2gXumApr2Ftq28ZYlnKa1g/9fuiIZZlHxrWzz8P63xoWNuXpe1rWY+Wsj8Z9MQ7hlhPGWI9YoTlnvkzCINgnWKIZbk/ZCmvjYZ8PW3ElwtPGmG5Z3axPQxtwgV2dzsssrfq29b90aoPuedTjbBcsOyPJ3r7cs98N3EQrClDrLwRlguW/fFRIyxLXeiCpY4e1nY/rGU80cdaS75cWLVNVv7Y4cITRliW9oQLVvJyz5Y2+WOGfFmNtS5Y2hOW8hrGscOFdw2xLNcUnjfEsty3slxnslz/sjxfyJ+gyLbef6rlNCLwGd/y8XPfPp/aL0+c22TkW3N9N9AnKObKxeJcoVivFyqFaq2QIXzhld+NAP1MpPsn084qh/2Ew3xB+wQFf2ZiFOLWUtwYxAmP2icowtxDmE8lf6SfV9LzJygG+XTMlUvEkk9Q4NgnfXu57iCIrhEfUp9t6Rr0c7DcvMind76o8CL0tPs16B+B/fMh75J3in5r5dLojKUsl6Q7fvc2Cotp9eqw3tsI7BJ4Ic24jfxq4w77ThK9g/5AtHFqJOrVkzhGjNG7aqs/aDqIP7WQVgc53m/Y3F02rJtMzF/B5XfcHzS/Cknu3xubu8si+eL8q4h/wzFK/3ubO5i3tJ59bq6FXpJbZdb3Qk98KXEadqss6e8A/cZulbnMWE5NT0kZNP3jArtVlvQHybYM1M9Ut8pCy9fuAvOV2j8U25aB9HXRp4+0u6gp3SqzGzUUJ8JxsVEsGJeld5zuM83u30txq6ypsHEF03cllvNxt+B3I0r6NYS1RsknvGc9+RED83FT0vK58PNNPU+crLBOWVaYP40bZcRi08rnRnldAha7PtZcYwtWktukqwgL86dxyYxY7Pq4X5fMiHWIsPp1yYxY7Pq4X5fMiMWuj/t1yYxY7PoY86dxyYxY7PrY55J5cwIWuz7G/Jtj8uHw6kIad8Xo1tNuOCimvnYt9JfLXbEmd5+74i0Kr3klDsuGcUhHc4ugYW0zxNpkiDVuiLXWECtniLXOEGu9IdakIdYGQ6wpQ6y8IdYphlgbDbFGDLGOt1vgNTH080r+yIOFeXxlQfs3jVtgtFUFj7cofhumsqtugZc+rp6oboFlPphR+OH8UQKW/H5vHN3WnU5brtXmLpJe+h4uLSEGu+6V9P8Q2ju77tXmYj7Xvb4vKCE/2jw3R3HavFLb7pF0ovtGIc5y+dmV4+7dHT5YPmPN9LJwgWWnzQnRjmG9r321T1uqZLsqqV35XPbi8mCDllq1r7EGnlOk3hLgOUUgt2LeOYX21WmR3ekKr3mKc4GPP5+u0DldoaNhvW6I9aoh1nOGWEcMsd4YUqyjhlivGGK9YIj1kCHWa4ZYln3Ish7fNsR6xhDrTUMsy75t2b4s+5ClXj0ZZP+yIZaljhZdmOazdZrtsNlDR1uP7NcOkfRnKul9rlvPgPySV2y+syDOer4bVx9nAk2hvxTXrSK30ygdu25Fu+2MGKyIfp9G77KAh0HbR4o7niF04+pXmxfkPHRGB6QzqtA5fvOEuSXvPQzbPCHt3oPVOrMLPJ4NgvW2IdYzhlgvGWIdNcQ6bIj1kCHWa4ZYrxtiWcp+WNvqm4ZYRwyxLNuXpc551RDrZJD9y4ZYlmV8Y0ixLPv2C4ZYVrJ3z1Z7zS5YttVhtQEssVbH7dVxe6WMHavj9uq4vTpun5iyH9a2+pYhlqW8LHWOpexfNMSy7EOW4/aw6uhhtScsy2hp+1rWo6XsTwY98Y4h1lNGWO6Z3fYNgmV5HvtUIywXHmna8WV17tmFx434cuFpQ6wnjbDcM7u9WpW9v4wn+t0BFyzb6qNGWJZt1QXLPjSs7X5Yy3ii60JLvlxYHTtW/tjhwhNGWO7Z8syDlbzcs9VdMRceM+TLaqx1wdKesJTXMI4dLrxriGU553veEMtyT8dyHcByfeKwIRa7TBTXYZe0/JmFdaU313aZiP4kMlE37Q2BaGeInsgP3yH9SYUf4TunxA3iMrExVyoslhv1wnR5YWGxUMsQvvDK70aAPupbTK+d9RNZ58PIWnWZOAVydWEU4jZQ3BjECY+ay8SpQPynkT/Szyvp72p20vVTlxrW55aIJS4T8WyF9O3lOpPLLhM/13rQXCaG5iWsfivOic7YHvUGiduhlFHiToX0WOccsvQby+Tk+vieDi6nY35Q5rzumeTajdul8ICu3TANu3aT9NdDm2DXbphHMB8ATG4ngonvkWd27Sbpv0Zj4CSVfV/rd2HAoLl2E1qaL6Y0PqLwHfcDzUdU2DL23w/YXSSuc7PbO5z/sntjvCsxQnF4jyRDcXinYxvF4R2TTRS3E+L4DsIuiMO2yEHry1Ivrny/sqODy+kioontZgfFoc47leJGFNywrlZLS3a1OhKEH7+rVZQPtyvN7Wme4lyw+hSBC5au4i0//fecIZbl57iH9VOclp+9tuTrsCHWsH7C8WFDrHcNsSzl9YohlmV/HNbPlw/r56UtPzNiqXMs24TlJ7SH9RPHlny9Zohl2SYsbRPLcXtYP1U9rJ/2tuyPw6qjLbEs29cLhlgie8mH8zn0Bxb2k0WFYtj1/UJZZKX5qsYy8fo+yioT81ewOI73A9YEkp2vbL52gOs77KNNw5rsEyvwWlm7Ttd6yo30Jz28auVgXxdp5/6SfoOHL0zv82Uedi+j48tEk6G2l7EUXyYitwspnaz9jkS9bXAyBiui3xfSuyzgRUp6rQ5zCk9pPm2yJgGLfftr3zHwyR+x2Lc/5k/TdxHrKsLS5O5rw4jFvv379cePWIcIq19//IjFvv379cePWOzbH/On8cePWOzb3+ePf1MCFvv2x/zsYz3Jzwv79sf87NNpSwLWA4Sl+ZrifO5Z+04Arn/jZ43+Yms3T5IXfc+i7lgP8Zg+s62D+V+3dp5loX9dShou3NLUaYy2sDT/tpJmJAZT+r2k3wpxvv0dSb9dSb8V0gh9qSs8B7U9SqaNdcb7fTv65PVUJT3uA20lXpG/U/vk9cpl5nVU4XVSoS3j1oRSLutxH+lJOfAd0s8pZQxhw/rk6oLUQ8pPNWFTZ3EiHBcbxYJxWXrH6S5tdv9eyqea0D2bJgI2UbBMp8Xk4y7B70aU9KcS1qlKPuE968mPGJiPm5KWz4VfaPbmSdN1TiP8fa3fhYFCcTpt1xH6y9V1ktoNb02ervCaV+K4XyzVDaV73maItcUQa8QQa9wQa40h1lpDrElDrA2GWFOGWHlDrFMMsTYaYm0yxNpsiJUzxNpuiDVqiDVmiMWf3dE+fRJnRll8dufUGPqblfyRBwvz+MqCtgxPO2RcGI/8U54xSv8lmKbxZ3e2KPldSPM5O7aV9rV+FwYLqU14ob9cn7NLmnqxHbJd4TWvxPF4vyUlHavP7ohtn1H44fxRAlaG4rQ2jnj8SRSsZ8mrLYskyYj7jthnuMSBGLc1O/GYfsGzxKEtQfim1tpUXGsHU8QD5tWWCKRtadcPJF3gT/jUtU/4YHnHmt2ySDsdlvTaHAB1M3/WCudI2yhOm6uxvmN9+6dT3elwyTcT81d45Xc83iGWfKFd6OQN6SDWN4gOLofjcuR99OksGcOwH2HeZrMTj+lfgOXIB1vP2nJ4PurOL3HfgX74W3vi84ssteVxdsvO14CSyonyuy2mnA8Dn79N1xGwXwpfgftlQ+uXuGTO/VIb47RPJLBexfTYv0Rm+ahXp/H8SNuSQZmzThcZjivpEW+M0j+r2EPatQF2A5/tk3dtPNL0zAYox0iLSW2LIc1njX2fs9A+a8xYIzH8S7/mes/G0Ob00iZGIT22BbZdJf1rUFfr9+iYkcKDVkdCbzwm/VbiQdK/pbQXn57A9r+JMCX9jwHzsd39YU7GYL7rsVW0fopbemm2V7C+eBsA5bid4pB3Hje3AX1Ou57oYxy2NaYbefjlMTeJXx6PJO43YDz75dbzBOEZ6/Kyry53KuVJW5cbPOVnLMk3GvW2V18fQnn9zW065lifmL+u2ASarXNns0P7N2LsGRc0e4b1NuoUyYt2kmZ38Dgk7fq3lf563GyFYr2g2Qp4VI5tBe2oAqZnnaIdIcDxmm14TH9HszsO64Hdk2if+0w7FuNVzoMbosTyIu63mpFaXs2G1NqFpP+HHj2uHZ3wyVxr37g2KvxoRy02Uxzyztfasb1KuuPRXlE+3F59snCBZaetMaBe4vaquVrRxhtem05qV772Knlde623GpRWl1zPyAPvLSS1GV4r1tYltWM2vC75bzx2lWbbacc0fWNi2uMgvHeH441m217W7C6PpP+PKfW51EvYuV+xqPUPlCv3D58MXejXRuT5k7bWxeM10kzTd7QxJW3fkbyu3V5Iun4yJS73YWwz2pHBMUr/lx5dr5XNp+u1sQF1AF+3R5lvojjM59P1x7MtD4uu5zUOrb1q7U/k6drfhhS2hu/zkmltK83VwkaKyys8HrdxPqbusbxc975+4EK/NhLXPbaLdRSHfZ7XazQXFqhTLqNyaDoFMXitVdKf1lK0aXWKr10l6RThJ41OwTbn0ynorsOFUYg7WdqVT6f02658Y6DkdTroP7cqQzvyzucWtHbks8+S2hHrJ02HauMqridNKLgu7Gv9LQwYfHs/E1Fv/Rqu/aQ+myf0c4ocQ+yJa/WK8hkh+YT5DG2h4s4hsQ524fZmr2yYD+5Pk8C7yPgqwGH3Vdj/cO/sQ9u7cbX1AMwrNHg9YN/2DuZHCNOq7//dSZ1XxJ1U8nI7GI9Jj2XH9J+CsSpubR150NqWpE+y4XiswvbAe++aLmY6WI8oLx6XJf3nlXFZG/+Edtjxr6SOfyhDHv+0ObnmglPSJ83JeY0E546bKA7rgM/LaG1Vc9emuYvCOSD31ykol9a3UCcgj8KHC7dBmtEYvrEdYfuW61msD27w2HeaPvadSUmyUXg/3beHmDQW8JwZ1885PeLxPtdCCp0xFunzPpappK97ZKrpFZ9Mff0E+dF0Dd/rSJIpX/fR1uJ8MpX0t3tkquk7n0wl/QGPTPu97pWkS1imvvW9JJnGXU1LK1NJf69HplOQJ41MJf39x1GmWOZtlA91BuqIbNSr73Ix+bIezM0xmJr+8l0X1epS02lcl9/31KVWLuY3rlxbjMq1pc9ySfrHA5VrKqZcU32Wa3NCuaaoXJL+WaVc2hjG81rsy7yO5gKv/Uv651PadifLeimvX2ifR9DOXHH9a+0l7fwGz4f9mNY2fK5mNd2srdOxbv5RyjZwPNe3UJ7cBrQ1Z998a5D9fJkna22A9yOt5riPT3anC3W2VsrGcsJ5hDbv576YjfT5JaeXPoNn67R5L+usX4H2uh7OqnK945rG39iu046bw/CahqT/+7Cm8WutZ59LC219OW5NMm59hfutpP/NlP32ZNnv4D0NbEs+3c3raJruTjsvR929bjKZf80m4LGqX9vo9/qcEyFf323qmH8A7f4fbO8uP9ajnHdy6f5ouw3tf9Ln3EG7cyTpk+YOfHZIm49xubmu/oj0Qpo1ubS2KsbxHMTXr7YoZWQZjkf+eT/PLf6F0s60dS+2jdKut7BOx7yaTk9ys8RtQevn7BotinSXIby+pK0xa7pY3gVeIy0dbxtKZKed4Wf7StOfmai3L2cJ24W09/D+uHUARXPzxOOx5n4K37ENhfklHdvY/y/0FT43r9ntWMY4u/0vPXoxyYVWmvpEGXFf0PZ1tXy+fU4X9rX+FgqNgYLQE/2wRuElbi9nrKW7nBy37NF5zfTwO1iYjHrrKUNyCrMnWypkiF4U9c4VkH4u0tvDPhN+/HuyWr8LuydbbOCeLLbffvZktbkazkemUqyrYt7vNDvxmH7Ljg7mxhjMKOpfd6Id+7F13bg+XeFCv2coeK6kjffaGhifC/Sd9fXtr7hnPuco6c8A3eC7F7ks62PFRrHfe5G+9S4XlroHpN1J5rFba3/YFnhfDfc0fWuzPA8+D+qI7VC0y/hc72ifvGt3Ormfc9/hfq7d8dDcnUp6bJdZBUPubvC94yLI5ECMvYE8oF7gNuGzDZEf371orW/7zmguzz1jfc0Cy8v9SbOrMH2/dpXUvWYnb6A4bMtCc5JwsD5c+9ve0t0YL38H+QRmaW5uZr60UKjM1hYbtUqZ7SSUxboA9BcXZhYq9YXFmWJlplwp1JabfqlWqxcrxdn5uXqlUpufXm76lenq7GJ1tlicrxTrlWIifdfOf9ZiAu8rulADG+KL8PmyDOGxfYpt3dAeTP2pMaGfI16N+WnbpyPETyZG3hNRt0415mchE/Xq7KxCk/36rFPieFzS1qARd4TS83jEd0VvpPEY11HFZ0hGidPWXYVn106voXaK6wTsI2RMoSlx4564NZ449t2HcROQ7wDlyymYjodfJDtBq1tsf+xzlNs+Yq1LwGK36Jifz0uuT8Bit+iYn++7TiZgXUVYmD+NW3TEGtQtOmIdIqx+3aIj1qBu0RFrULfoiDWoW3TEGtQtOmIN6hYdsdK4RResrQlYDxIW5uezcdsSsG4jLMzPexCIxeNzIH8OqcdnoZ8jXkONz757nVHUOx7uUHjNK3GstzR/aJoPMA1r0hBrgyHWlCFW3hDrFEOsjYZYmwyxNhtibTHEYr2VNF5f33z/r2+8lnxxfjDw7Ig2RiNGnD2AtnmSXXAZ8azR1GxM8c3CNqbQxTj+JDPGoT/pdRSHNibrffQvu57icK6Jd3V/MWZuh2XTziKt8fDMn9HGecUYxaGM+FPgOH7w58VRflLuEHPqhdrMYmG+XKxVq7OF2Zm5fubU2p0qHo+5ne9bIp/dYbGYUfjUxmOhnyNebfnpjMfaXEGbz4X9LNliwae/JhX5hP70nbZmzDYG7iNr++t41w/T47Pkx3d/n3SANt/Q9r54rq7NkbTzAsuNpc23NN9FTqf8JskC22sm5q/g8jvmEeuT9fo6QzraHU6tP7l/+1q/CwOFcol9iiGPYT+PNz2bVtcJ/VwUtC8XfW0Y5cNzD22/SDuT+0izky6pfSMdDevNIcU6Yoj1siHWa4ZYlvI6aoj1iiHWC4ZYDxliWZbx1SHl6zlDLMv+aFmPhw2xLPvQG4ZYlvVo2VbfNsSybF+vG2L9xBDLst0Pq86xLOM7hlgPG2K9a4hlKS9L28SyfQ2rXWjZ7ofVlnvGEOslQ6yTwZYb1nZvaZusjmn9YQ2rLTesutDSlrPUhZb1aCmvYbW/fmCINaz21/OGWJZ927IPWcrLchyy7EPDKntL/fWCIdawrg1Zti9L23dYbcxhHDvcM+9ZWYwdUzHY+OzbG9boZBSetT1lPGsyEfWW13JfWbuzaokv5fbdgUH62r3zTMxfweI4obVcfoG1svn2onHfHWUQh3VKn1gTSlyIOs17yo30Jz28auWYNJTJmCHWOGFp/V/bv5X02vlprZ34zk8H9r1d8tWtdgbbnVmQc1m1+sI9N1924OaIQpbkIHK7htLJPYCRqLdvnBKDFdHva+hdFvAwLJd+n1TySbrAZ4ZSf1tc6OcUmYTQlxtSylU7b8T3G7H/3N3sPGNaOc/ku5ujjTdhx96Zctr6EfrLNZ759LoLXD9p9LoLjzc76QbRxS782BDrNUOsI4ZYzxlivWmIZVnGw4ZYDxliWbaJZwyxLNvEDw2xToY28Yoh1quGWMPaty1lbymv5w2xLMv4kiGWZT1atvsXDLEs2/2LhliWbeIdQyzLNrFqf50YOtpyrH3aEOtk0IXvGmJZ6pxnDbHeMsSy7EOW8rIc04bVLhzWMW1Y51aWsrfsQ5bystTRq2PHiTF2WM6tLHXh64ZYq2sKx68PWcresow/McQa1vmQpeyPGmIN63qhpZ2zqieOnz2xqieOn+yHVU+I/aX5/820/gY+h5N6f1/o54hXY36856G083f8vSfMm1fi4nz8SHw0xDIfPw4yHx9Q5i7c1Xz/r3YmCdvRUvqTdr5HozM+IJ1xhQ7/1s6IyHkS/zdIBgoV7XtY3JbDfLMifVsW+jniNVRbTvt9Tv6OO+bNK3F8hi5AfZa17ytwfW4JI7/U9YnfDwvYvtr1mfZ7EiK7rQqveSVO6k/znxr3zWDkYYvCQ17Jv8VDJ43/WB8dzX/shJJvX+tvYaBQrrCMhTbSDeRzNXX7FPq5qLfOQ7RP3/f9XOD2uV3hNa/Eha/PQuM4+vRNXZ8nik/fJdRnabFRLE/XZ6cLM9XKdG2mXKqVZgu1ynSjWJwrluYrc+VyY7EyV5srlRul2dLipFIGrs8dYeRXSVufQj8XBW1f7frU/NGifLg+T1V4zVOcC2LbZpS4rPJuJAaLx4RBsFyQbxEEHAemue0L70gXy3c89IbQz0VB233RV2ea32OR3WkKr3klbgvlw/pcHpmXF5Yq80C2qlfmmr3Uj8xdeKLZScdxWeXdiAfrGUOso4ZYLxliHTHEOmyI9ZAh1puGWK8aYlmW8TlDLMsyvmyI9Zoh1luGWJbty7I/WrYvS11oydcrhliW7f5kaBMvGmJZtq83DLEsy2gp++cNsSzb/euGWKt64sTQE5Zl/IkhlqU9Mayyf8cQa7UP9Yf1tCHWah86frK3nLtbzpHlLIrsT+EaEu+D9bsuifklnUZn84B0Nqekkx+QTj4lnfEB6YyfBOXh39oZCj4/chrk47bZbx/A/JJOo7N5QDqbU9I50cqzdUA6W1PS2TYgnW0p6WwfkM72lHR2DEhnR0o6+QHp5FPSGR+QzvhJWp5V/Tbc5VnVb910jqd+m1Dy7Wv9LZbLxUKhNlts1Brl6dn50kJxpjwz06g0ZmfmKrXGdKVam60XK9Vyab4+W2gU5+r12eny4uxMY762ONPgb5y6IN+9c335qdO7yyPfMcXvKOJ3Q0cgHtPnzuhgPtvC5O+mRvA8QXiZyHKPtZT6m9tCP0e82vLT2fMdIX5YPrznm1V4zVOcC7znm1XoZBU6GtarhlhvGWK9Yoh12BDrIUOstw2xnjHEeskQ66gh1rDWo2VbteyPlnw9Z4h1xBDrDUMsyzbxvCGWZZt43RDLUl6W+suSrzcNsSzr0ZKvYR07LOvRUvaWfduyjO8YYj1siPWuIdbJMG5b9u0QY63MlXE+J990n6J87nkdxY1CHGJgHPI36uEP84/G5ONyyHw01F1VwV8bBr/9XYI1iqywTEJf5pdjkD4T81ewOE5o5QjLWna+siH/3A7WAD+87qlhrekTa0KJC1Gn455yI/1JD69aOUZJJlo/yygykfdrPXxh+imFtuQVGU5AnKEMSz4ZYl8U+kv5poPI7UJK97lmRw7cBtfEYEX0+0J6lwU8DFOEoelR7s9x9ZuPye/CpIfOpJJPyrcOeDwT4tcSjTMVHs/08Ij5JZ1GJzMgnYxCh7G0NVMXbml24jH9ptaaqSvDgd3dmGcp/Pn64k4l/VmQRvjRZLMzRT4XJhVawpP0413w3loXIj3hF98h/RzxGmpM2kX8sHy4b5yt8JpX4lgvnK3QOVuho2FJfU5FvfXL34DR2t1ZHjqTCp2wbaFUYllikLjdShklbg/E7YRnDln6jWVyffZ39nRwOR3zgzIX3oZNTmdR3B5If3WzO+4ciJM7m0uR4T/rQ4Y7IU74Fp0q37vZ0wJ3Y+3MGd1pxN/JF8/qpJmjNHKe56Own/WhM7r52N1hrV12TWb8nZ1zlDiH/7kWP9I/90adcvL4uBcwsso73/i4NwZrFLAmAEvqfIzS39CSh7Tf8wDXrv3OzIrczgeeeLy5IBDttOON0J9U+BG+c0rc6AC8NhbnCuXCzEytPlNZmK40MoQvvPI7thkuVNJr3zoSWX8gCiLrUvt7kM0O/oUgVxdGIe4CihuDOOFxLaSbIExr/tPIH+nnlTj0SdVPXeaVuKubNlioDyyw1iwRa2PU3Z9Q54TVQaV5TQdJ0Po8r69gH5NzF2nHSSmTw9x7TgeX0zE/qOeRNy6HNn7InHUq6pXr+YR1QQLWlYR1voevCxOwriYsrV9lo95+junGFGymzXUqaVwIq0fSz3GEvjauhJjjaHWj9VOR3QcUXvNKHLYtjEM6H1DoaFjStrS2xmcrtT5wvodOXqETti10fOFg+SVI3EVAm+2Qi2PKz0HTO1Imp3du6EPvoMyFt6moV068Fqu1L3znO4Mq6cLaKKUayzxSyn+xUkaJ+yDEoZw4aPWBNs2BPuoDZS68TUS9bcdQTnWWRaTwhbK4kOIKkP6qZndcEeL6nXNKeZ0MX+1DhtiePkhxFyl5Rb7YFo7HGCH0c1HI+u6MERcTPywfHiM+qPCaV+JQ/hiHdD6o0NGwZMyfUrBZJ/U7Fo0rPIdtC6UGyxID9ydNJxUhDtsHB60/SZn6XQdDmQtvwyanD1Ac6h1eBytBXL86CWXYzzoY1hXLENu7nQzLBU0/M1+afmY5ueed8MxBk5OUycnp3y5RdxcpDtua8DYV9cqQ5yn96p8LlHJocxi2UfudZ+cVnjU6aeZwPjrne+hgHOvTfm3ucYVnjc6FA9K5UKETdm2xf33ENhL2M7aRBtFHUt5+bSSsjwLFrc6jlz6P1uxkza7hPm1pI+E6CffpfvcixhU6E0oZhtVGwvbBQetPUqZ+bSSUOY/vw6KT9lJcKBsJdVI/NpKmk7jdjsI7tO2vbb7/l/e9fgZ7gn9Ke4LnAg2h7dKVz+xOt1fhO2zdpteHQj8X9bbDEPowaf2Y9aG2rquN43g2Lk7v+taXNJtAsz34TnC/tscmhc6w9fNNFIf6ENsHh6S+/DsD9uVhk9P5FDds+lAbU7jdptWHkn5zS7cF1l+FjVQupHX8zggsXa+GsXX8elXTQ/3qVZwzD6pXfXYm+0Do187crNAZNn2xmeJQr/a7P7BUvbpqZ3bSWNqZaW3CtPr3uub7f1n/zp3ZwZyJsTORD5fuvjN1/iWtC6t601ZvWtqjUpdTUW8bY3v0XIXOuR46mxQ6K8keXS69iTIfVr15LsWtpPm58J5WH0r664fIHj1XKf+w6tVzw/Dj1auaHjqe9qhvns/2aL/z/M0KncD6ou9zGGyParoktF5FmQtvwyYnnufjfijr1UHOqyxVr2Jd8XmVJJtQZD0L6Qz3kOeEj7moN0jcPNDG84EcNJkJ305mf/3cDi6nY5rY7uYpDtvdhygO9ceHKQ73nn+O4lBvfYTisK19lOKwT36M4tAO2kdxuPf+cYorQ9wnKK4CcZ+kuGmI+xTFzUDcJa1n0ZPYtnz6GmWB8XMQX1LisazTED+pvONxGdue4ThYSzsuC/1c1CvjEOPyfNQrP5QPj8sfUnjNK3G8H/khhc6HFDoa1gWGWLOGWB8wxLrYEOtCQ6yCIVbREGvOEKtsiFUxxOIzSViv7Lu1X7sX8/P5aazz4zn2b6U4lA3qRQ6aXSBleu/8WB92AcpceBM5YXs+nnLis0HYvh5sdsd9GOL6tUelvE6GW/Z2cDkd84rtiW2rC5W8YeWbfo4s9HNRb1sIMRYXiZ+4PqzZdJI3r8SxDvfZTEhHwxK7bkrBZj/PBYVOwUNnm8LzsPW1bRQXN+5ySOpP/cyRtf40bHLifRDUSTxHttJJ/cyRNb2ejXplyGv43I6530YKBuMUKK3EjSh52Q85xrG/c01/4Dvub9sVfrV1C9bLqA+Oh14W+rko6DhR9OlLTa7afLpEMsc41stlhU5ZoaNhsQ3gG1fD2HeFStr6E/rLNa5q49B2Ra7L0b7j6rno4acShp+2z4JphR/N7nC+U8aj3jaE8sI2iXxPA768S2Pz8F10Te/6+ili8V30YkwZ4uoIsfguuiaDMYqbAp8z//XM7jSyzrUO0mRaz6xXhI4LgdtI6j4t9HNRbzsI0acrxE+crnRtdk3kbztYd7img2syH1TKym354gSeuC1rtDT7RNK5NjF5Vny6gicd7glcCOlO8aT7gJKOMaT94jr9uRQnaTe3MJyttrBXpysYLoT165G+bQv95dorPY/4Yfn49kolr29/MxP16rN+90rT+O5IiyVrsoHvgfS9z8fnJ0Lt8+EdkXof6yrYL4Rv57tU5qg31w99vn7/NdXbb6lVD91y4I4v1++6p37w0CjBnhvDjvzm61tSdYgTedh1YYTizqN4cYU2EulhUsnHaiKM24f00xKhn4uCqq22mtCup6N8WE1crPCaV+LYRZw2rF2s0NGwpK1oR3z5M1r9HvHdofAc2CVL3ypkB8WhCdLv1ja6ZFnqEV8+UjEscuIjvqFULcqwn+UiTdVK3G5If2ezOw7djF5E+c6BOMFHV5CSTnMbKnG7IG4PxZ0NcecA/s5WpimFR3Y1ia4ss8o77pNrFX4YK62rSUl/W0sAE1Gv3OzabMfVpM8U3RuIdtoxhvuJdpxHu7oXwtVkWn0t6TWzdkpJH9YM1F1NngdydWEU4vZS3BjEoenGriYDuUQtpZE/0s8rcexqst+xV3PLNygW6gMLrDVLxBJXkzjNE50TVgeVZjQdJEHr8+xqEvtYv64mpUz9uppEPc+2o3b9AMcPXhJBuZ5LWHsTsHh571wPX+clYPHyntavJpV8PF4M29LFnjD8FNPKleck5yu8am5msF1gHNLxHb9GrHMNsfgKI/KZJzrnKHTO8dDB/Kx/wtghpTlNj0jQ6oxtzjh3Rhw0/SNleu/obh/LIChzPsK/XK5LhsX1MLsuwfkdyomDVh/oevjv91EfmuvhwEt7VZZFpPClXT3mo9ouHGx2x10EcYMs7f3ZEpf2+HjeMLibRVlo60s74ZlD0rz83y7R7RTPr7FfCG/aUUqep/a7lL1HKYc2t+bxoN+5dV7hWaNzzoB0zklJZ3xAOuMp6ewdkM5ehU5gO35BO4YhgfuZpo+wn7E+wjW1fvUR2vj96COsDz72Lph4VRPHK3YdIun/Hmx1/x1a89oNNIS2SzexszvdOQrfYW2k9PsBQj8XhWxrHdtbs2c0+9I3Hoa+uu7r53x1vd9+vkmhE9he7ruf89X1iyCuX/sM7eV+9gO0vjxscuJ5BepD3g8YRB+iDPvZD8C6Yn2I69xp9KGk/3e0zh1If6lX13n88a1pDJteDb2mkbTutFS9anmEQtqjtg7BV9f7XYfYrNAZNn3BV9dRr2L74GCpVzWdMGxyOofihk2vamNTWpswrT3KrkMk/YadHcz1O+P52g20v0jpVu3RlWWPSl1ORb1tjO3R3Qqd3R46mxQ6q/ZoLz8o82HVm3zuYiXZo8J7Wn0o6T+48/2/w2CP7lbKP6x6dXcYfrx6VdND2hop61WMS/OZwLT7YieYPdr3Pgzbo9qYE1qvosx5H2ZY5MT2qHbFRtuXWC69inXF7t2SbMKwV3PK08LHdNQbJA7d8PTrwkv47teVEra7GYrDdjdLcag/5igO20ycCwH3zO6ZcCxk90xo66w090yiJ7Ft+fQ19x+JRzcavk+GII8a35LGBWn32PYMx8HUrpSEfi7qlXGIcXkm6pWf5lZBZDer8JpX4ng/b1ahM6vQ0bD2GmJVDLEuMMS60BDrfEOsiwyxLjbEmjbEKhhiFQ2x+LNrWK/sSqlfuxfzs2tPrPPjOfazKyWUDepFDppdIGXq15USylx4EzmF+exj/3Ji157YvtiVErpC6dcexc8+9uNKCdsT21bnK3nDynfpn6INcw7M/ylarQ9rNp3vU7Sswwf5zJrYdVMKNrtSukihc5GHzjaF52Hra+xKKW7c5ZDUn/qZI2v9adjkxOfaUCfxHNlKJy3VjfsM4LMMMR26UrpI4UHjK6PgXERpJW5EycuulDCOXSn1e+d1u8Kvth7MejnMp3rT62Whn4uCjhNFn77U5KrNpz9IMsc41sv9up5DLLYBfONqGPsu/f0Oob9c46o2DvlcKYVs33H1fLGHn0Cuwtp38jQXRJrdga6UsA2hvJLc1WB7SGPz8F0rTe/6+ili8V2rOFc5cXWEWHzXSpMBu0n6k53v/3Uy/Mc7u9PIOtdPIc0ftp5ZrwgdFwK3kdR9mt2OBnLX5nU7qulKdKUU13biPpuuuTNC2tyWL0zgiduyRkuzTySdaxP/cmd8uos86XZDuvMh3b/xpLtASccY/CkbxODPfv27FobmSsm3VxrIdVHqts131EPvlWr3T9PulUre0PcR9xpiyZps2Pruf5+Pz0+E2ueT8vbrSknbK12CK6XdMezI7730W8Q3iCulcyg+rSsl31G1Yfs6VeijatrXqdIeVfN9nWrQq2W+r1MhNrtS6vfqxA6F52G7ssmulLRjrWnVBF7LXOrVCb6WOSxy4qsTqE5Z1eJ0bpCrrUs9qsamGjiZ7HGltAvysQuGsyFOc3Uk6UYh3VmEcTrE7aK4MyDubMD/v1s/phQe2ZWSxLmQVd75XCntisFK60pJ0n+89TAR9crNrs12XCn5TNE9gWinHWO4n2jHebQrJiFcKaXV15JeOzLnc6UUxgzUXSnhkS4XRiFuD8WNQRyabnxcLZDLr1Ia+SN97co3u1Lqd+zV3M4MioX6wAJrzRKxxJUSTvNE54TVQaWypoMkaH2eXSlhH+vXlZKUqV9XSrsgjm3H3UQT07vASyIo192EtScBi5f3dnv4OicBi5f3tH41qeTj8SLQHCD10oXQz0W9dRViTpIkV56TaO7K8koctguMQzq+L4Rry1MWWHw1HPlk1xlnK3TO9tDB/Kx/wtghpWlNj0jQ6mwXxe2NKT8HTf9Imfp1pYQy56/Mh3b9EdglR9+u9diVErrkQTlx0OoD3W7040pJc4MSeGlvlmURKXyhLNiOxiVBdl2Cc9hBlvb+bIlLe8L3MLntQllo8/md8MxBkxO67erHlRK2J77qgP2CXRyhDHfBM8YJr/yO9cIupRza3JrHg10KnV0eOnmFZ43O2QPSOTslnfEB6YynpLNnQDp7FDqB7Xgzl4QusD7Ctdd+9RHa+P3oI6wPPl4umHhVE8crdh0i6d9sgbp28PqubnroPlxou3T/nNKdrfAd1kZKvx8g9HNRyLbWsb01e0azL33jYV6J46vr/epHTddq/ZyvrvfbzzcpdALby333c766jntW/dpnaC/3sx+g9eVhk9MuikN9yPsBg+hDlGE/+wFYV6wPhfe0+lDS/1brIbD+Uq+u8/izSyn/sOrVXWH48epVTQ/1q1fTuPdOq1elPWrrEHx1vd91iM0KnWHTF3x1HfUqtg8OlnpV0wnDJqezKW7Y9Ko2NqW1Cbl9x+lfdh0i6f/Vrg7mv9gVz9dZQHvP2d3pVu3RlWWPSl1ORb1tjO3RsxQ6Z3nobFLorNqjvfygzIdVb/K5i5VkjwrvafWhpB9rgQ6DPXqWUv5h1atnheHHq1c1PaStkbJe9X1uZpB9sRPMHu17H4btUW3MCa1XUea8DzMscmJ7FPUx61Xcl1guvYp1xe7ddkGcZhOGvZpTLgkfpag3SBy64dkNzxw0mQnf/bpSwnZXpjhsdxWKQ/0xTXHYZtiFAPatk8U9k+hJbFs+fc39R+K1r8hjPJYVr9dNKu94XMa2ZzgOpnalJPRzUa+MQ4zL5ahXfppbBZFdReE1r8Txfl5FoVNR6GhYewyxioZYew2xzjPEOtcQ6wJDrAsNsUqGWBcZYl1siCV6TPvMIrtS6tfuxfySLuydpP7HfnalhLJBvchBswukTP26UkKZC28ipzCfB+tfTudSHLYvdqWErlD6tUfx02H9uFLC9sS2le8T0GHkm36OLPRzUW9bCDEWa3fWtD6s2XSSN6/EsQ732UxIR8MSu067Ds6ulLS7fhd46GxTeB62vsaulOLGXQ5J/amfObLWn4ZNTnyuDXUSz5GtdFI/c2RNr2ejXhliOnSlpLlB0PjKKDgXUFqJG1HysisljGNXSv3eed2u8KutB7NeRn1wPPSy0M9FQceJok9fanLV5tMfIJljHOvlixQ6Fyl0NCy2AXzjaqA756nvd/Cd89DjqjYO+VwphWzfcfV8oYefQK7C2nfyNBdEmt2BrpSwDaG8sE1q7mqwPaSxedK4n/H1U8Tiu1ZxrnLi6gix+K6VJgN2k/TrrUURJ8O/cnZ3Glnn+huQ5pdonx554j4dqI2k7tPsdvSiMPx43Y5quhJdKaVxk4RrOrgmc75SVm7L5yXwxG1Zo6XZJ5LOtYlfPTs+3QWedLgncC6k+w1Pur1KOsbgT9kgBrtZ+q0WhuZKybdXitjHo20L/eXaK91N/LB8fHulkjf0fcQ9hliyJhu2vvvf5+PzE6H2+aS8/bpS0vZKl+BK6awYduT3Hvot4hvEldLZFJ/WldLZCg1pNsP2darQR9W0r1OlParGX6eyvFqGWHy1FbHZldIuhc4uD50dCs/DdmWTXSlpx1rTqgm8lrnUqxN8LXNY5LSL4jSvpdoxtkGuti71qBqbaqgH2ZUSujpiFwxJro7GCH9dSzFL3YUxQ8o1bjdCA2mfHYh2Wl3LR3CQH+Fb08ODuBQq1RcWZ6rVRnmxUVisNuqZqFfn+vSwz7zboqQPe+ypXJV2jy6FdoNcXRiFuLMpbgzi8KgSL92HMefK1TTyR/p5Jf1dzU66fupSu3bMrnvSYonrHtTTbHqyzeZCWD2Q3u4R+jniNZTdox1pH1Xk6jvypl2D5yP6uxQ6PnsEsUTvL/cRfeTBcDwvafa3BInbrZRRO0KH7YODNmZLmQY5oi+8DZucuJ9rLsokDt3b9Gv3oAz7sXuwrnZTnG/JJox80+sktgFCL9lousK3ZKPZK9qYshOeBx2fpC6not665ePtowqdUQ+dzQqdYetrfLwddVK/x9uXqpO0/jRschqluGHTSZpeZ97HlLRnUpykvbQF4uZet7eetT6yPuqOOxPi1sEz0sUjA2dGnXBLU+fzCy36Tia/vUfHHInBxLpxAe167JMujEKcXVtbLDq+797d4YN141izu0yaPsP0aeZOqOPYvsN2vZOwNB2HOlu2azR5Co/HQ57II8tzZ0KZWJ6a/HdCGpGRNp6cTlinK1goY5880Y51YRTiQssTeUwjT20c9NkBOyGNyEibM5xBWJo8sb9/jniV/ONKesQbo/S3gM65dEc3f+shP7eFdQo26lBfP8sp5ZikOMzrcJ9qEcF4TLev9bvQZ1icnllYrExXC/Wi+1niq50uSD27Mov75/EmlKvZnWdN6/do1Bn7ML3gjVH6e2Esug/a6XtpFXou3aOedJmYv+9hKO9Gm93vJpq96bPN3vRCO9fs5VHi1kEc9jMX1rd+o7wQS/gYo/QPw3jtwlrII/nzCv21RL+Lb+Ud9nPGyirvJL2rn2+3eJR2i2W3nou8R5Pw8R3zJm1nXWTfr+oLlfnZhfnF6UKtMF+cLyf1K6d/ftZiwrfulbYt8xwFsWTdT2zvcchvecRK8NcQf0b4RZHTWNQrJ6G9NkjZGo009YD0c8RriPaP9IQflg+vr0+EkU/dHT2Stof6Y1yRDfOxhnjMBeJRs8XQPbsLoxAnfLg0l5zXzeNIIB7D9tFGe78L56jiht7RfIvsGakbnNthu8exHdO/A2P7j2meyTrXhXUQv0aJl99SXyNKWt6TWEMy1OSK6aVNjseUdZzKKun/CtiUH9uhY6L8kK+RGMy/CpgHqE7QnvT1eUm/TkmPfUz4mYp6++Y6yoe846dh+J1WPxlKy2Mw7k+tobRrYuiwPDQe1io4PE4yJtPk9uAC2/JZhQ72KRzzJxT6huPDtDZWSpA4dg+McVj2rzY76Thk6TeWyZX3SbLXMR3zo/U1S9tI3o/Be6abpbTjlJb3zZDHMQMe8wqdccJd4+E/QzijSr7JSO+P2t+0/GYUfrWxZlA6iPW1ZjcdrGcc0/4R6U/U41kl77ebnXhM/09hTPvDlGMa6xIsw03NzjvW2WzHcp/k9RAeuzgNjuOY/o+VsYv1A2K5d/97ChtBs/vYRpDFdpf2X5I8NRtgKuqVDbfhCaKF9rGMLyyDfw/1+m93x9MSuU56yuje/cfdejrkAdMxhjZ2CobWryXflMIX9z3WHeMeGtp4ptEYo7hB60cbt9HW0GwYLR7Hc6TD70aU9En2Ry4GW8MdV3A0Pb+W4jJKHOswLC/qMLZNtDkZ6kat38XVnc/21nhPY1eNe3jX5Id6yHotpzBXKBYWZ6cbjWJtprpQSVrLsaZfmp6fq84vFIqlRqlUnptZbvozlZni3Fx1bnFmsTFfWVxYbvqL8zON+XJ5oVier9Xni8te/nqlvNAoNo6t55UbhfJccbnpH1udL9UrxYWF6WK9Oj/f6GctUdPPOFZgH8L32P9kb5vH6zNb43XYtTbd3WSaMU4rn6Zfro4p3zzYI2fvSabn05naWDhCcagXuY7a6+cpyyDpz2/xjesG2roXrrm5MNrsLt++1vvCYKGi7UHifH2s2V1u31qFC2wnr1fS414d2zS4x8dzuTEFSxuXuJ2NR7rdK3jczipQR7wHiW0+R7xj2dlWyCp0fWscjs8rqD8H2heY1dYUJExGun2DcdhP+GwZrxVjHLaDfs9hiiwcX19KcV5H0xOsC7R1P01P4Jmk9/hr9vJ1PPot2tjcb7U1SUwvfScf9dYbt1fNdtT6ANucWQ89bb6EfSBuTw51Aq4pXEXnlbQ1BczL+lrS3wZjzrU05qB+4vai6RnmJYp0PZZmrUmbu0q9aPt8lmuXGaIn5cB3SD8XBdVfRdb3KFffXlsg+6gi/GhzXq2e3d7chqi3zrT5Na6zXtV8/6/WHn26je0jTbdpfZ31gDZn9a1N+Po67i+lsR21fsz9HNMfgH78iMd2jFvniyJ/HfrqHOXLazHafo1vncanz9d6+EraY2K+tD2mSKGdVAZfu9Ps6+M4pk5rYyqWncdUn23rAtfBpJJes3fzlB5l7lt70vrlOopL2y/RDn0kZizFcqCe5fUhrX/iGI3jeoZ4QRq4fvZAszv9GOByesQbo/TPKLY+Y4quceHBZi8m84zvUS48b5d0R4CH6857/znNXbtAZ1dS33sV+st1106b/2nnXwPPlxZ9/UCz+3h+xXWHfTjuHALvc+LYgHqf1+3farWtPGG6IH4uMkqctqeFZ/Ve2dNdtlB7q3z/I+5czDuko7C/a2cDRH9wX/xFsBN+gewEre2vi/w6SzuLw+0n7jwL6yxJ/1c9Okub5yBfDzZ1zF9W1qV87UKrP27LmN63X6jt02l3XrA/vYfd7MUMbCPUNBsB5cM2gk8WLvRrP0r7yFN6lKPWj3gN1NdWXfCdncFz8NLvzNf4i8ViY6ayMDezWCo0aovLvcZfacxWZxqzhelSrVIv1ar9rPH7ZJxRZDzlkXFae4ixMh6ssQQsdk0Y1wc53zLZJ6ldpbF9EuZMqN8+Qfnw2qhmK2ifduc5cL/rR9qapwUWj82IHdc3tDk7yiiKdHsHZfvl5vt/w55HLixoc8CIyrxe4TmjpNfWsPH88g1g93M6pomyW09xqOcnKQ7HkQ0Uh+PIFMVpa4xp+qALvvYzFlMuCzra2KeN14PS0dbrWN4WdLS1QG0dhfu379yNRiej0NHmomh7/9kenWacDcpr7ZJ+0zkdzP9vT3cakdFfgn2+tpV+QuHdUA/Ma/srEckGdRCv0eM+F7d51B/cTnH9h9vWBuABz2Vz0PSOpHOY96fQO5qsA42lQyXrtPIUWbz3mbc+9Di2VykTzid9/Qjpcj/aCv1ozzmd9EgnitLN5ZLWjXkup60bD+s4rdU9t5kNEMdtZgriuH/mIQ5lwiHJLkjbP7meNb0fd/+d2xWu/f7ZAGu0oucl/VLXaD9wToeHNGu0uDZstUZbAB6GYI12yXOgYVmj7WcO5AKvVS513hIKa1jWQfeRHkhaB2VbTNJfAmPIJ1vPw7YO+lmPXkhaB+X1X0l/GWCuroPG65/VddDuddB90G5CrgOOJWClWbvzYaVdU1xdB+wJK2odcNQQK0PlQdknrZEntWdug761aMy3TG0w9Vk4boOZMPwU08p1qW3Qst0MO1ZIvy9av4mz6R4mm07ypbXpJP3jYNM96rHptPuxXM64cdInf00HSnrfnTOkpZ119N19jLtbg7LDssmZSj4/eFixC4ftrNpy2l8iM83+Yv3hu+OeVTCxza/uHSWvEa3uHa3uHfnoDPPe0a/GrFvGzdtZP0v6fwRj2986pzuNyOh/hDR/b3Xv6L2wHHtHf2917+i9sBL2jv4Q+sifrO4dxY7TJ9Le0Z/E6GChwTo47d7Rryo2nKTDfRtsjy7ImjrPX37+3A72fyAdL3h/Cu33P53TzSeW+9pmd5x2B8i9+0mLpqa73L99rd+FgcJs1WfHhL3PV1lMY1cg/eXynZn2Pp9mo/LdFrSnnmx20nFcVnk34sF61RDrTUOsI4ZYDxlivWiI9Ywh1huGWJbysiyjFV+aHhyWtvq6IZZl37ZsE68YYq3qr1X9FbKMlrJ/zhDLst2/ZYhl2beHtT9a6uhhHWst6/GwIdbJMA6dDGW05MtSrw7ruP19QyxLvizl9WNDrKOGWJa2ybCOaav98fiVcVjH7ZNhnmbZJp41xBrWdv+aIdawrnW8bYgVUkdLWtzbkPsfLtzZeuY9irdpTyDQunzNdxYg7PeiKql9APE+v+bTPafEDeKbYaHYKNcLCwuV0kJtemZmJkP4wiu/4zXLtN/pEVmvCyPrBe0cWQ7k6sIoxE1Q3BjECY9O9hcQ/2H2UCsLaeSP9PNKer6Tk7YuN0bdbQ37o7bvd0ezO067y4P7fr5zatr+J95l+WvndnjFfNzOtPOOfFY/G/MenzP0Hukiveua3fl4z5F54fJmFT41WYwostDOL2QJA/spnkV1dcz+X0eIdxcmFD4N9yfraXWjvFuuewdZ4oflI8/uPIN8i/fm+qEr7lm4/ZbFz9fvP/jxO2pXVO8+dEv19o/XanfXDx7kFoY1xaVFaWhpOB2nT1sK360U7qVJN1T5tgzm79drztWEFXfDFH/zrTsXRAuNpMBhDabx5fMSy718TQLWQcLC/Hyzam0C1iHC0k5D8m8+le0Cy8uHEzeyIF/3NLv5wpGFT0vmErDuJSxtNBSsdQlY3yQszM8eWuX3WNTLJ8vLh+P+rU/g675mN19oJa0nrMkErPsJC/NPEtaGBKwHCAvzY178PRb18sny8uFkos7Jrji+HiS+8JQYn57mEQPjNF2ljcJxJ6Wx/2qnoOJOPmOf0E7e+GYEOYrT2p52GpNPqmvtQjuRJ7I9QW+fpbZEhvX2WWBPrTXfGDlsnlr/vGUha7cD4m4xRQoPQjtq8fIzsryP9222/3Judx7JF3ebjW/qS/rs3g5mpvW8eputu2zs7VXSr2vJy7W9IbjNVnd8nMi32aTN4xikzeixTcm71dtsvVirt9nS01m9zRavA6xvs5X36jTjbrOxfpb0X4SxbWZvdxqR0Ryk+WTrefU2WycdB03vSDqHmfa2DMs60Kre6m22KF0/Qrrcj74EfeQm6purt9lOzNtsN8XoYKHBOjjtbTbR7dae5mdLi9PV8vR8YbE+PVudme3H0/yqDdlJs2pD6uWyoLNqQ8brEmsb8vt92pBx3rTfgLHvkRgb8jFI8/yqDfleWA4b8vlVG/K9sBJsyLehj/y1VRsydpw+kWzIvxbIhvw+rLuuFC+h4wlYfO7Bd74gaR3dd7aD25nv5E+g/aTU3h6F/nKd/Em7P6HZtewtl0+zyjPGIR1t3d1yD0vDGjPEknrTxpG4eVfafjbk+8czadvzqvfSkxtrWPaOf0rjsuSL2ztmb3GS/l+DTfevVveO1T4mZ/147/g/Ddfe8cyJvnf8U8VmXF3366RZXffTy2VBZ3XdL14HWK/7bT1Ppxm37sf6WdIXz+tg7jivO43I6DRIc27reXXdr5OOg9W6H8t6dd2vk2bY1v0q0Ec+QX1zdd3vxFz3+0SMDhYarIPTrvtthX7/3rtmJ51hHZakPGPNDs8im9Fmh+9x4NuFtRAn6YTXiTC8FoTXXAtf+ifSxLKMUHp+HqN310JdYhmlHPgO8SX9OoiT9Fl4JzxK+x2HuHXN/rDWEtaaAbCEr7ySfs0S+dKwxglrQsHCd3gm/bOtunG6xvo8RXW2Pl+ZKZcWy4356lxhrp/zFGnWltHONOwPqb9mJe+G7VappgMlL89/XeAb39r+h/blyOXC0taiuC0E+ppm6n0GoZ+LgrbNok+uWUWu2hxb8vLc0gWuP239V/PMsFKwJL8L2jxQvI749iBYN6HsfeumrOP6WRvUPBsgv7w2+BDNb9YSr/tavwsDBtbpSEsrX9ZTPm1N/OqY8r0Cc4Lvn5dMT7vbnKE4lNEIxbHHFMSQcXMsZRkk/RMtvpPWb4XnwOu36pdEcX411uwut28u5QLPvbT7yzi/5f1PnONw//V57XCB1/5FhuORvpbPfgAk/YtQR/JlW21tiT2qYNnXUlxWoautS+O85ZepPwfaV5/V1hQlaOuurEuxn7C+5PkyxmE7QBlw0OaXIgvH1++mmF9qeoJ1wRqlHJqewH259/hr9vJ1PPotzpe532prJphe+k4+6q03bq/YByYoDvsAfwUi66GH9S+yxj4QN45qNo7wKHWR9mvzkv5vUr8L42FMH0dR73P5LPfttH0RCdo+DPd5bdzU9AH3eW3dLW2fF1n02+c1O1DTB9zntbM4Wh/g/oF9gMc3HAe4f6BNKt7vMoQZRf6xT9tHT5pvY5/APZHfo/U4oYc2D+Zlm0fS/wnYbf+A7DZtD1WrmzTn4nznKtL43ZB4FwL3/dRzTP7qTyAboO+v/gSeY1SEH20NWKvnU6L317m5zrQ9R+2Lhml0haYPfPbBcugKpL0u6m/+pfVj7ueY/v+Afhyd311+TY9miL8o8tehr85RvsKrVi+8r6zZrfKc89DR+EraR2K+tH2kSKGdVAZfu9PmqMfRLlW/jIxlHwO67p9vfugC18Gkkl6bM+YpPcpc65c8X0O66ygubb/EuZz0F9/4hXqW97a0/olj9P8PN4dQTFTGBgA=",
      "debug_symbols": "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NXHy1uStyVuTtyZvTd6avC15W/K25G3J25K3JW9L3pa8LXlb8krySvJK8krySvJK8krySvJK8kryavJq8mryavJq8mryavJq8mryavJa8lryWvJa8lryWvJa8lryWvJa8vbk7cnbk7cnb0/enrw9eXvy9uTtyevJ68nryevJ68nryevJ68nryevJO5J3JO9I3pG8I3lH8o7kHck7knfgnWOqFpfENXFLLIk1sSXuiT1x8pbkLclbkjfllae88pRXnvLKU155yitPeeUprzzllae88pRXnvLKU155yitPeeUprzzllae88pRXnvLKU155yitPeeUprzzllae88pRXnvLKU155yitPeeUprzzllae88pRXnvLKU155yitPeeUprzzllae88pRXnvLKU155yitPeeUprzzllae88pRXnvLKU155yitPeeUpr/zKq/N6wK+8mlwS18QtsSTWxJa4J/bEyevJ68nryevJ68nryevJ68nryTtzpp3XNnOYVD2H5Y05TGrxgGcbv7gkronnw88eLInnw08PtsTTO4I9cXhLrNts4xeH9xziNuYwqcXhPd+1GHOY1OLwniPyx5y0b3F4z9cVxpy0b/H0ntfPc6TU4umN3zjb+MXTG79xtvGLpzd+42zjF09v/MbZxi+ex0D8xquNT57HQPzGq41PnsdA/MarjU+ex0D8xquNBxv3g9eIpYtbYkmsiS1xT+yJuQ+9RixdnLw9eXvy9uTtyduTtydvT96evFcbif3o9AmM6/iP/ej0P1wDjyaPI3FJXBO3xJI4uYYl7ok98b7/PSebP/JCyQs1L8y6bS7MwjIX9l3huTDSQjnyQskLNS+0vCB5QfOC5YWeF/IalLwGNa9BzWtQ8xrUvAY1r0HNa1DzGtS8BjWvQc1r0HZf8rlQ8kLNC5oWZN+nngslL9S80PKC5AXNC5YXel7wvDDSgu471nOh5oWWFyQvaF6wvNDzgueFkRbsyAtTOubC7mQ+Fywv9Lyw71/PhZEW+pEXSl6oeaHlBckLmhcsL/S8kKWem4znJuP5cPF8uIx8wI58wI58wI58wI58wI58wI58wI58wI68BiOtwTXqai2UvFDzQssLkhc0L1he6HnB80Jeg5KazDUAay3UvJCazDXWah69pZa8UPNCywuSFzQvWF7oecHzQmoypaUmU1rNCy0vSF7QvGB5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",
      "brillig_names": [
        "process_message"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3754547823828078727": {
            "error_kind": "string",
            "string": "Function _mint_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5244613806648663532": {
            "error_kind": "string",
            "string": "NOTHING TO MINT"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14078072021571061404": {
            "error_kind": "string",
            "string": "Function _addLiquidity can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vZ3bruU2jobfpa5zYUkkJfarNBpBkq5uFFBIgppkgEGQdx+R4sF7B1a71lrVN1lf/duiDqZFnez88eGfH3/8/d/ff/r5X7/8z4e//f2PDz9++fT586d/f//5l59++O3TLz9P9Y8Ph/yndPzwt/LdhzLAfvnD3+r8ZbDf9e96gP2O9Vua/dq/q/279vXbqv3S+oWyfnHag/lLzX7H+u32727/HvZvnum6/LL+tmPqpQrMCwtOKNWhG1RXqivNlTbNFJoA3QCLg/9JirZgGEjhypgwigMZ8GzGWgTAgRfAAQ6uFFeqtEYVYIPWDMD/BGiAh4Mos1FASrhgGHRp7i5ABlLUBa6wK2wKaglnLVDacMH8UzsmSAkXiDKzwHY4oAG4Aq6gKzgL1sQgkUGff4JZC5RiLKAFdBwO4MAGxRXxMwW5uQs8efPkzS9ufjE0h26AxcGTkycnT06ee/fk3ZMPz11aFdoErY6CKV2rowAOw0DaeYFfXP3iigbNlebJxWkVtDoK3QCLgydHv5j8YvLcuytanXmbulZHgQzEnxeAw1gwjupgyUdxpVjyIdXB6TZD3HgBGaD/CcGBDcgVKaqC+PMCTz48+fCLh1/MzaEv4KM4WHIuhwM4WO5cm4Mnb9VBks8HlrU6Cq5odRTAYRhQdfCLu18s3a3CcGV4cul5FbQ6Cn1BOY4ShEHsVFrQcKqh1bDSahA5wREEQWEFIwVGCoqyUGhav6qEQewkfblRd5LHxshTlOMISs2tFK1lUxpO0gcsamIPlSTFEJIa0aE0NZKSFrlbi+QuGc1SEQnJE9I1hcShrpbHimQTyICLwyxml0yrFN0IgtiphFYt3NZm8bb2ooFuAhqIayxwhV1hUzQMdlLqTvI0GpGTPI9G6CRNtYAMxAkWgMMwwObgirabguQiDd06BPlVw9PJLVdgz1YqIQDH4RAKG8jNVosaKo38qubpGjhYtgDVwbIFdAWttiAdfmel4ST9zTiUupPc+FGUyEkqYdSN8ChBfp0GVKPQalxXQ5OqjKqEQewk/b1Rd5Ie34icKDQSK11I/GqwEjmN0EZo4ltGaKQB2Sg1dhJvNhpO0t0YhSbdjZHnRlCCwjJGbvJwclEaThLGjGYbsNSS5G4ZkZM8NUYQNJw4UrCn6EcNCq2EVjxtr25PQ7MROkFoENdBpBXv46bUneRuGWEQO8mzZBSaPExGYkV6ki53y4iNNDAvKiUo/ir3yGg4tdAgUoBb1pBtFBqFRqlFHlr6RaGN0Ebky5Evu8Z6P5TKEQRBbo+jHhz14KgHt9AgNPB2YYw8MDQKjULrJYicRmgjNA7N78cMBUdQaKUFdadag0JrkaKxE8RfsQSRE4VGkbZHCXpoI7SRWuTBEORaOSAotKiHBuFFNbQaWguteemL+1XVcLwIIw8MjSIthb0eWg97UQ+dtLLMEnXaaiTakBmp1mNRaCU0rYeS1mNRaC00rYeSxBgjctI7syg0fVIWRW4UJehhuUduIyyPyI3DMrvldhxBGOSWW9StRd1a1E3nxItaDQrLUILCMkZuGJYxcqOwTJFbD8s9chtheURuHJY5cov7BnHf4HDLOi4wcstQa5BbhlaC3DLAESSDr+NQ5EAZ6jiOQEq1rzFbBemPBTTgyyoFlsMBDaor1ZXminRRMhSrCDWoO4krGaETHUFrFFM1vi9ABzawsdeEYcCu8BoWTd+0YVXVwL6o2FUa1xVqdbBsycZeEyxbAlds8DhhuEUkJ/KryNORFVdn2Qu8cMOzHa7Y4HECriFb7ToEXmRDtqrh28iGZ7X7sGsSObUaFBrEdRBpMTSM6yg0siFb7f0IgqDhpAPJReTEJci1IY/1nJspQiIHllRLqjXVOgJ1ycuwB0ol58RNkQLxSIRASpXy2p4Weqojr9WVxENuzODqyKtuC0egeFyR5byJPVDX7wxTbam2VLVChhioFTKU4sja30QO1KfasAf2VHteO9LCSJXzWlYLshqoEd9w1U2xlkRpM10nPORRcsRASBVSxVS1QoYjUCtkKMWRVcE5N6yJFKg3yzBVzms5LJSjJsa1paiFrjgCV90UdXprKG0mS4lNJ+RzaKA4ArXfNUyVUqVUtUKGFKjLsobSZk0WbYtEF0dIHI46MDAsR2JYqDXVmtfqQ9ZYsFHgqpsi1kRpSVkZa7riPaeciiPQhwEthgFN176NQuMaZIGvtaMGhVZKEDnVIwidWmgNgjzqTa0l9kCtmGGqWhsB6b8VbJmiaTAX0Fi+wJXiSnGlWghsGr2NyAmOIAhiJ1xRpYHFmQngMAx6degGw5VBBuIzErAmWRCbwx+7Cg9Lh6U4oAMbVHBwpTWH7hblwTbyq9DT2TpLQ/JsLeQ3D/lNZ/QK43CAFQznwKwG0QqGTYO9kYWxRuLxRujkoXJSaC2ua5EWQoO4DkNDC4GT2IlaUHfqJQidxhGUmnQgqKbFsYos+DVdZXdMtaSqwdKQA2uqNVW5R44jEGpiD8RUZVBgSJkxZXEos+iZcdcsZDtKhwaOPVAGB3MtR5Ec1/DAEBJH4NoJW5jJaiarqbZUW6qQFiDtYuamIXQhpUp5bU8L2kGjxIChHbQhJnKgRlPD4chHS+yBRY2xIgWuai7EwOjm2OcBc6MuNEiNnXyO0xhDo9B8jtM4Om72OU5jn79NCs3nb01XCLTLhGONhhZCIgeWVG3JGA5bMgZdlQcFMqDi4Ep3pbsyrNucNJy4BVnnC+UoQeRUVl80oRvU4oAObGCrsqCRXwGag3WBUBCD/CrydNZjQ+merXV4oJF+gSt8ONgiNFTpsI3sqmo9NlTrsSdYtjrtX2DZ1uZKs9rq7vWyCOyEfhV6OuuxJ3i2/XDwbIcrAxx0l/nQzWBybLY2Ds3WxqHZ2vgMjs3BitdsmgY6uVewNf4JGCY1phv6degpbXV8BlzP2G9HI8+4u2Kr/HPZXZ522UQBncs7iqOS7mozO+oQgBTMHnhFwCsC7lVg800ArwjYfHMCezVgbeIrol/nFfGRAPhIAHwkMJN5xl4RHwmAjgTm2FNwVWOh3iPQzXgK9BA6CYLYyUMo6FBgUYvrINJCanEdhoY2i5z1akHdyUMooIdQ0GWARQOCQtOOlrqiVEp2u2ZTidqL4gjU3nWhzmC0LyCdkukjoCv8RQYbE3sgpAqp6jkLQwqkVClVeWwcMZEDdUpmmKrWzTAy1mV+x8iil5IYWehuvCMkRhZroGA4ArXGer+6zqoXao0NJQu9AV3DpiEHrhMmC3vgOm6yMC2MTMaZjCPZOEpiqqUlhoVRw+4aEhie1LwW0oLe2CHPxlh1U9QpjuEI1CHBIEUKXHVbmCqnyqGuxQNDSOTAVTdWHIG6jmBIgS3VltdCWoBUMa9Vp5VNHdDhgKHWbaHOqg2lSWRpGtaKwULtTwxdxRX/DVPVChn2QK2QoRZHDtYc0kU6YiIHQqqY12JaoFQprxX3nPsVguKThlI3Q/E+RzmIdMipnnK0RFWlvDqCcOyBNdWaaktVj48tlB7TERO1kHp0STpNxxFINTHVntf2tDBSHXmtzKjmAELOQh1H4giUftJQD3YVUMTAdiSmCqnCSeVAGWE4jkCtUOmKPbCXRAwcqY68ltMCh9qOkqhHz+T0lw42DNehtYUcKCFt1lUQ7BAE6uaBETshBIWmHb0CG0iB1tmy4kAGxZXiSnWl2kIA6jk6o+Hkq+yTyMlX2SetwQeCDd8mkIEN3xBs5DOBDYYrtsY+g7eNOhGPI8iuQhvzzMX95mDZoo15EG3Mg9hcsTEP6pGAZdFH0IjoV6GnsxHPBM/WRjyI3bPtrtiIB3H4oBNxjXgW2nU6NFhgBSYbSyPZWHquVBwOoVh9qdlBDiQfQ6MuGugf0dPZ6gcSerZ+M3S9QKG7YpMB1MUCCcCoG/2L2HYAUIcASt0WcLB7FbpXoXsVuk0HsNsCDnavQrfpwIRuuXTAIPZcdMy2yFP6feh+H7pXonsl+vCiDFdsRoM9BqCoZ+8cfQCKaz/A0HIYNp2ZYJUd7k7D3WnYlg0OCMWKPHQxdmWkUcEQIyMdqRh6Du5Lw+swvA6DwcFyYH8mdB9AwWaXyP5MsD8T7A7Ffje4efLmis0ukcGToxv0R4P90WC/JUye3J9t9keDRzQ2r1nNQm9sOtbdWLhymEtsxQEd2MBuyYRh0FyxGSYduo8hj95EDkS/Dj2lPRd0kGdsnRQd3TMerlgnRUfMMedunz/uVGyOScXmmFSsm6Ji3RT5hJ+KzTGpVFfMryZgmIw5JhXfRZvdRAkiJ6pBofW4rkfaEdqI6zg0tlkPaWQ2gqDhVGoQOdUSFJoOgWV2RBqodXZEGqh1HkQaqA2xJUp0lvPTtKKzYQ/sqfZUR6p6tnChnig3xESJuK3ocWdIHIE6wDJMtea1NS20VFteC2pBvFq3/B1HoNwpQx1utK6IgeNITJVT5ZPKjqAjRsMRqBWCQ7EH6iDEEANbqi2vhbQAqWJeuw7Uy+FtO1KvqHUz5EAdG8pOzkQO1FP/oOXVIbAiaoUMUy2pllR1CGxIgatCC6WQchqZdNHAERJHIKZKeS2lhZ5qz2u7WpBq6mjAUOumSNLhOUpLygIv6UDAkQJrqjXVluqq0EIOXBVaqMVhQR0CG/ZAKomp9ry2p4WR6shr9QgvrcP+7KjjA0PpxQ1ldFO1U9ATBJXEQtcKGaaqb29or6ErAYaYqowNDCUUVRkHk54fmD2DIgaOVPVxktET6fDAMVTdHHCERA4sqZZU9bUdwxGoEzDDHgiprropYmaMWRzMLCgzpsyiZ8Y9sxiZxcgs1osrCyMLzhpz1pizxroo4BgZ66KAY2TMrSRGxrpT4JgZQ2aBmbH2kzL+Iz1Q6NgDtVvRsKVLBY6YyIE6szbshl3fAnDERA4sqZZUa6otLbS0Cy1xBGKqmNdSWtBuZej7LbpUsFC7FUM1BvoCDAVqt2LIjmvVYKCgdiuGGFjzAj/C1osfYeulhQah+fG8Xvx4Xi8YGoVG6NSPIAhipxGa78v3wpGb78vP/qIEeW7rgIFs6PR1wMCQAyskpqp7VayEThgahkahUWg9tB7aCG2ExqGxa+uE4aLQSmh6wnARO9XQamgtND2Vq6S3Z1F30tuziJyiRi1qpDsRi3pY7mFZj00sCsscubFb1pUFI7cMUTeIukHUDWoL8tyg1SDPTd/dM4rc4m5B3C3AsEyRG4XlHrn1sDwitxGWOXKL+4Zx33Tpwchz0xGIkeem4w8jz01HH0aeG4YnYniiblgswsgNwzJFbhSWe+SmLyrKqwpd9ykMdWnKsDvS6vgWRrI1/DDEQA1jC/WdSsNUIVXtyRdiWqC0S5lbTzWLricVHbO8nNdyXKtnCJosmnUdEDhSIKVKqfZU5Tk2HKmOvFaazzFyG9K3Njkb1nU/wLDUxFRrqjXVVhJThbxW4oYhZm7i54bi6IasWBU1mQQLfVPPsEAiB9aWqGVYbymqBQkLOut3pEDpRxwhsOe1Iy8Y2r4kyCVxGM5BVkvkwFXehamu8nbB1XwLKRAgkQMxk2EPpLTQtbxDERM5cLTEHrgqtDCS6RKA40kNY7oQ4BjGdPd/9vOKPbBBIgfqy8ELV90Wdmv1UVbdFmJgT1UdXF7EHrrb3+Qw4dCDfAs1zBpKp+AoxmRqO/QgnyMkjkDpzR0pEDIZpDFMFdMYpjFKY5TGeibrmaxnsqFqFdTnWFEjZ5M3qIeGTke1Ky3ZVhkUV8YLpX1lljv0NL5jqtqBQFHEQG1fw1D1RT3Hk8qB6iXyXvTQCbojBaprGHIgZDIdYvJ6YVj6VHndaaKqcudB50XyasfQ4/eGOpiUgDJR7B7rTWMIlMDu2AO1lzMcgS2S6YS3ySbW0AmvoTqXIQXWVJcFUFS7pG83q7GhSIEaAwwxULsrw1T1vi0caWykyqlyqP2oiZFxLyUREzlQu/hD2lfns44UqE9A0dezteiGHKg9rWGqWkhZTRl6rG2h7lY7qnNJ843lUYrLoxZS4PocASpCIgdCqpAqpoqpUqoyDjPsLbEHrqdFUftUQ3LkoyTGtfpOm2FVVVxDXydvss4zZ7aabChSIKVKqWpfYghhQSOZYQ9crb5wGPKKZIaplppIgerKsr/JOlVscrB+xmtI1HvcBLU4hiNQndawB3Kq2nyKKyQZQmIY061kx0ymXmKIiVGyFZ0M0xikMYiS6XzRMY1RlmxVHhRHoDrMwhFq1c5G3hRg/TqKoY4JDDGRA1dTL8xkmKpGnIWUqvb2EixZl5oNtbc3xEQO5JYYyfSEuWOqpSTqDRAvaat9hyIHQqo6VCssuGqxsAeqrxtiIgf2TNYz2XKuhakujxKEFdGlDLAi+kKPm6zviBvqPTbUx1Q+AwHreVt4Uj0AsoYkxxHIqXKoeLTEHlg8brKeITOsEKhDFMMeCJlMW0frhto6C/XOa4X0FJih3mPFFeq0QivULSyprp6g6IctjkQMbKm2VCHV1RUvHF5eQgqkkhiVpw6JkWx1bfKyx+wptFeQHQn5REY9MSVrx+Cs48u6mJMbnPikw0mHk44nHU86nezTSddb49yT1yzO+JR2nNLqdMnqu8a88r7xsfo+4zW+hcWY3E661tFZ7ZCy9jPOJ309FH1xT9Z75XzKq5cT530p+mg4czKfysOp16OduCeXcuLM1wb08Oef333w71t9/9uXjx/l81anD179/Y8Pv/7w5ePPv33428+/f/783Yf//eHz73rR//z6w8/6+9sPX+Zfp89//Pmf83ca/Nenzx+F/vwuUx/XSeGQcYymhhkfw0A5+l0Ts4/zAkysj5iYLTLMxIwyfGmiXZuQL78UsyHffsly9PvFGMUbY64Hl8ti4LWJIUFGLZwNtDHeGKBrAyTjVTUwF4MuDexuB/Tqt2NOFS4rMTZtOaMoe1vOUHhyiwJvjPDGCLI3xXwA6WSivDFRdt452FsD5pjt6pbKQO/yhkB45xxfX5rYVYRaNMacy1xXZOOdczzkzlmx5n2dO/dvbcCmHONw7yxz5ndt43Y56NLG7ebg6+bo1zY6eU3mumFYgHq7DL1GU8w1xusybGw03adcz8kcNlw2Rd11GHq2eDXnHP1e35Lb5WgP3ZJzc7x5Wt82R23f8JYMONI7rx/3uuk85yjRC4FzH+TqWa30gjCwLQe0KAfAeMyErKm4Cb40sWlRYvetuckZBmakvH9LKG/JKJe3pG26z7k5Ek1Bx2U9ZOHvOiQOb4pRT635Ppa0V0T3bUEqjgjOx6Ygm/taOdpDXnEPG+OdCdq1hzjOKkahbNI2m/eNjb67LS3cC+E8TsCvKEePctRSr8uxcTHZBHEn5VNMem8DdgMWdD+H0zChtrdjWCi7bpgjqtWTk36VjTo4hqBHfcxGj9FfnYPiSxvbZ7bUfGavu3LY+Gg7ivu5fMDg2sYLnAP6C5xjPO0c/ALn4Bc4B39j54jhsHw/7PLG7kww+32tc0J+aQJhF6ZjtjZ327MYlW8XY06ZjyjGm5jwrhgbF51LUW5j4mWUxr6bHESDzs2W+sDkoOazVs/x4C8V2dhgdMeYe7iPtOa8qZCFuL6puylfj2d1jiZzRI1vLdAmvBY4IkTDycR01bc22i5EU44VxuVsjTbeOXee456WcukWtOlAS0Hyu1rKZtiznUO37MnnmjJeDjdoF+e7l4OO6/tK4+kpNPHTU+hdPagcsapxPYPum9g6J64RCeZ231Uh+sZBOUsxV3UfWSBqFPM9+QLH5dpK303j55Jo9OKy+PnIQlXDeOChwkMLVTE/mZuRl+tMve8WAmou8DS87Li2NjBnjXiaJrV3k9/bNk4zz/c2xm6kEvF9vFl/fPeobp93jK6rzB2gh4zUI3rhepyWZ971wmM3UyqA4V39uOyFx8ZFew5C+zi5+fveD3fLCcWDQadTXHxvgvY1iZWmAtfrAWMbGWOB5miXYW1sTBD5LaE3c+jjoTKchkvvysCb532ki485Iw8TxPdNjBIuPqA/YmLuu7uH89zoeKgU3DlNXFdk13/ObfoIrLJPnw98bbc78hHLCe3NNOtdB8q0XY/NFW45l/ZQQRhj84R7eWj/hY+aJjZ14RcEpV3npa9X20Tr9Mjj+/X+sutFsxOFcqrLu/WVctTtulf4R7rY3Bf5ChN46oc3JuD52W858Nnp775JIWLbjJS0adLd+K3Ho9+PN93g+xbZdYTHEYF6brheluSuj1G59LHdptJtH9ttK930sa2Jez6228657WO7faWbPrZt0rs+VugFPrbbWXq1j/V67WP8Ah/b7S7d9LGtiXs+VusLfGy3u3TXx/gFPrbblrntY/s9phf42MgDD8flQL/U8fT6V6n89ALY3adlXI6wS3tF1G/PR/32fNRvr4j67fmo314R9dvNqF+Jrp+WNrYzwdhYHtfT0Xse1k7e8d7DdntMd2fFZbe9c3NaXKA+PS8u0F4wMf4PtTmyNteb3GW30zSXgGouAZ2Xb+j23YURGxJ44PXd7a+4u+MFd5efv7t4fNtljzfHfMp1eMH6Ddc93hQCrsdRu62mmwsfexv3Vj62Nm4ufezLcW/to+B4xeLHbsW0No5zjnCOdF+x6lp1qrdslNMg6GEbFR+ykftWvTxt4XRnv2L1eI58c6untnZcLv2W3a7T3fEc0bccz0kFKCvz5iTX+8o8v+1UXrDvdP/O4HhkUR56jCxhbMbqu62n2xGqt+cj1G736W6E6vhtIxSMGv4xTs7+l0bdhf1cs5wbJ9cxamvk6TB3rgnDdU3GPuYXyBY9bZG+Dw57K0TpZcTtQSujxTMj/0O9KyvbqWnB6MrgelC324S6PSncbUPdnBRuTdybFI4XHIQq4+mTUPsmvTsp3G3h3F5C4fJNl1De+Bhed8vcXuBj2w2pez62NXHPx3a7Ubd9jPvTPrZt0ts+xs/7WD2Ob+xjcQ7ozZAMy0NeSpfLY/V4gZfW42kv3Zu45aX1eIGX1uNpL9036U0vrccrvLQc/72ecFxOtGupL/Cx3XbUTR/bmrjnYwVf4GO7zaibPrZt0rs+VsbzS7C18DdcgsUSr57JB+4vPaxuV6TvHQ+tdfsKx63zoXW3F3XzgGitu67wBSdEe43Dnf38OspfGpVe8NjW/vRjuzVx77GtL3iVpLan3yXZN+ndx3a3k3Q7NOxfeno6NLzxsdPBxvc+ttuNuu1jjZ72sa2Jez623Yu67WP8tI9tm/Suj+02cG772G4/6hU+ph8DMx+D8sAg+Y2XtsuTYxVe4aXwvJfC814Kr/BSeN5L4RVeiq/wUqz/vZ7wekmq4guWpCo+vSS1N3HPx/AFS1IVn16S2jfpXR+jm0tS20EylW84SH7jYddnEyu94PR+peeP71d6/vx+pVcc4P8Ptbl1TqHudqNecE6ht+FdUIejPRLlAHpY2CwF7d6Cuu0fu82ou/6x3Yu66R/bN6FesI8k34/2cuD14KN2en4faWvk6X2kc034eq2x9u0ZScgAheli71/J2hq5eV5ia+PmeYk66tPnJbY2Sn7WpJy7daCvsDHG6TMa/crG7jNGDeMjW41PT+27NzTq7nWoOPdx+t4N3H7PRL46FiMouH4Fs47nN/X1ZfknN/W3VeHsNcr1B4jqbgPqblW4ftuqxBdJyrH5tFTdbx7FpxpmcCvXVdmEe8Y4icOI5cmqlHpdld3izYFekXaeKvylItu5U4u1vdN3GuD+59OO+LzVLA880BJzCB3VqP0yNLbtSztHyZdaZwf6UDkaxXthrdN1ObZLUJQP23E+H/UV5YDqsaABlOty7GY8R89zb0dneqgcB2Y5rr8gdGxfLxkjv0PE9aH7gvl5Fty1xy7Qn6eipQ1+oBxVz6CvYU/B6w+S7E3Ee+jl9PXIrzJx7/Ms269HtjQB9SETFDG+ng/OfI2Jm9932VaETm8ePWaixU7NbJXyWCnufexmYwLj85H4WEtgRGc6ner8CgNvxjv0mIkS4X3OTsZjJuh8lOohEy2/+dP4sVJgPX1koT9mgnKZZvBjFTnym6L1sYq0nN40fKwilN/Eo/5YKXrPOQU/9HwUzrbg+pCJDjUXEx4xwLGSwPhQO3B8qZbrYyWIh4M7PlmFxwxgzDBxnI5+3//YLpX8Wm99yMCzn/vFGGzSAQ+VIOamdP4Y4X0DN+fpx9Oz9O2rstGOZdT+kAU8fV0XHrKQfeToj5XheqXhH/NfP/z06cv3pw+E//Gn2Pry6YcfP3+0f/7r959/Ov31t//71f/y45dPnz9/+vf3v3755aeP//z9y0exJH/7cNh//l7mutN3hZn/8d2Hpv+eg8wpwvw3zn/XYz6xdQa1f8hnzOUCnGvIc/55iFD0irmINf9T//GnFPn/AQ==",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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1bN3eLY3nPG6Z+lpPahWn5cYJZ71RutvldD0maj+3laYpK+ByVslZswlKvOHl0uelxDWCRN974cIX1DX470fcqTlTuy9rajxxlyp+ZW5PyjR+A5ZT581+KOtiLl3pcp7P4S1lF/dffLpvni7xJj8kLxw/J9shXJE6ucl5K0SLdawK+2w90oIvdba3iqRI6e/ty8aXw/sP3xA+c0S7x3U/Ep4K++VYDHkLvJmCX7ID98w+YMScedWur13UHt0TpVxHG+eF6xwXd86qD2+RvZD59bzApyao369H15Dd7LNvU5cpDuMx0sbjs73DfStn6Fxs9ffOhZj0EfR3yoQK1WO2d4rEMsyz/5Zgbws8x/tRPon38pKiW6r/J7qe1vw82H8r6//+w//+M//9t/++q//+A///s//+i//5/X3/vMs9W///A///a//dP/f//l//+Uf03/99//v/17/5b//2z//9a///L/+2//+t3/9x3/6H//33/7prHT+t78c9//8l3m8Rk5eT4btv/7dX8rr/5/vFOrfvf53jte/af4nXoOk82h2/onzr8j5aY7X/8zzX5x/Z7bXb3jdj5X/+p/nRv//AA==",
      "brillig_names": [
        "sync_private_state"
      ]
    },
    {
      "name": "toBeMinted",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "tokenA",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tokenB",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "toBeMinted"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000002"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000002"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "FactoryV3"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "pools",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "feeAmountTickSpacing",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "ticks",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "approved_lps",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "protocolFees",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "positions",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "tickBitmap",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "observations",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "observationByIndex",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "RouterV3"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "factory",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "liquidityToBeMinted",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "tokenA",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "tokenB",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "sqrtPriceX96",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "liquidity",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "tick",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "isNegTick",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "RouterV3::_addLiquidity_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "RouterV3::_addLiquidity_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "tokenA",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "tokenB",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "RouterV3::_getPool_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "token0",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token1",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "tickSpacing",
                    "type": {
                      "kind": "integer",
                      "sign": "signed",
                      "width": 32
                    }
                  },
                  {
                    "name": "maxLiquidityPerTick",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "feeGrowthGlobal0X128",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "feeGrowthGlobal1X128",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "slot0",
                    "type": {
                      "fields": [
                        {
                          "name": "sqrtPriceX96",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "tick",
                          "type": {
                            "kind": "integer",
                            "sign": "signed",
                            "width": 32
                          }
                        },
                        {
                          "name": "observationIndex",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 16
                          }
                        },
                        {
                          "name": "observationCardinality",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 16
                          }
                        },
                        {
                          "name": "observationCardinalityNext",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 16
                          }
                        },
                        {
                          "name": "feeProtocol",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 8
                          }
                        },
                        {
                          "name": "unlocked",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "factory::pairV3::Slot0"
                    }
                  },
                  {
                    "name": "liquidity",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "protocolFees",
                    "type": {
                      "fields": [
                        {
                          "name": "token0",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "token1",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "factory::pairV3::ProtocolFees"
                    }
                  },
                  {
                    "name": "initiated",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "rate",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "rate_mul",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "rate_time",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "factory::pairV3::Pair"
              }
            }
          ],
          "kind": "struct",
          "path": "RouterV3::_getPool_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "tokenA",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "tokenB",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "tickLower",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "tickUpper",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "isTickLowerNeg",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "isTickUpperNeg",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount0Min",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "amount1Min",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "lte",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "RouterV3::_mint_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "RouterV3::_mint_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "tokenA",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "tokenB",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "tickLower",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "tickUpper",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "isTickLowerNeg",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "isTickUpperNeg",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "amount0Min",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "amount1Min",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "lte",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "getSqrtRatioAtTickUpper",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "getSqrtRatioAtTickLower",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "RouterV3::_mint_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "array",
                "length": 3,
                "type": {
                  "kind": "field"
                }
              }
            }
          ],
          "kind": "struct",
          "path": "RouterV3::_mint_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "tokenA",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "tokenB",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "tickLower",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "tickUpper",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "isTickLowerNeg",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "isTickUpperNeg",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "amount0Desired",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "amount1Desired",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "amount0Min",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "amount1Min",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "lte",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "sqrtPriceX96",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "RouterV3::addLiquidity_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "RouterV3::addLiquidity_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_factory",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "RouterV3::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "RouterV3::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "tokenA",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "tokenB",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "RouterV3::currentTick_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "signed",
                "width": 32
              }
            }
          ],
          "kind": "struct",
          "path": "RouterV3::currentTick_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "RouterV3::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "RouterV3::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "RouterV3::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "RouterV3::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "tokenA",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "tokenB",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "RouterV3::toBeMinted_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "RouterV3::toBeMinted_abi"
        }
      ]
    }
  },
  "file_map": {
    "101": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "105": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/macros/authwits.nr",
      "source": "use crate::macros::utils::{\n    compute_struct_selector, derive_serialize_if_not_implemented, get_trait_impl_method,\n};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\npub comptime mut global AUTHWIT_TYPES: UHashMap<Field, TypeDefinition, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\ncomptime fn register_authwit(authwit_selector: Field, authwit_struct: TypeDefinition) {\n    if AUTHWIT_TYPES.contains_key(authwit_selector) {\n        let existing_authwit = AUTHWIT_TYPES.get(authwit_selector).unwrap().name();\n        let authwit_name = authwit_struct.name();\n        panic(\n            f\"Authwit selector collision detected between authwits '{authwit_name}' and '{existing_authwit}'\",\n        );\n    }\n    AUTHWIT_TYPES.insert(authwit_selector, authwit_struct);\n}\n\npub comptime fn generate_auhtwit_interface_and_get_selector(s: TypeDefinition) -> (Quoted, Field) {\n    let name = s.name();\n\n    let authwit_selector = compute_struct_selector(\n        s,\n        quote { crate::authwit::authwit_selector::AuthwitSelector::from_signature },\n    );\n\n    let from_field = get_trait_impl_method(\n        quote { crate::authwit::authwit_selector::AuthwitSelector }.as_type(),\n        quote { crate::protocol_types::traits::FromField },\n        quote { from_field },\n    );\n\n    let authwit_interface = quote { crate::authwit::authwit_interface::AuthwitInterface };\n    let authwit_selector_type = quote { crate::authwit::authwit_selector::AuthwitSelector };\n\n    (\n        quote {\n        impl $authwit_interface for $name {\n\n            fn get_authwit_selector() -> $authwit_selector_type {\n                $from_field($authwit_selector)\n            }\n\n            fn emit_as_offchain_effect_and_get_hash(self) -> Field {\n                let inner_hash = compute_inner_authwit_hash(protocol_types::traits::Serialize::serialize(self));\n                crate::oracle::offchain_effect::emit_offchain_effect([$authwit_selector, inner_hash]);\n                inner_hash\n            }\n        }\n    },\n        authwit_selector,\n    )\n}\n\npub comptime fn authwit(s: TypeDefinition) -> Quoted {\n    let (authwit_interface_impl, authwit_selector) = generate_auhtwit_interface_and_get_selector(s);\n    register_authwit(authwit_selector, s);\n\n    let serialize_impl = derive_serialize_if_not_implemented(s);\n\n    quote {\n        $authwit_interface_impl\n        $serialize_impl\n    }\n}\n"
    },
    "106": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        authwits::AUTHWIT_TYPES,\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n    let process_message = generate_process_message();\n    generate_authwit_exports();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_authwit_exports() {\n    let authwits = AUTHWIT_TYPES.values();\n    authwits.for_each(|(s): TypeDefinition| { s.add_attribute(\"abi(authwits)\"); });\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "107": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "110": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_array, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n    size_in_fields,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    } else {\n        if is_void {\n            create_utility_void_stub(f)\n        } else {\n            create_utility_stub(f)\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n    let params_num_fields =\n        fn_parameters.fold(0, |acc, (_, typ)| acc + crate::macros::utils::size_in_fields(typ));\n\n    let serialized_args_index_name = quote { serialized_args_index };\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args = [0;2];\n    // let mut serialized_args_index = 0;\n    // let target_address_serialized = aztec::protocol_types::traits::Serialize::serialize(target_address)\n    // for i in 0..target_address_serialized.len() {\n    //    serialized_args[serialized_args_index] = target_address_serialized[i];\n    //    serialized_args_index += 1;\n    // }\n    // serialized_args[serialized_args_index] = fee_juice_limit_per_tx as Field\n    // serialized_args_index += 1;\n    // ```\n    let serialized_args_array_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_NAME = [0; $params_num_fields];\n            let mut $serialized_args_index_name: u32 = 0;\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append =\n                add_to_field_array(SERIALIZED_ARGS_NAME, serialized_args_index_name, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n"
    },
    "111": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "114": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "116": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ, _) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "117": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "119": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "121": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "122": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    prelude::AztecAddress,\n    utils::array,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__EVENT_COMMITMENT, hash::poseidon2_hash_with_separator_bounded_vec,\n    traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private_log` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "123": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "124": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "125": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "126": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "142": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "155": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "158": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "162": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "163": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "164": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "165": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "166": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "167": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "172": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "173": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "175": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(validateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(bulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "177": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, note nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "178": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/offchain_effect.nr",
      "source": "use protocol_types::traits::Serialize;\n\n/// Emits data that will be delivered to PXE unaltered. This data can be interpreted freely by a\n/// downstream consumer (such as a wallet).\n///\n/// # Arguments\n///\n/// * `data` - The data to emit.\npub fn emit_offchain_effect<T, let N: u32>(data: T)\nwhere\n    T: Serialize<N>,\n{\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { emit_offchain_effect_oracle_wrapper(data) };\n}\n\nunconstrained fn emit_offchain_effect_oracle_wrapper<T, let N: u32>(data: T)\nwhere\n    T: Serialize<N>,\n{\n    emit_offchain_effect_oracle(data.serialize());\n}\n\n#[oracle(emitOffchainEffect)]\nunconstrained fn emit_offchain_effect_oracle<let N: u32>(data: [Field; N]) {}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "180": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "184": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "193": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "207": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "210": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "211": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "213": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "214": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "216": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "218": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "230": {
      "path": "/home/g/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "248": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "291": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "308": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "309": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "323": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] != 0 };\n        consumed_counter = 1;\n    } else if typ.is_field() | typ.as_integer().is_some() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type, _) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type, _)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    let serialize_trait: TraitConstraint =\n        quote { Serialize<$serialized_len> }.as_trait_constraint();\n    quote {\n        impl $serialize_trait for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "325": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "326": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "336": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] != 0,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] != 0,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] != 0,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] != 0,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "347": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "361": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    #[inline_always]\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// T = type of item in BoundedVec\n// M = max length of BoundedVec\n// O = field length of T\n// O * M + 1 = total serialized length of BoundedVec<T, M> (the +1 is for length of the BoundedVec)\nimpl<T, let M: u32, let O: u32> Deserialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Deserialize<O>,\n{\n    #[inline_always]\n    fn deserialize(fields: [Field; O * M + 1]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[O * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; O];\n            for j in 0..O {\n                nested_fields[j] = fields[i * O + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl<let N: u32> Deserialize<0> for () {\n    fn deserialize(_fields: [Field; 0]) -> Self {\n        ()\n    }\n}\n\nimpl<T, let M: u32, let O: u32> Serialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Serialize<O>,\n{\n    #[inline_always]\n    fn serialize(self) -> [Field; O * M + 1] {\n        let mut fields = [0; O * M + 1];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..O {\n                fields[i * O + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[O * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    #[inline_always]\n    fn deserialize(fields: [Field; N]) -> Self {\n        str::<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "366": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as u8 as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as u16 as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as u32 as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as u64 as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "367": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T, let N: u32> Serialize<N + 1> for Option<T>\nwhere\n    T: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T, let N: u32> Deserialize<N + 1> for Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    fn deserialize(fields: [Field; N + 1]) -> Self {\n        if fields[0] == 1 {\n            let mut value_serialized: [Field; N] = std::mem::zeroed();\n            for i in 0..N {\n                value_serialized[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_serialized))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "385": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_padded_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_padded_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_padded_array::{\n    assert_sorted_transformed_i_padded_array_capped_size,\n    assert_sorted_transformed_padded_array_capped_size, validate_padded_items,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_padded_arrays::assert_split_transformed_padded_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "388": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "39": {
      "path": "std/ops/arith.nr",
      "source": "use crate::convert::AsPrimitive;\n\n// docs:start:add-trait\npub trait Add {\n    fn add(self, other: Self) -> Self;\n}\n// docs:end:add-trait\n\nimpl Add for Field {\n    fn add(self, other: Field) -> Field {\n        self + other\n    }\n}\n\nimpl Add for u128 {\n    fn add(self, other: u128) -> u128 {\n        self + other\n    }\n}\nimpl Add for u64 {\n    fn add(self, other: u64) -> u64 {\n        self + other\n    }\n}\nimpl Add for u32 {\n    fn add(self, other: u32) -> u32 {\n        self + other\n    }\n}\nimpl Add for u16 {\n    fn add(self, other: u16) -> u16 {\n        self + other\n    }\n}\nimpl Add for u8 {\n    fn add(self, other: u8) -> u8 {\n        self + other\n    }\n}\nimpl Add for u1 {\n    fn add(self, other: u1) -> u1 {\n        self + other\n    }\n}\n\nimpl Add for i8 {\n    fn add(self, other: i8) -> i8 {\n        self + other\n    }\n}\nimpl Add for i16 {\n    fn add(self, other: i16) -> i16 {\n        self + other\n    }\n}\nimpl Add for i32 {\n    fn add(self, other: i32) -> i32 {\n        self + other\n    }\n}\nimpl Add for i64 {\n    fn add(self, other: i64) -> i64 {\n        self + other\n    }\n}\n\n// docs:start:sub-trait\npub trait Sub {\n    fn sub(self, other: Self) -> Self;\n}\n// docs:end:sub-trait\n\nimpl Sub for Field {\n    fn sub(self, other: Field) -> Field {\n        self - other\n    }\n}\n\nimpl Sub for u128 {\n    fn sub(self, other: u128) -> u128 {\n        self - other\n    }\n}\nimpl Sub for u64 {\n    fn sub(self, other: u64) -> u64 {\n        self - other\n    }\n}\nimpl Sub for u32 {\n    fn sub(self, other: u32) -> u32 {\n        self - other\n    }\n}\nimpl Sub for u16 {\n    fn sub(self, other: u16) -> u16 {\n        self - other\n    }\n}\nimpl Sub for u8 {\n    fn sub(self, other: u8) -> u8 {\n        self - other\n    }\n}\nimpl Sub for u1 {\n    fn sub(self, other: u1) -> u1 {\n        self - other\n    }\n}\n\nimpl Sub for i8 {\n    fn sub(self, other: i8) -> i8 {\n        self - other\n    }\n}\nimpl Sub for i16 {\n    fn sub(self, other: i16) -> i16 {\n        self - other\n    }\n}\nimpl Sub for i32 {\n    fn sub(self, other: i32) -> i32 {\n        self - other\n    }\n}\nimpl Sub for i64 {\n    fn sub(self, other: i64) -> i64 {\n        self - other\n    }\n}\n\n// docs:start:mul-trait\npub trait Mul {\n    fn mul(self, other: Self) -> Self;\n}\n// docs:end:mul-trait\n\nimpl Mul for Field {\n    fn mul(self, other: Field) -> Field {\n        self * other\n    }\n}\n\nimpl Mul for u128 {\n    fn mul(self, other: u128) -> u128 {\n        self * other\n    }\n}\nimpl Mul for u64 {\n    fn mul(self, other: u64) -> u64 {\n        self * other\n    }\n}\nimpl Mul for u32 {\n    fn mul(self, other: u32) -> u32 {\n        self * other\n    }\n}\nimpl Mul for u16 {\n    fn mul(self, other: u16) -> u16 {\n        self * other\n    }\n}\nimpl Mul for u8 {\n    fn mul(self, other: u8) -> u8 {\n        self * other\n    }\n}\nimpl Mul for u1 {\n    fn mul(self, other: u1) -> u1 {\n        self * other\n    }\n}\n\nimpl Mul for i8 {\n    fn mul(self, other: i8) -> i8 {\n        self * other\n    }\n}\nimpl Mul for i16 {\n    fn mul(self, other: i16) -> i16 {\n        self * other\n    }\n}\nimpl Mul for i32 {\n    fn mul(self, other: i32) -> i32 {\n        self * other\n    }\n}\nimpl Mul for i64 {\n    fn mul(self, other: i64) -> i64 {\n        self * other\n    }\n}\n\n// docs:start:div-trait\npub trait Div {\n    fn div(self, other: Self) -> Self;\n}\n// docs:end:div-trait\n\nimpl Div for Field {\n    fn div(self, other: Field) -> Field {\n        self / other\n    }\n}\n\nimpl Div for u128 {\n    fn div(self, other: u128) -> u128 {\n        self / other\n    }\n}\nimpl Div for u64 {\n    fn div(self, other: u64) -> u64 {\n        self / other\n    }\n}\nimpl Div for u32 {\n    fn div(self, other: u32) -> u32 {\n        self / other\n    }\n}\nimpl Div for u16 {\n    fn div(self, other: u16) -> u16 {\n        self / other\n    }\n}\nimpl Div for u8 {\n    fn div(self, other: u8) -> u8 {\n        self / other\n    }\n}\nimpl Div for u1 {\n    fn div(self, other: u1) -> u1 {\n        self / other\n    }\n}\n\nimpl Div for i8 {\n    fn div(self, other: i8) -> i8 {\n        self / other\n    }\n}\nimpl Div for i16 {\n    fn div(self, other: i16) -> i16 {\n        self / other\n    }\n}\nimpl Div for i32 {\n    fn div(self, other: i32) -> i32 {\n        self / other\n    }\n}\nimpl Div for i64 {\n    fn div(self, other: i64) -> i64 {\n        self / other\n    }\n}\n\n// docs:start:rem-trait\npub trait Rem {\n    fn rem(self, other: Self) -> Self;\n}\n// docs:end:rem-trait\n\nimpl Rem for u128 {\n    fn rem(self, other: u128) -> u128 {\n        self % other\n    }\n}\nimpl Rem for u64 {\n    fn rem(self, other: u64) -> u64 {\n        self % other\n    }\n}\nimpl Rem for u32 {\n    fn rem(self, other: u32) -> u32 {\n        self % other\n    }\n}\nimpl Rem for u16 {\n    fn rem(self, other: u16) -> u16 {\n        self % other\n    }\n}\nimpl Rem for u8 {\n    fn rem(self, other: u8) -> u8 {\n        self % other\n    }\n}\nimpl Rem for u1 {\n    fn rem(self, other: u1) -> u1 {\n        self % other\n    }\n}\n\nimpl Rem for i8 {\n    fn rem(self, other: i8) -> i8 {\n        self % other\n    }\n}\nimpl Rem for i16 {\n    fn rem(self, other: i16) -> i16 {\n        self % other\n    }\n}\nimpl Rem for i32 {\n    fn rem(self, other: i32) -> i32 {\n        self % other\n    }\n}\nimpl Rem for i64 {\n    fn rem(self, other: i64) -> i64 {\n        self % other\n    }\n}\n\n// docs:start:neg-trait\npub trait Neg {\n    fn neg(self) -> Self;\n}\n// docs:end:neg-trait\n\n// docs:start:neg-trait-impls\nimpl Neg for Field {\n    fn neg(self) -> Field {\n        -self\n    }\n}\n\nimpl Neg for i8 {\n    fn neg(self) -> i8 {\n        -self\n    }\n}\nimpl Neg for i16 {\n    fn neg(self) -> i16 {\n        -self\n    }\n}\nimpl Neg for i32 {\n    fn neg(self) -> i32 {\n        -self\n    }\n}\nimpl Neg for i64 {\n    fn neg(self) -> i64 {\n        -self\n    }\n}\n// docs:end:neg-trait-impls\n\n// docs:start:wrapping-add-trait\npub trait WrappingAdd {\n    fn wrapping_add(self, y: Self) -> Self;\n}\n// docs:end:wrapping-add-trait\n\nimpl WrappingAdd for u1 {\n    fn wrapping_add(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingAdd for u8 {\n    fn wrapping_add(self: u8, y: u8) -> u8 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u16 {\n    fn wrapping_add(self: u16, y: u16) -> u16 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u32 {\n    fn wrapping_add(self: u32, y: u32) -> u32 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u64 {\n    fn wrapping_add(self: u64, y: u64) -> u64 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u128 {\n    fn wrapping_add(self: u128, y: u128) -> u128 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i8 {\n    fn wrapping_add(self: i8, y: i8) -> i8 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i16 {\n    fn wrapping_add(self: i16, y: i16) -> i16 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i32 {\n    fn wrapping_add(self: i32, y: i32) -> i32 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i64 {\n    fn wrapping_add(self: i64, y: i64) -> i64 {\n        wrapping_add_hlp(self, y)\n    }\n}\nimpl WrappingAdd for Field {\n    fn wrapping_add(self: Field, y: Field) -> Field {\n        self + y\n    }\n}\n\n// docs:start:wrapping-sub-trait\npub trait WrappingSub {\n    fn wrapping_sub(self, y: Self) -> Self;\n}\n// docs:start:wrapping-sub-trait\n\nimpl WrappingSub for u1 {\n    fn wrapping_sub(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingSub for u8 {\n    fn wrapping_sub(self: u8, y: u8) -> u8 {\n        wrapping_sub_hlp(self, y) as u8\n    }\n}\n\nimpl WrappingSub for u16 {\n    fn wrapping_sub(self: u16, y: u16) -> u16 {\n        wrapping_sub_hlp(self, y) as u16\n    }\n}\n\nimpl WrappingSub for u32 {\n    fn wrapping_sub(self: u32, y: u32) -> u32 {\n        wrapping_sub_hlp(self, y) as u32\n    }\n}\nimpl WrappingSub for u64 {\n    fn wrapping_sub(self: u64, y: u64) -> u64 {\n        wrapping_sub_hlp(self, y) as u64\n    }\n}\nimpl WrappingSub for u128 {\n    fn wrapping_sub(self: u128, y: u128) -> u128 {\n        wrapping_sub_hlp(self, y) as u128\n    }\n}\n\nimpl WrappingSub for i8 {\n    fn wrapping_sub(self: i8, y: i8) -> i8 {\n        wrapping_sub_hlp(self, y) as i8\n    }\n}\n\nimpl WrappingSub for i16 {\n    fn wrapping_sub(self: i16, y: i16) -> i16 {\n        wrapping_sub_hlp(self, y) as i16\n    }\n}\n\nimpl WrappingSub for i32 {\n    fn wrapping_sub(self: i32, y: i32) -> i32 {\n        wrapping_sub_hlp(self, y) as i32\n    }\n}\nimpl WrappingSub for i64 {\n    fn wrapping_sub(self: i64, y: i64) -> i64 {\n        wrapping_sub_hlp(self, y) as i64\n    }\n}\nimpl WrappingSub for Field {\n    fn wrapping_sub(self: Field, y: Field) -> Field {\n        self - y\n    }\n}\n\n// docs:start:wrapping-mul-trait\npub trait WrappingMul {\n    fn wrapping_mul(self, y: Self) -> Self;\n}\n// docs:start:wrapping-mul-trait\n\nimpl WrappingMul for u1 {\n    fn wrapping_mul(self: u1, y: u1) -> u1 {\n        self & y\n    }\n}\n\nimpl WrappingMul for u8 {\n    fn wrapping_mul(self: u8, y: u8) -> u8 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u16 {\n    fn wrapping_mul(self: u16, y: u16) -> u16 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u32 {\n    fn wrapping_mul(self: u32, y: u32) -> u32 {\n        wrapping_mul_hlp(self, y)\n    }\n}\nimpl WrappingMul for u64 {\n    fn wrapping_mul(self: u64, y: u64) -> u64 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i8 {\n    fn wrapping_mul(self: i8, y: i8) -> i8 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i16 {\n    fn wrapping_mul(self: i16, y: i16) -> i16 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i32 {\n    fn wrapping_mul(self: i32, y: i32) -> i32 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i64 {\n    fn wrapping_mul(self: i64, y: i64) -> i64 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u128 {\n    fn wrapping_mul(self: u128, y: u128) -> u128 {\n        wrapping_mul128_hlp(self, y)\n    }\n}\nimpl WrappingMul for Field {\n    fn wrapping_mul(self: Field, y: Field) -> Field {\n        self * y\n    }\n}\n\nfn wrapping_add_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\nfn wrapping_sub_hlp<T>(x: T, y: T) -> Field\nwhere\n    T: AsPrimitive<Field>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    x.as_() + 340282366920938463463374607431768211456 - y.as_()\n}\n\nfn wrapping_mul_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\nglobal two_pow_64: u128 = 0x10000000000000000;\n/// Splits a 128 bits number into two 64 bits limbs\nunconstrained fn split64(x: u128) -> (u64, u64) {\n    let lo = x as u64;\n    let hi = (x / two_pow_64) as u64;\n    (lo, hi)\n}\n\n/// Split a 128 bits number into two 64 bits limbs\n/// It will fail if the number is more than 128 bits\nfn split_into_64_bit_limbs(x: u128) -> (u64, u64) {\n    // Safety: the limbs are constrained below\n    let (x_lo, x_hi) = unsafe { split64(x) };\n    assert(x as Field == x_lo as Field + x_hi as Field * two_pow_64 as Field);\n    (x_lo, x_hi)\n}\n\n#[field(bn254)]\nfn wrapping_mul128_hlp(x: u128, y: u128) -> u128 {\n    let (x_lo, x_hi) = split_into_64_bit_limbs(x);\n    let (y_lo, y_hi) = split_into_64_bit_limbs(y);\n    // Multiplication using the limbs:(x_lo + 2**64*x_hi)*(y_lo + 2**64*y_hi)=x_lo*y_lo+...\n    // and skipping the terms over 2**128\n    // Working with u64 limbs ensures that we cannot overflow the field modulus.\n    let low = x_lo as Field * y_lo as Field;\n    let lo = low as u64 as Field;\n    let carry = (low - lo) / two_pow_64 as Field;\n    let high = x_lo as Field * y_hi as Field + x_hi as Field * y_lo as Field + carry;\n    let hi = high as u64 as Field;\n    (lo + two_pow_64 as Field * hi) as u128\n}\n"
    },
    "398": {
      "path": "/home/g/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "401": {
      "path": "/home/g/nargo/github.com/noir-lang/noir-bignum/v0.7.5/src/bignum.nr",
      "source": "use crate::fns::constrained_ops::limbs_to_field;\nuse crate::params::BigNumParams;\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub trait BigNum: Neg + Add + Sub + Mul + Div + Eq {\n    let N: u32;\n    let MOD_BITS: u32;\n\n    fn params() -> BigNumParams<N, MOD_BITS>;\n    fn modulus_bits(_: Self) -> u32;\n    fn num_limbs(_: Self) -> u32;\n    fn modulus() -> Self;\n\n    fn new() -> Self;\n    fn zero() -> Self;\n    fn one() -> Self;\n    fn from_limbs(limbs: [u128; N]) -> Self;\n    fn get_limbs(self) -> [u128; N];\n    fn set_limb(self: &mut Self, idx: u32, value: u128);\n    fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    fn from_be_bytes(x: [u8; (MOD_BITS + 7) / 8]) -> Self;\n    fn to_be_bytes(self) -> [u8; (MOD_BITS + 7) / 8];\n    fn from_le_bytes(x: [u8; (MOD_BITS + 7) / 8]) -> Self;\n    fn to_le_bytes(self) -> [u8; (MOD_BITS + 7) / 8];\n\n    fn get_limb(self: Self, idx: u32) -> u128 {\n        self.get_limbs()[idx]\n    }\n\n    unconstrained fn __eq(self: Self, other: Self) -> bool;\n\n    unconstrained fn __is_zero(self: Self) -> bool;\n\n    unconstrained fn __neg(self) -> Self;\n    unconstrained fn __add(self, other: Self) -> Self;\n    unconstrained fn __sub(self, other: Self) -> Self;\n    unconstrained fn __mul(self, other: Self) -> Self;\n    unconstrained fn __div(self, other: Self) -> Self;\n    unconstrained fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    unconstrained fn __invmod(self) -> Self;\n    unconstrained fn __pow(self, exponent: Self) -> Self;\n\n    unconstrained fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    fn assert_is_not_equal(self: Self, other: Self);\n\n    fn validate_in_range(self);\n    fn validate_in_field(self);\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self);\n    fn udiv(self, divisor: Self) -> Self;\n    fn umod(self, divisor: Self) -> Self;\n\n    fn is_zero(self) -> bool;\n}\n\n// we need macros that implement the BigNum, Default, From, Neg, Add, Sub, Mul, Div, Eq, Ord traits for each bignum type\npub comptime fn derive_bignum(\n    strukt: TypeDefinition,\n    N: u32,\n    MOD_BITS: u32,\n    params: Quoted,\n) -> Quoted {\n    let constrained_ops = quote { $crate::fns::constrained_ops };\n    let unconstrained_ops = quote { $crate::fns::unconstrained_ops };\n    let typ = strukt.as_type();\n    let serialization = quote { $crate::fns::serialization };\n    quote {\n\n        // implement BigNum for BigNum \n        impl $crate::BigNum for $typ {\n            let N: u32 = $N; \n            let MOD_BITS: u32 = $MOD_BITS;\n            \n            fn modulus_bits(_: Self) -> u32 {\n                $MOD_BITS\n            }\n            \n            fn num_limbs(_: Self) -> u32 {\n                $N\n            }\n\n            fn modulus() -> Self {\n                Self { limbs: Self::params().modulus }\n            }\n\n            fn new() -> Self {\n                Self {limbs: [0; $N]}\n            }\n\n            fn params() -> $crate::params::BigNumParams<$N, $MOD_BITS> {\n                $params\n            }\n\n            fn from_limbs(limbs: [u128; $N]) -> Self {\n                Self { limbs }\n            }\n\n            fn get_limbs(self: Self) -> [u128; $N] {\n                self.limbs\n            }\n\n            fn set_limb(self: &mut Self, idx: u32, value: u128) {\n                self.limbs[idx] = value;\n            }\n\n            fn zero() -> Self {\n                Self { limbs: [0; $N] }\n            }\n\n            fn one() -> Self {\n                let mut limbs = [0; $N];\n                limbs[0] = 1;\n                Self { limbs }\n            }\n\n            fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n                let params = Self::params();\n                $typ::from_limbs($constrained_ops::derive_from_seed::<_, $MOD_BITS, _>(params, seed))\n            }\n\n            unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n                let params = Self::params();\n                Self { limbs: $unconstrained_ops::__derive_from_seed::<_, $MOD_BITS, _>(params, seed) }\n            }\n\n            fn from_be_bytes(x: [u8; ($MOD_BITS + 7) / 8]) -> Self {\n                Self { limbs: $serialization::from_be_bytes::<_, $MOD_BITS>(x) }\n            }\n            \n            fn to_be_bytes(self) -> [u8; ($MOD_BITS + 7) / 8] {\n                $serialization::to_be_bytes::<_, $MOD_BITS>(self.limbs)\n            }\n\n            fn from_le_bytes(x: [u8; ($MOD_BITS + 7) / 8]) -> Self {\n                Self { limbs: $serialization::from_le_bytes::<_, $MOD_BITS>(x) }\n            }\n\n            fn to_le_bytes(self) -> [u8; ($MOD_BITS + 7) / 8] {\n                $serialization::to_le_bytes::<_, $MOD_BITS>(self.limbs)\n            }\n\n            unconstrained fn __eq(self: Self, other: Self) -> bool {\n                $crate::fns::unconstrained_ops::__eq(self.get_limbs(), other.get_limbs())\n            }\n\n            unconstrained fn __is_zero(self: Self) -> bool {\n                $crate::fns::unconstrained_ops::__is_zero(self.get_limbs())\n            }\n\n            unconstrained fn __neg(self: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__neg(params.modulus, self.get_limbs())}\n            }\n\n            unconstrained fn __add(self: Self, other: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__add(params.modulus, self.get_limbs(), other.get_limbs())}\n            }\n\n            unconstrained fn __sub(self: Self, other: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__sub(params.modulus, self.get_limbs(), other.get_limbs())}\n            }\n\n            unconstrained fn __mul(self: Self, other: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__mul(params, self.get_limbs(), other.get_limbs())}\n            }\n\n            unconstrained fn __div(self: Self, divisor: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__div(params, self.get_limbs(), divisor.get_limbs())}\n            }\n\n            unconstrained fn __udiv_mod(self: Self, divisor: Self) -> (Self, Self) {\n                let (q, r) = $unconstrained_ops::__udiv_mod(self.get_limbs(), divisor.get_limbs());\n                (Self{limbs: q}, Self{limbs: r})\n            }\n\n            unconstrained fn __invmod(self: Self) -> Self {\n                let params = Self::params();\n                assert(params.has_multiplicative_inverse);\n                Self {limbs: $unconstrained_ops::__invmod(params, self.get_limbs())}\n            }\n\n            unconstrained fn __pow(self: Self, exponent: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__pow(params, self.get_limbs(), exponent.get_limbs())}\n            }\n\n            unconstrained fn __tonelli_shanks_sqrt(self: Self) -> std::option::Option<Self> {\n                let params = Self::params();\n                let maybe_limbs = $unconstrained_ops::__tonelli_shanks_sqrt(params, self.get_limbs());\n                maybe_limbs.map(|limbs| Self {limbs: limbs})\n            }\n\n\n            fn assert_is_not_equal(self: Self, other: Self) {\n                let params = Self::params();\n                $crate::fns::constrained_ops::assert_is_not_equal(\n                    params,\n                    self.get_limbs(),\n                    other.get_limbs(),\n                );\n            }\n\n            fn validate_in_field(self: Self) {\n                let params = Self::params();\n                $constrained_ops::validate_in_field::<_, $MOD_BITS>(params, self.get_limbs());\n            }\n\n            fn validate_in_range(self: Self) {\n                $constrained_ops::validate_in_range::<_, _, $MOD_BITS>(self.get_limbs());\n            }\n\n            fn udiv_mod(self: Self, divisor: Self) -> (Self, Self) {\n                let params = Self::params();\n                let (q, r) = $constrained_ops::udiv_mod::<_, $MOD_BITS>(params, self.get_limbs(), divisor.get_limbs());\n                (Self {limbs: q}, Self {limbs: r})\n            }\n\n            fn udiv(self: Self, divisor: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $constrained_ops::udiv::<_, $MOD_BITS>(params, self.get_limbs(), divisor.get_limbs())}\n            }\n\n            fn umod(self: Self, divisor: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $constrained_ops::umod::<_, $MOD_BITS>(params, self.get_limbs(), divisor.get_limbs())}\n            }\n\n            fn is_zero(self: Self) -> bool {\n                $constrained_ops::is_zero::<_, $MOD_BITS>(self.get_limbs())\n            }\n        }\n\n        // implement Default for BigNum\n        impl Default for $typ {\n            fn default() -> Self {\n                $typ::from_limbs([0; $N])\n            }\n        }\n\n        impl std::convert::From<Field> for $typ {\n            fn from(input: Field) -> Self {\n                $typ { limbs: $constrained_ops::from_field::<$N, $MOD_BITS>($params, input) }\n            }\n        }\n\n        impl std::ops::Neg for $typ {\n            fn neg(self) -> Self {\n                $typ { limbs: $constrained_ops::neg::<$N, $MOD_BITS>($params, self.limbs) }\n            }\n        }\n\n        impl std::ops::Add for $typ {\n            fn add(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::add::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::ops::Sub for $typ {\n            fn sub(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::sub::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::ops::Mul for $typ {\n            fn mul(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::mul::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::ops::Div for $typ {\n            fn div(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::div::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::cmp::Eq for $typ {\n            fn eq(self, other: Self) -> bool {\n                $constrained_ops::eq::<$N, $MOD_BITS>($params, self.limbs, other.limbs)\n            }\n        }\n\n        impl std::cmp::Ord for $typ {\n            fn cmp(self, other: Self) -> std::cmp::Ordering {\n                $constrained_ops::cmp::<$N, $MOD_BITS>(self.limbs, other.limbs)\n            }\n        }\n\n    }\n}\n\npub fn conditional_select<T: BigNum>(lhs: T, rhs: T, predicate: bool) -> T {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub unconstrained fn compute_quadratic_expression<T: BigNum, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    lhs_terms: [[T; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[T; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [T; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> (T, T) {\n    let params = T::params();\n    let (q_limbs, r_limbs) = crate::fns::expressions::compute_quadratic_expression(\n        params,\n        crate::utils::map::map(\n            lhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        lhs_flags,\n        crate::utils::map::map(\n            rhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        rhs_flags,\n        crate::utils::map::map(linear_terms, |bn: T| bn.get_limbs()),\n        linear_flags,\n    );\n    (T::from_limbs(q_limbs), T::from_limbs(r_limbs))\n}\n\npub fn evaluate_quadratic_expression<T: BigNum, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    lhs_terms: [[T; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[T; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [T; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    let params = T::params();\n    crate::fns::expressions::evaluate_quadratic_expression(\n        params,\n        crate::utils::map::map(\n            lhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        lhs_flags,\n        crate::utils::map::map(\n            rhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        rhs_flags,\n        crate::utils::map::map(linear_terms, |bn: T| bn.get_limbs()),\n        linear_flags,\n    )\n}\n\npub unconstrained fn batch_invert<T: BigNum, let M: u32>(x: [T; M]) -> [T; M] {\n    let params = T::params();\n    assert(params.has_multiplicative_inverse);\n    crate::fns::unconstrained_ops::batch_invert(params, x.map(|bn: T| bn.get_limbs())).map(|limbs| {\n        T::from_limbs(limbs)\n    })\n}\n\npub unconstrained fn batch_invert_slice<T: BigNum>(x: [T]) -> [T] {\n    let params = T::params();\n    assert(params.has_multiplicative_inverse);\n    crate::fns::unconstrained_ops::batch_invert_slice(params, x.map(|bn: T| bn.get_limbs()))\n        .map(|limbs| T::from_limbs(limbs))\n}\n\npub fn to_field<T: BigNum>(bn: T) -> Field {\n    let params = T::params();\n    limbs_to_field(params, bn.get_limbs())\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "433": {
      "path": "/home/g/nargo/github.com/noir-lang/noir-bignum/v0.7.5/src/fns/constrained_ops.nr",
      "source": "use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\nuse std::cmp::Ordering;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n * gt \n * check_gt_with_flags\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n        let mut grumpkin_modulus = [0; N];\n        if N > 2 {\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n        }\n        if MOD_BITS > 253 {\n            // this means that the field modulus is larger than grumpkin modulus so we have to check if the element fields in the field size are less than the grumpkin modulus.\n            // also for correct params N is always larger than 3 here\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n        } else if MOD_BITS < 253 {\n            // this means that the field modulus is smaller than grumpkin modulus so we have to check if the element fields in the field size\n            validate_in_field(_params, result);\n        } else {\n            // this is the tricky part, when MOD_BITS = 253, so we have to compare the limbs of the modulus to the grumpkin modulus limbs\n            // any bignum with 253 bits will have 3 limbs\n\n            // if modulus is larger than grumpkin modulus, this will be true\n            let mut gt_grumpkin = false;\n            for i in 0..3 {\n                if !gt_grumpkin {\n                    if _params.modulus[2 - i] < grumpkin_modulus[2 - i] {\n                        gt_grumpkin = true;\n                    }\n                }\n            }\n            let result_2 = if gt_grumpkin {\n                _params.modulus\n            } else {\n                grumpkin_modulus\n            };\n            validate_gt::<N, MOD_BITS>(result_2, result);\n        }\n\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        poseidon::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        if num_bytes >= num_filled_bytes {\n            let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n            let mut num_remaining_limbs =\n                (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n            let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n            let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n                + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n            for j in 0..num_limbs_in_bigfield {\n                let mut limb: u128 = 0;\n                for _ in 0..15 {\n                    let need_more_bytes = (byte_ptr < num_bytes);\n                    let mut byte = hash_buffer[byte_ptr];\n                    limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                    limb += byte as u128 * need_more_bytes as u128;\n                    byte_ptr += need_more_bytes as u32;\n                }\n                bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n            }\n            bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n        }\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n    assert(!underflow, \"BigNum::validate_gt check fails\");\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params.modulus, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params.modulus, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params.modulus, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n// a comparison function. returns true if lhs > rhs and false otherwise\npub(crate) fn cmp<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) -> Ordering {\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    // if underflow is true, swap lhs and rhs\n    let (lhs, rhs) = if underflow { (rhs, lhs) } else { (lhs, rhs) };\n\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n    if lhs == rhs {\n        Ordering::equal()\n    } else if underflow {\n        Ordering::less()\n    } else {\n        Ordering::greater()\n    }\n}\n\n// the constraining function for the results returned by __validate_gt_remainder. this is used in both comparisons and validate gt\npub(crate) fn check_gt_with_flags<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    result: [u128; N],\n    borrow_flags: [bool; N],\n    carry_flags: [bool; N],\n) {\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i] as Field\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1] as Field\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n"
    },
    "434": {
      "path": "/home/g/nargo/github.com/noir-lang/noir-bignum/v0.7.5/src/fns/expressions.nr",
      "source": "use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\n\nunconstrained fn compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N], [Field; 2 * N - 2]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n    assert(remainder == [0; N]);\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] as Field * params.modulus[j] as Field;\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N - 2] = [0; 2 * N - 2];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n    let downshift: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits =\n        (mulout_p[0] - mulout_n[0] + (borrow_flags[0] as Field * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [u128; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field - x[i][j] as Field) as u128;\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [u128; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] as Field * rhs[k][j] as Field);\n            }\n        }\n        mulout[i] += add[i] as Field;\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout: [Field; (N * 2)] = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, k, params.modulus);\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([u128; N], [u128; N], [Field; 2 * N - 2]) = unsafe {\n        compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [u128; N] = params.double_modulus;\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i] as Field;\n                    t0[k][i] += double_modulus[i] as Field;\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i] as Field;\n                    t1[k][i] += double_modulus[i] as Field;\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i] as Field;\n                t4[i] += double_modulus[i] as Field;\n            } else {\n                t4[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term =\n                        t0[k][i] * t1[k][j] - quotient[i] as Field * params.modulus[j] as Field;\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j] as Field;\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] as Field * params.modulus[j] as Field;\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] as Field * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n"
    },
    "437": {
      "path": "/home/g/nargo/github.com/noir-lang/noir-bignum/v0.7.5/src/fns/unconstrained_helpers.nr",
      "source": "use crate::constants::{TWO_POW_119, TWO_POW_120};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> (bool, [u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n\n    let mut result: [u128; N] = [0; N];\n    // swap a and b if there's an underflow\n    let (a, b) = if underflow { (b, a) } else { (a, b) };\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (underflow, result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32>(\n    modulus: [u128; N],\n    val: [u128; N],\n) -> ([u128; N], [bool; N - 1]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        if (i < N - 1) {\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params.modulus, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params.modulus, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift = (120 - limb_shift) as u8;\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> limb_shift);\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift: u8 = 120 - limb_shift as u8;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[(N - 1 - i)];\n        if (v > 0) {\n            count = 120 * (N - 1 - i) + get_msb(v);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = bit % 120;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index as u8) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n"
    },
    "438": {
      "path": "/home/g/nargo/github.com/noir-lang/noir-bignum/v0.7.5/src/fns/unconstrained_ops.nr",
      "source": "use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32>(modulus: [u128; N], limbs: [u128; N]) -> [u128; N] {\n    __helper_sub(modulus, limbs)\n}\n\npub(crate) unconstrained fn __add<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, modulus) {\n        __helper_sub(result, modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(modulus, lhs, __neg(modulus, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n"
    },
    "447": {
      "path": "/home/g/nargo/github.com/noir-lang/noir-bignum/v0.7.5/src/utils/msb.nr",
      "source": "use std::ops::WrappingMul;\n\nglobal MUL_DE_BRUIJN_BIT: [u32; 128] = [\n    1, 14, 2, 15, 26, 20, 3, 16, 68, 80, 27, 21, 56, 50, 4, 17, 65, 96, 69, 81, 105, 99, 28, 22, 86,\n    90, 57, 51, 72, 42, 5, 126, 18, 66, 48, 94, 97, 84, 70, 124, 82, 122, 106, 100, 114, 108, 29,\n    23, 77, 102, 87, 91, 119, 116, 58, 52, 61, 110, 73, 37, 43, 31, 6, 127, 13, 25, 19, 67, 79, 55,\n    49, 64, 95, 104, 98, 85, 89, 71, 41, 125, 47, 93, 83, 123, 121, 113, 107, 76, 101, 118, 115, 60,\n    109, 36, 30, 12, 24, 78, 54, 63, 103, 88, 40, 46, 92, 120, 112, 75, 117, 59, 35, 11, 53, 62, 39,\n    45, 111, 74, 34, 10, 38, 44, 33, 9, 32, 8, 7, 128,\n];\n\npub(crate) unconstrained fn get_msb(x: u128) -> u32 {\n    let result = if x == 0 {\n        0\n    } else {\n        let mut v = x;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v |= v >> 32;\n        v |= v >> 64;\n        let index = (v.wrapping_mul(0x1FC10C2FBCF471B913B14CD2595D6D5)) >> 121;\n        (index as Field).assert_max_bit_size::<32>();\n        MUL_DE_BRUIJN_BIT[index as u32]\n    };\n    result\n}\n\nmod tests {\n    use crate::constants::{TWO_POW_120, TWO_POW_60};\n    use crate::fns::unconstrained_helpers::__get_msb;\n    use super::get_msb as get_msb128;\n    use std::ops::WrappingMul;\n\n    fn assert_msb_equal(x: u64) {\n        let msb64 = unsafe { get_msb64(x) };\n        let msb128 = unsafe { get_msb128(x as u128) };\n        assert_eq(msb64, msb128);\n    }\n\n    #[test]\n    // To check that the msb functions are equivalent with de bruijn sequence for 64 bits and 128 bits\n    fn test_get_msb() {\n        // Test case 1: MSB at position 7\n        let x = 0x80; // binary: 10000000\n        assert_msb_equal(x);\n\n        // Test case 2: MSB at position 0\n        let x = 0x1; // binary: 00000001\n        assert_msb_equal(x);\n\n        // Test case 3: MSB at position 63\n        let x = 0x8000000000000000; // binary: 1000...0000 (63 zeros)\n        assert_msb_equal(x);\n\n        // Test case 4: Zero input\n        let x = 0x0;\n        assert_msb_equal(x);\n\n        // Test case 5: All bits set\n        let x = 0xFFFFFFFFFFFFFFFF;\n        assert_msb_equal(x);\n    }\n\n    /// Multiple entires in the `MUL_DE_BRUIJN_BIT` list do not map to a valid output of `v * 0x6c04f118e9966f6b`.\n    /// This is a dummy value to fill the gaps in the map.\n    global n1: u32 = 0xffffffff;\n\n    global MUL_DE_BRUIJN_BIT_64: [u32; 128] = [\n        0, // change to 1 if you want bitSize(0) = 1\n        48, n1, n1, 31, n1, 15, 51, n1, 63, 5, n1, n1, n1, 19, n1, 23, 28, n1, n1, n1, 40, 36, 46,\n        n1, 13, n1, n1, n1, 34, n1, 58, n1, 60, 2, 43, 55, n1, n1, n1, 50, 62, 4, n1, 18, 27, n1,\n        39, 45, n1, n1, 33, 57, n1, 1, 54, n1, 49, n1, 17, n1, n1, 32, n1, 53, n1, 16, n1, n1, 52,\n        n1, n1, n1, 64, 6, 7, 8, n1, 9, n1, n1, n1, 20, 10, n1, n1, 24, n1, 29, n1, n1, 21, n1, 11,\n        n1, n1, 41, n1, 25, 37, n1, 47, n1, 30, 14, n1, n1, n1, n1, 22, n1, n1, 35, 12, n1, n1, n1,\n        59, 42, n1, n1, 61, 3, 26, 38, 44, n1, 56,\n    ];\n\n    pub(crate) unconstrained fn get_msb64(x: u64) -> u32 {\n        let mut v = x;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v |= v >> 32;\n        let index = (v.wrapping_mul(0x6c04f118e9966f6b)) >> 57;\n        (index as Field).assert_max_bit_size::<32>();\n        MUL_DE_BRUIJN_BIT_64[index as u32]\n    }\n\n    unconstrained fn __get_msb64<let N: u32>(val: [u128; N]) -> u32 {\n        let mut count = 0;\n        for i in 0..N {\n            let v = val[((N) - 1 - i)];\n            let v_low = v as u64 % TWO_POW_60 as u64;\n            let v_high = ((v - v_low as u128) / TWO_POW_60) as u64;\n            if (v_high > 0) {\n                count = 60 * ((2 * N) - 1 - (i * 2)) + get_msb64(v_high);\n                break;\n            }\n            if (v_low > 0) {\n                count = 60 * ((2 * N) - 1 - (i * 2 + 1)) + get_msb64(v_low);\n                break;\n            }\n        }\n        count\n    }\n\n    #[test]\n    // To check that the msb functions are equivalent with de bruijn sequence for 64 bits and 128 bits\n    unconstrained fn test_get_msb_equivalence() {\n        // Test single limb (64-bit number)\n        let x = 0x8000000000000000;\n        let arr = [0, 0, x as u128, 0];\n        let msb1 = __get_msb64(arr);\n        let msb2 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test multiple limbs (120-bit number)\n        let x = 0x800000000000000000000000000000; // 120 bits number\n        let arr = [0, 0, x as u128, 0];\n        let msb1 = __get_msb64(arr);\n        let msb2 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test zero\n        let arr = [0, 0, 0, 0];\n        let msb1 = __get_msb64(arr);\n        let msb2 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test all bits set (120 bits)\n        let x = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // 120 bits\n        let arr = [0, x as u128, 0, 0];\n        let msb1 = __get_msb64(arr);\n        let msb2 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test systematic bit positions\n        for i in 0..120 {\n            let x: u128 = 1;\n            let shifted = x << i;\n            let arr = [0, shifted, 0, 0];\n            let msb1 = __get_msb64(arr);\n            let msb2 = __get_msb(arr);\n            assert_eq(msb1, msb2);\n        }\n\n        // Test random-like patterns (multiple bits set)\n        let patterns = [\n            0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, // alternating bits\n            0x555555555555555555555555555555, // alternating bits (opposite)\n            0x1234567890ABCDEF1234567890ABCD, // some pattern\n            0xFEDCBA0987654321FEDCBA09876543, // some pattern\n            0x800000000000000000000000000001, // highest and lowest bits\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE, // all bits except lowest\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFF, // all bits except highest\n        ];\n        for i in 0..patterns.len() {\n            let arr = [0, patterns[i] as u128, 0, 0];\n            let msb1 = __get_msb64(arr);\n            let msb2 = __get_msb(arr);\n            assert_eq(msb1, msb2);\n        }\n\n        // Test with MSB in different array positions (120 bits)\n        let x = 0x800000000000000000000000000000; // 120 bits\n        let arr1 = [x as u128, 0, 0, 0];\n        let arr2 = [0, x as u128, 0, 0];\n        let arr3 = [0, 0, x as u128, 0];\n        let arr4 = [0, 0, 0, x as u128];\n        let msb1_1 = __get_msb64(arr1);\n        let msb2_1 = __get_msb(arr1);\n        assert_eq(msb1_1, msb2_1);\n\n        let msb1_2 = __get_msb64(arr2);\n        let msb2_2 = __get_msb(arr2);\n        assert_eq(msb1_2, msb2_2);\n\n        let msb1_3 = __get_msb64(arr3);\n        let msb2_3 = __get_msb(arr3);\n        assert_eq(msb1_3, msb2_3);\n\n        let msb1_4 = __get_msb64(arr4);\n        let msb2_4 = __get_msb(arr4);\n        assert_eq(msb1_4, msb2_4);\n    }\n\n    #[test]\n    unconstrained fn fuzz_get_msb(seed: [u128; 5]) {\n        let mut seed_copy = seed;\n        for i in 0..5 {\n            seed_copy[i] = seed_copy[i] & (TWO_POW_120 - 1);\n        }\n        let msb1 = __get_msb64(seed_copy);\n        let msb2 = __get_msb(seed_copy);\n        assert_eq(msb1, msb2);\n    }\n}\n"
    },
    "448": {
      "path": "/home/g/nargo/github.com/noir-lang/noir-bignum/v0.7.5/src/utils/split_bits.nr",
      "source": "use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n"
    },
    "453": {
      "path": "/home/g/Documents/Projects/Cloak/fzuk/packages/factory/src/fullMath.nr",
      "source": "use dep::bignum::{BigNum, bignum::to_field, U256};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\nglobal MAX_U8: u8 = 255 as u8;\nglobal MAX_U16: u16 = 65535 as u16;\nglobal MAX_U32: u32 = 4294967295 as u32;\nglobal MAX_U64: u64 = 18446744073709551615 as u64;\nglobal MAX_U128: u128 = 340282366920938463463374607431768211455 as u128;\nglobal MAX_U160: Field = 1461501637330902918203684832716283019655932542975;\nglobal MAX_FIELD: Field =\n    21888242871839275222246405745257275088548364400416034343698204186575808495616;\nglobal MAX_U256: U256 = U256::from_limbs([\n    1329227995784915872903807060280344575 as u128, // 2^120 - 1\n    1329227995784915872903807060280344575 as u128, // 2^120 - 1\n    65535 as u128, // 2^16 - 1\n]);\n\n// @notice Calculates floor(a*b/denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n// @param a The multiplicand\n// @param b The multiplier\n// @param denominator The divisor\n// @return result The 256-bit result\n// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\nfn mulDiv(a: Field, b: Field, denominator: Field) -> Field {\n    // 512-bit multiply [prod1 prod0] = a * b\n    // Compute the product mod 2**256 and mod 2**256 - 1\n    // then use the Chinese Remainder Theorem to reconstruct\n    // the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2**256 + prod0\n\n\n    let mut result = 0;\n    let mut ltResult = U256::from(0);\n    //  The variables prod0 and prod1 represent the least and most significant 256 bits of a 512-bit product\n    let mut prod0 = U256::from(0); // Least significant 256 bits of the product\n    let mut prod1 = U256::from(0); // Most significant 256 bits of the product\n\n    let mm = U256::from(mulmod(a, b, MAX_FIELD)); // let mm := mulmod(a, b, not(0))\n\n    prod0 = U256::from(a).mul(U256::from(b)); // prod0 := mul(a, b)\n    let mut subResult = mm.sub(prod0); // sub(mm, prod0)\n    if (mm < prod0) {\n        ltResult = U256::from(1);\n    } else {\n        ltResult = U256::from(0);\n    }\n\n    if (subResult <= ltResult) {\n        prod1 = U256::from(0);\n    } else {\n        prod1 = subResult.sub(ltResult);\n    }\n\n    // Handle non-overflow cases, 256 by 256 division\n    if (prod1 == U256::from(0)) {\n        assert((0).lt(denominator), \"bad denominator\");\n        result = to_field(prod0.udiv(U256::from(denominator)));\n        result\n    } else {\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        assert( 0 !=denominator, \"bad denominator\");\n        assert(U256::from(denominator) > prod1);\n\n        ////////////////////////////////\n        // 512 by 256 division.\n        ////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        let mut remainder = U256::from(0);\n        remainder = U256::from(mulmod(a, b, denominator));\n\n        // Subtract 256 bit number from 512 bit number\n        if (to_field(remainder) as u128 > to_field(prod0) as u128) {\n            ltResult = U256::from(1);\n        } else {\n            ltResult = U256::from(0);\n        }\n        prod1 = prod1 - ltResult;\n        prod0 = prod0 - remainder;\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n\n        let mut twos = U256::from(unsafe { largest_power_of_two_divisor(denominator) });\n        let mut newDenominator = U256::from(0);\n        newDenominator = (U256::from(denominator).udiv(twos)); //  denominator := div(denominator, twos)\n\n        // Divide [prod1 prod0] by the factors of two\n        prod0 = prod0.udiv(twos); //  prod0 := div(prod0, twos)\n\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n\n        let neg_twos = 0 - to_field(twos); //  twos := add(div(sub(0, twos), twos), 1)\n        let quotient = neg_twos / to_field(twos);\n        let twos = U256::from(quotient + 1);\n\n        let mut tempProd0 = 0;\n        tempProd0 |= (to_field(prod1) * to_field(twos)) as u128;\n\n        prod0 = U256::from(tempProd0 as Field);\n\n        // Invert newDenominator mod 2**256\n        // Now that newDenominator is an odd number, it has an inverse\n        // modulo 2**256 such that newDenominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, newDenominator * inv = 1 mod 2**4\n        let mut inv = U256::from((3 * denominator).pow_32(2));\n\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n\n        assert(to_field(newDenominator) == 3);\n        inv = inv * (U256::from(2) - (newDenominator) * inv); // inverse mod 2**8\n        inv = inv * (U256::from(2) - (newDenominator) * inv); // inverse mod 2**16\n        inv = inv * (U256::from(2) - (newDenominator) * inv); // inverse mod 2**32\n        inv = inv * (U256::from(2) - (newDenominator) * inv); // inverse mod 2**64\n        inv = inv * (U256::from(2) - (newDenominator) * inv); // inverse mod 2**128\n        inv = inv * (U256::from(2) - (newDenominator) * inv); // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of newDenominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = to_field(prod0) * to_field(inv);\n\n        result\n    }\n}\n\n// @notice Calculates ceil(a*b/denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n// @param a The multiplicand\n// @param b The multiplier\n// @param denominator The divisor\n// @return result The 256-bit result\n//  (x * y) % k\nfn mulDivRoundingUp(\n    a: Field, //uint256\n    b: Field, //uint256\n    denominator: Field, //uint256\n) -> Field {\n    let mut result = mulDiv(a, b, denominator);\n    if ((mulmod(a, b, denominator)) as u128 > 0 as u128) {\n        assert((result) as u128 < (MAX_FIELD) as u128);\n        result = result + 1;\n    }\n\n    result\n}\n\nfn mulmod(\n    a: Field, //uint256\n    b: Field, //uint256\n    denominator: Field, //uint256\n) -> Field {\n    assert(denominator != 0, \"Denom must be > 0\");\n    let product = U256::from(a * b);\n    let quotient = product.udiv(U256::from(denominator));\n    let result: U256 = unsafe { product.__sub((quotient.__mul(U256::from(denominator)))) };\n    to_field(result)\n}\n\n// Function to compute the largest power of two divisor of a number using a for loop\nunconstrained fn largest_power_of_two_divisor(n: Field) -> Field {\n    // Ensure n is not zero to avoid division by zero\n    assert(n != 0, \"Input must be non-zero\");\n\n    // Initialize the result to 1\n    let mut result = 1;\n\n    // Initialize a temporary variable to hold the current value of n\n    let mut temp = n;\n\n    // Loop to divide temp by 2 until it's no longer even\n    for _ in 0..256 {\n        if temp as u128 % 2 as u128 == 0 as u128 {\n            result = result * 2;\n            temp = temp / 2;\n        } else {\n            break;\n        }\n    }\n\n    // Return the largest power of two divisor\n    result\n}\n"
    },
    "454": {
      "path": "/home/g/Documents/Projects/Cloak/fzuk/packages/factory/src/helpers.nr",
      "source": "use dep::bignum::{BigNum, bignum::to_field, U256};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub fn sqrt(value: u128) -> u128 {\n    let ONE = (1) as u128;\n    let TWO = (2) as u128;\n    let mut z = value;\n    let mut x = value / TWO + ONE;\n    // 68 iterations of needed for number `2 ** 127`. Couldn't make `2 ** 128` work.\n    for _ in 0..69 {\n        if x < z {\n            z = x;\n            x = (value / x + x) / TWO;\n        }\n    }\n    z\n}\n\n// Function to calculate the minimum of two values\npub fn min(a: Field, b: Field) -> Field {\n    if (a) as u128 < (b) as u128 {\n        a\n    } else {\n        b\n    }\n}\n\n// Function to calculate the maximum of two values\npub fn max(a: Field, b: Field) -> Field {\n    if (a) as u128 > (b) as u128 {\n        a\n    } else {\n        b\n    }\n}\n\npub fn bitwise_and(a: U256, b: U256) -> U256 {\n    let mut result: U256 = U256::from(0);\n    let mut mask: U256 = U256::from(1); // represents 2^i\n\n    // We know we're dealing with up to 256 bits\n    for _ in 0..256 {\n        // Extract the current bit of `a` and `b` by dividing by mask, then mod 2\n        let bit_a: U256 = modulo((a.udiv(mask)), U256::from(2));\n        let bit_b: U256 = modulo((b.udiv(mask)), U256::from(2));\n\n        // AND the bits via multiplication: 1*1=1, otherwise 0\n        let and_bit: U256 = bit_a.mul(bit_b);\n\n        // Accumulate into result by adding and_bit * mask\n        result = result.add(and_bit.mul(mask));\n\n        // Double the mask for the next bit position (mask = mask * 2)\n        mask = mask.add(mask);\n    }\n\n    result\n}\n\npub fn bitwise_and_optimized(a: U256, b: U256) -> U256 {\n    let mut result: U256 = U256::from(0);\n    let mut mask: U256 = U256::from(1); // 2^i, grows by doubling\n    let mut a_temp: U256 = a; // will be shifted right each loop\n    let mut b_temp: U256 = b;\n\n    // Process exactly 256 bits\n    for _ in 0..256 {\n        // Extract least significant bits\n        let bit_a = modulo(a_temp, U256::from(2)); // cheaper LSB test than division by mask :}\n        let bit_b = modulo(b_temp, U256::from(2));\n\n        // If both LSBs are 1, add current mask\n        if (bit_a == U256::from(1)) & (bit_b == U256::from(1)) {\n            result = result + mask; // single add instead of multiply :contentReference[oaicite:5]{index=5}\n        }\n\n        // Prepare for next higher bit\n        a_temp = a_temp.udiv(U256::from(2)); // right shift by 1\n        b_temp = b_temp.udiv(U256::from(2));\n        mask = mask.add(mask); // left shift mask by 1 :contentReference[oaicite:6]{index=6}\n    }\n\n    result\n}\n\npub fn bitwise_and_optimized_2(a: U256, b: U256) -> U256 {\n    let mut r: U256 = U256::from(0);\n    let mut m: U256 = U256::from(1); // 2^i, grows by doubling\n    let mut x = a;\n    let mut y = b;\n\n    // Process 4 bits per loop -> 8 iterations total\n    for _ in 0..8 {\n        // Bit 0\n        let bit0 = modulo(x, U256::from(2)).mul(modulo(y, U256::from(2)));\n        r += bit0.mul(m);\n        x = x.udiv(U256::from(2));\n        y = y.udiv(U256::from(2));\n        m = m.add(m);\n\n        // Bit 1\n        let bit1 = modulo(x, U256::from(2)).mul(modulo(y, U256::from(2)));\n        r += bit1.mul(m);\n        x = x.udiv(U256::from(2));\n        y = y.udiv(U256::from(2));\n        m = m.add(m);\n\n        // Bit 2\n        let bit2 = modulo(x, U256::from(2)).mul(modulo(y, U256::from(2)));\n        r += bit2.mul(m);\n        x = x.udiv(U256::from(2));\n        y = y.udiv(U256::from(2));\n        m = m.add(m);\n\n        // Bit 3\n        let bit3 = modulo(x, U256::from(2)).mul(modulo(y, U256::from(2)));\n        r += bit3.mul(m);\n        x = x.udiv(U256::from(2));\n        y = y.udiv(U256::from(2));\n        m = m.add(m);\n    }\n\n    r\n}\n\npub fn bitwise_or(a: U256, b: U256) -> U256 {\n    let mut result: U256 = U256::from(0);\n    let mut mask: U256 = U256::from(1);\n\n    for _ in 0..256 {\n        let bit_a: U256 = modulo((a.udiv(mask)), U256::from(2));\n        let bit_b: U256 = modulo((b.udiv(mask)), U256::from(2));\n\n        let or_bit = if to_field(bit_a.add(bit_b)) as u128 > 0 as u128 {\n            U256::from(1)\n        } else {\n            U256::from(0)\n        };\n\n        result = result.add(or_bit.mul(mask));\n        mask = mask.add(mask);\n    }\n\n    result\n}\n\npub fn bitwise_shift_left(a: U256, n: u128) -> U256 {\n    let mut result: U256 = a;\n    for _ in 0 as u128..n {\n        result = result.add(result); // multiply by 2 each iteration\n    }\n    result\n}\n\npub fn bitwise_shift_right(a: U256, n: u128) -> U256 {\n    let mut result: U256 = a;\n    for _ in 0..n {\n        result = result.udiv(U256::from(2)); // integer division by 2\n    }\n    result\n}\n\npub fn modulo(a: U256, b: U256) -> U256 {\n    // Disallow division by zero\n    assert(b != U256::from(0));\n    // Compute quotient (integer division) and remainder\n    let divider = b;\n    let q = a.udiv(divider);\n    let r = a.sub(q.mul(divider));\n    r\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "479": {
      "path": "/home/g/Documents/Projects/Cloak/fzuk/packages/factory/src/tickMath.nr",
      "source": "use crate::fullMath::MAX_U256;\nuse crate::helpers::{\n    bitwise_and_optimized_2, bitwise_or, bitwise_shift_left, bitwise_shift_right, modulo,\n};\nuse crate::helpers::sqrt;\nuse crate::tick::{Q1, Q128, Q16, Q2, Q32, Q4, Q64, Q8};\nuse dep::bignum::{BigNum, bignum::to_field, U256};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\nuse dep::aztec::oracle::debug_log::{ debug_log, debug_log_format };\n\n/// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\nglobal MIN_TICK: i32 = -887272;\n/// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\nglobal MAX_TICK: i32 = -MIN_TICK;\nglobal MAX_TICKS_UINT: U256 = U256::from(50);\nglobal MAX_SKIP_TICKS: i64 = 1024;\n\n/// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\nglobal MIN_SQRT_RATIO: Field = 4295128739;\n/// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\nglobal MAX_SQRT_RATIO: Field = 1461446703485210103287273052203988822378723970342;\n\n/// @notice Calculates sqrt(1.0001^tick) * 2^96\n/// @dev Throws if |tick| > max tick\n/// @param tick The input tick for the above formula\n/// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n/// at the given tick\nfn getSqrtRatioAtTick(tick: i32) -> Field {\n    let mut absTick = 0 as u32;\n    if (tick < 0) {\n        absTick = (-tick) as u32;\n    } else {\n        absTick =tick as u32;\n    }\n\n    assert(absTick  <= (MAX_TICK as u32), \"Tick out of range\");\n\n    let mut ratio: U256 = U256::from(0);\n    if (absTick & (0x1 as u32) != 0 as u32) {\n        ratio = U256::from(0xfffcb933bd6fad37aa2d162d1a594001);\n    } else {\n        ratio = U256::from(0x100000000000000000000000000000000);\n    }\n    if (absTick & (0x2 as u32)!= 0 as u32) {\n        let product = ratio.mul(U256::from(0xfff97272373d413259a46990580e213a));\n        ratio = product.udiv(U256::from(Q128));\n    }\n    if (absTick & (0x4 as u32)!= 0 as u32) {\n        let product = ratio.mul(U256::from(0xfff2e50f5f656932ef12357cf3c7fdcc));\n        ratio = product.udiv(U256::from(Q128));\n    }\n    if (absTick & (0x8 as u32)!= 0 as u32) {\n        let product = ratio.mul(U256::from(0xffe5caca7e10e4e61c3624eaa0941cd0));\n        ratio = product.udiv(U256::from(Q128));\n    }\n    if (absTick & (0x10 as u32)!= 0 as u32) {\n        let product = ratio.mul(U256::from(0xffcb9843d60f6159c9db58835c926644));\n        ratio = product.udiv(U256::from(Q128));\n    }\n    if (absTick & (0x20 as u32)!= 0 as u32) {\n        let product = ratio.mul(U256::from(0xff973b41fa98c081472e6896dfb254c0));\n        ratio = product.udiv(U256::from(Q128));\n    }\n    if (absTick & (0x40 as u32)!= 0 as u32) {\n        let product = ratio.mul(U256::from(0xff2ea16466c96a3843ec78b326b52861));\n        ratio = product.udiv(U256::from(Q128));\n    }\n    if (absTick & (0x80 as u32)!= 0 as u32) {\n        let product = ratio.mul(U256::from(0xfe5dee046a99a2a811c461f1969c3053));\n        ratio = product.udiv(U256::from(Q128));\n    }\n    if (absTick & (0x100 as u32)!= 0 as u32) {\n        let product = ratio.mul(U256::from(0xfcbe86c7900a88aedcffc83b479aa3a4));\n        ratio = product.udiv(U256::from(Q128));\n    }\n    if (absTick & (0x200 as u32)!= 0 as u32) {\n        let product = ratio.mul(U256::from(0xf987a7253ac413176f2b074cf7815e54));\n        ratio = product.udiv(U256::from(Q128));\n    }\n    if (absTick & (0x400 as u32)!= 0 as u32) {\n        let product = ratio.mul(U256::from(0xf3392b0822b70005940c7a398e4b70f3));\n        ratio = product.udiv(U256::from(Q128));\n    }\n    if (absTick & (0x800 as u32)!= 0 as u32) {\n        let product = ratio.mul(U256::from(0xe7159475a2c29b7443b29c7fa6e889d9));\n        ratio = product.udiv(U256::from(Q128));\n    }\n    if (absTick & (0x1000 as u32)!= 0 as u32) {\n        let product = ratio.mul(U256::from(0xd097f3bdfd2022b8845ad8f792aa5825));\n        ratio = product.udiv(U256::from(Q128));\n    }\n    if (absTick & (0x2000 as u32)!= 0 as u32) {\n        let product = ratio.mul(U256::from(0xa9f746462d870fdf8a65dc1f90e061e5));\n        ratio = product.udiv(U256::from(Q128));\n    }\n    if (absTick & (0x4000 as u32)!= 0 as u32) {\n        let product = ratio.mul(U256::from(0x70d869a156d2a1b890bb3df62baf32f7));\n        ratio = product.udiv(U256::from(Q128));\n    }\n    if (absTick & (0x8000 as u32)!= 0 as u32) {\n        let product = ratio.mul(U256::from(0x31be135f97d08fd981231505542fcfa6));\n        ratio = product.udiv(U256::from(Q128));\n    }\n    if (absTick & (0x10000 as u32)!= 0 as u32) {\n        let product = ratio.mul(U256::from(0x9aa508b5b7a84e1c677de54f3e99bc9));\n        ratio = product.udiv(U256::from(Q128));\n    }\n    if (absTick & (0x20000 as u32)!= 0 as u32) {\n        let product = ratio.mul(U256::from(0x5d6af8dedb81196699c329225ee604));\n        ratio = product.udiv(U256::from(Q128));\n    }\n    if (absTick & (0x40000 as u32)!= 0 as u32) {\n        let product = ratio.mul(U256::from(0x2216e584f5fa1ea926041bedfe98));\n        ratio = product.udiv(U256::from(Q128));\n    }\n    if (absTick & (0x80000 as u32)!= 0 as u32) {\n        let product = ratio.mul(U256::from(0x48a170391f7dc42444e8fa2));\n        ratio = product.udiv(U256::from(Q128));\n    }\n    if (tick > 0) {\n        ratio = (MAX_U256).udiv(ratio);\n    }\n\n    // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n    // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n    // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n    let mudResult = modulo(ratio, bitwise_shift_left(U256::from(1), 32 as u128));\n    let mut b = 0;\n    if mudResult == U256::from(0) {\n        b = 0;\n    } else {\n        b = 1;\n    }\n\n    // sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    let mut sqrtPriceX96 = bitwise_shift_right(ratio, 32 as u128) + U256::from(b);\n\n    to_field(sqrtPriceX96)\n}\n\n// Main: convert sqrtPriceX96 (Q64.96) to tick (i32)\nfn getTickAtSqrtRatio(sqrtPriceX96: Field) -> i32 {\n    // Range check (sqrtPriceX96 should be within [MIN_SQRT_RATIO, MAX_SQRT_RATIO))\n    assert(U256::from(sqrtPriceX96) >= U256::from(MIN_SQRT_RATIO), \"R: below minimum\");\n    assert(U256::from(sqrtPriceX96) < U256::from(MAX_SQRT_RATIO), \"R: at or above maximum\");\n\n    // 1) Scale input to Q128.128:\n    let mut ratio = U256::from(sqrtPriceX96).mul(U256::from(Q32 as Field));\n    let mut msb: u32 = 0;\n\n    // 2) Find most significant bit (msb) of 'ratio'\n    let mut r = ratio;\n    // Check descending powers of two (128, 64, 32, 16, 8, 4, 2, 1)\n    // 2) Find most significant bit (msb) of 'ratio'\n    let mut r = ratio;\n\n    if r > U256::from((Q128) as Field) - U256::from(1) {\n        r = r.udiv(U256::from(Q128 as Field));\n        msb |= 128;\n    }\n    if r > U256::from((Q64) as Field) - U256::from(1) {\n        r = r.udiv(U256::from(Q64 as Field));\n        msb |= 64;\n    }\n    if r > U256::from((Q32) as Field) - U256::from(1) {\n        r = r.udiv(U256::from(Q32 as Field));\n        msb |= 32;\n    }\n    if r > U256::from((Q16) as Field) - U256::from(1) {\n        r = r.udiv(U256::from(Q16 as Field));\n        msb |= 16;\n    }\n    if r > U256::from((Q8) as Field) - U256::from(1) {\n        r = r.udiv(U256::from(Q8 as Field));\n        msb |= 8;\n    }\n    if r > U256::from((Q4) as Field) - U256::from(1) {\n        r = r.udiv(U256::from(Q4 as Field));\n        msb |= 4;\n    }\n    if r > U256::from((Q2) as Field) - U256::from(1) {\n        r = r.udiv(U256::from(Q2 as Field));\n        msb |= 2;\n    }\n    if r > U256::from((Q1) as Field) - U256::from(1) {\n        /*r >>= 1;*/\n        msb |= 1;\n    }\n    r = if msb >= 128 {\n        // divide by 2^(msb - 127)\n        let exp = msb - 127;\n        // compute 2^exp\n        let two_pow_exp = U256::from(2.pow_32(exp as Field));\n        ratio.udiv(two_pow_exp)\n    } else {\n        // multiply by 2^(127 - msb)\n        let exp = 127 - msb;\n        let two_pow_exp = U256::from(2.pow_32(exp as Field));\n        ratio.mul(two_pow_exp)\n\n    };\n\n    // Compute initial log2 = (msb - 128) * 2^64 (as a 192.64 fixed-point number)\n    let mut log2 = if msb >= 128 {\n        U256::from((msb - 128) as Field) * U256::from(Q64 as Field)\n    } else {\n        // negative part treated via sign (see below)\n        U256::from((128 - msb) as Field) * U256::from(Q64 as Field)\n    };\n    // Refine log2 by iterating bits 63 down to 50\n    let negative_log = msb < 128;\n    for i in 50..64 {\n        // Square r in Q128 then scale back by 2^127\n        let product = r.mul(r.udiv(U256::from(10))); // divide by 10 to avoid the overflow error\n        r = product.udiv(U256::from(2.pow_32(127 as Field))).mul(U256::from(10));\n        // Extract the top bit of r (>=2^128) as next log bit\n        if r >= U256::from(Q128) {\n            log2 = if (!negative_log) {\n                log2 + U256::from(2.pow_32(113 - i as Field))\n            } else {\n                log2 - U256::from(2.pow_32(113 - i as Field))\n            };\n\n            r = r.udiv(U256::from(2));\n        }\n    }\n    // Convert log2 to log_sqrt10001 = log2 * log2(sqrt(1.0001)) = log2 * 255738958999603826347141\n    let constant = U256::from(255738958999603826347141);\n    let log_sqrt10001: U256 = log2 * constant;\n    // Compute provisional ticks (128.128 fixed point => integer shift)\n    // // Constants for tick bounds (in same 128.128 scale, as in TickMath.sol\n    let c1 = U256::from(3402992956809132418596140100660247210);\n    let c2 = U256::from(291339464771989622907027621153398088495);\n    let mut tickLow: i32 = 0;\n    let mut tickHi: i32 = 0;\n   \n    let base_hi_field = (log_sqrt10001 - c1).udiv(U256::from(Q128 as Field));\n    let base_lo_field = (log_sqrt10001 + c2).udiv(U256::from(Q128 as Field));\n\n    let base_hi = to_field(base_hi_field);\n    let base_lo = to_field(base_lo_field);\n    if (negative_log) {\n        tickHi = -(base_hi as i32);\n        tickLow = -(base_lo as i32);\n    } else {\n        tickLow = base_hi as i32;\n        tickHi = base_lo as i32;\n    }\n    // Choose the correct tick\n    if tickLow == tickHi {\n        tickLow\n    } else {\n\n        // Compare sqrratio at tickHi to input to resolve ambiguity:contentReference[oaicite:3]{index=3}\n        let sqrtAtTickHi: Field = getSqrtRatioAtTick(tickHi);\n        if U256::from(sqrtAtTickHi) <= U256::from(sqrtPriceX96) {\n            tickHi\n        } else {\n            tickLow\n        }\n    }\n}\n"
    },
    "498": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        array_concat(note_completion_log, padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/home/g/Documents/Projects/Cloak/fzuk/packages/router/src/liquidityAmounts.nr",
      "source": "use dep::aztec::protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize, ToField}};\nuse dep::bignum::{BigNum, bignum::to_field, U256};\nuse dep::factory::fullMath::{mulDiv, mulDivRoundingUp};\nuse dep::factory::tick::{Q96, RESOLUTION};\n\n/// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n/// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\n/// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n/// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n/// @param amount0 The amount0 being sent in\n/// @return liquidity The amount of returned liquidity\nfn getLiquidityForAmount0(\n    _sqrtRatioAX96: Field, // uint160\n    _sqrtRatioBX96: Field, // uint160\n    _amount0: Field, // uint256\n) -> u128 {\n    let mut sqrtRatioAX96 = _sqrtRatioAX96;\n    let mut sqrtRatioBX96 = _sqrtRatioBX96;\n    if (sqrtRatioAX96 as u128 > sqrtRatioBX96 as u128) {\n        sqrtRatioAX96 = _sqrtRatioBX96;\n        sqrtRatioBX96 = _sqrtRatioAX96;\n    }\n    let intermediate = mulDiv(sqrtRatioAX96, sqrtRatioBX96, Q96);\n\n    mulDiv(_amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96) as u128\n}\n\n/// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n/// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n/// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n/// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n/// @param amount1 The amount1 being sent in\n/// @return liquidity The amount of returned liquidity\nfn getLiquidityForAmount1(\n    _sqrtRatioAX96: Field, // uint160\n    _sqrtRatioBX96: Field, // uint160\n    _amount1: Field, // uint256\n) -> u128 {\n    let mut sqrtRatioAX96 = _sqrtRatioAX96;\n    let mut sqrtRatioBX96 = _sqrtRatioBX96;\n    if (sqrtRatioAX96 as u128 > sqrtRatioBX96 as u128) {\n        sqrtRatioAX96 = _sqrtRatioBX96;\n        sqrtRatioBX96 = _sqrtRatioAX96;\n    }\n    (mulDiv(_amount1, Q96, sqrtRatioBX96 - sqrtRatioAX96)) as u128\n}\n\n/// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n/// pool prices and the prices at the tick boundaries\n/// @param sqrtRatioX96 A sqrt price representing the current pool prices\n/// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n/// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n/// @param amount0 The amount of token0 being sent in\n/// @param amount1 The amount of token1 being sent in\n/// @return liquidity The maximum amount of liquidity received\nfn getLiquidityForAmounts(\n    _sqrtRatioX96: Field, // uint160\n    _sqrtRatioAX96: Field, // uint160\n    _sqrtRatioBX96: Field, // uint160\n    _amount0: Field, // uint256\n    _amount1: Field, // uint256\n) -> u128 {\n    let mut liquidity = 0 as u128;\n    let mut sqrtRatioAX96 = _sqrtRatioAX96;\n    let mut sqrtRatioBX96 = _sqrtRatioBX96;\n    if (sqrtRatioAX96 as u128 > sqrtRatioBX96 as u128) {\n        sqrtRatioAX96 = _sqrtRatioBX96;\n        sqrtRatioBX96 = _sqrtRatioAX96;\n    }\n    if (_sqrtRatioX96 as u128 <= sqrtRatioAX96 as u128) {\n        liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, _amount0);\n    } else if (_sqrtRatioX96 as u128 < sqrtRatioBX96 as u128) {\n        let liquidity0 = getLiquidityForAmount0(_sqrtRatioX96, sqrtRatioBX96, _amount0);\n        let liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, _sqrtRatioX96, _amount1);\n\n        if (liquidity0 < liquidity1) {\n            liquidity = liquidity0;\n        } else {\n            liquidity = liquidity1;\n        }\n    } else {\n        liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, _amount1);\n    }\n\n    liquidity\n}\n\n/// @notice Computes the amount of token0 for a given amount of liquidity and a price range\n/// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n/// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n/// @param liquidity The liquidity being valued\n/// @return amount0 The amount of token0\nfn getAmount0ForLiquidity(\n    _sqrtRatioAX96: Field, // uint160\n    _sqrtRatioBX96: Field, // uint160\n    _liquidity: u128, // uint128\n) -> Field {\n    let mut sqrtRatioAX96 = _sqrtRatioAX96;\n    let mut sqrtRatioBX96 = _sqrtRatioBX96;\n    if (sqrtRatioAX96 as u128 > sqrtRatioBX96 as u128) {\n        sqrtRatioAX96 = _sqrtRatioBX96;\n        sqrtRatioBX96 = _sqrtRatioAX96;\n    }\n\n    to_field(U256::from(mulDiv(\n        (_liquidity << RESOLUTION).to_field(),\n        sqrtRatioBX96 - sqrtRatioAX96,\n        sqrtRatioBX96,\n    ))\n        .udiv(U256::from(sqrtRatioAX96)))\n}\n\n/// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n/// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n/// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n/// @param liquidity The liquidity being valued\n/// @return amount1 The amount of token1\nfn getAmount1ForLiquidity(\n    _sqrtRatioAX96: Field, // uint160\n    _sqrtRatioBX96: Field, // uint160\n    _liquidity: u128, // uint128\n) -> Field {\n    let mut sqrtRatioAX96 = _sqrtRatioAX96;\n    let mut sqrtRatioBX96 = _sqrtRatioBX96;\n    if (sqrtRatioAX96 as u128 > sqrtRatioBX96 as u128) {\n        sqrtRatioAX96 = _sqrtRatioBX96;\n        sqrtRatioBX96 = _sqrtRatioAX96;\n    }\n    mulDiv(_liquidity as Field, sqrtRatioBX96 - sqrtRatioAX96, Q96)\n}\n\n/// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n/// pool prices and the prices at the tick boundaries\n/// @param sqrtRatioX96 A sqrt price representing the current pool prices\n/// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n/// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n/// @param liquidity The liquidity being valued\n/// @return amount0 The amount of token0\n/// @return amount1 The amount of token1\nfn getAmountsForLiquidity(\n    _sqrtRatioX96: Field, // uint160\n    _sqrtRatioAX96: Field, // uint160\n    _sqrtRatioBX96: Field, // uint160\n    _liquidity: u128, // uint128\n) -> [Field; 2] {\n    let mut amount0 = 0;\n    let mut amount1 = 0;\n    let mut sqrtRatioAX96 = _sqrtRatioAX96;\n    let mut sqrtRatioBX96 = _sqrtRatioBX96;\n    if (sqrtRatioAX96 as u128 > sqrtRatioBX96 as u128) {\n        sqrtRatioAX96 = _sqrtRatioBX96;\n        sqrtRatioBX96 = _sqrtRatioAX96;\n    }\n\n    if (_sqrtRatioX96 as u128 <= sqrtRatioAX96 as u128) {\n        // below range: only token0 contributes to liquidity\n        amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, _liquidity);\n    } else if (_sqrtRatioX96 as u128 < sqrtRatioBX96 as u128) {\n        // inside range: both tokens contribute\n        amount0 = getAmount0ForLiquidity(_sqrtRatioX96, sqrtRatioBX96, _liquidity);\n        amount1 = getAmount1ForLiquidity(sqrtRatioAX96, _sqrtRatioX96, _liquidity);\n    } else {\n        // above range: only token1 contributes\n        amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, _liquidity);\n    }\n\n    [amount0, amount1]\n}\n"
    },
    "51": {
      "path": "/home/g/Documents/Projects/Cloak/fzuk/packages/router/src/main.nr",
      "source": "mod liquidityAmounts;\nmod test;\nuse dep::aztec::macros::aztec;\nuse dep::aztec::oracle::debug_log::{ debug_log, debug_log_format };\n\nglobal DEFAULT_AMOUNT_IN_CACHED: Field =\n    21888242871839275222246405745257275088548364400416034343698204186575808495616; // ~ type(uint256).max - Got this max from noir error\nglobal amountInCached: Field = DEFAULT_AMOUNT_IN_CACHED;\n\n#[aztec]\ncontract RouterV3 {\n    use crate::liquidityAmounts::getLiquidityForAmounts;\n    use dep::aztec::oracle::debug_log::{ debug_log, debug_log_format };\n    use dep::aztec::{\n        context::{PrivateCallInterface, PrivateContext},\n        prelude::{AztecAddress, Map, PublicMutable},\n    };\n    use dep::aztec::macros::{\n        events::event,\n        functions::{initializer, internal, private, public, view},\n        storage::storage,\n    };\n    use aztec::protocol_types::traits::ToField;\n\n    use aztec::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    use dep::factory::FactoryV3;\n    use dep::factory::{\n        oracle::Observation,\n        pairV3::Pair,\n        position::Position,\n        tick::Tick,\n        tickMath::{getSqrtRatioAtTick, getTickAtSqrtRatio, MAX_TICK, MIN_TICK},\n    };\n\n    #[storage]\n    struct Storage<Context> {\n        factory: PublicMutable<AztecAddress, Context>,\n        liquidityToBeMinted: Map<AztecAddress, Map<AztecAddress, Map<u32, Map<AztecAddress, PublicMutable<u128, Context>, Context>, Context>, Context>, Context>,// tokenA => tokenB => fee => user => to be Minted - we add this to help with Gas\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(_factory: AztecAddress) {\n        storage.factory.write(_factory);\n    }\n\n    // @dev Returns the pool for the given token pair and fee. The pool contract may or may not exist.\n    #[public]\n    fn _getPool(\n        tokenA: AztecAddress,\n        tokenB: AztecAddress,\n        fee: u32, // uint24\n    ) -> Pair {\n        FactoryV3::at(storage.factory.read()).getPool(tokenA, tokenB, fee).call(&mut context)\n    }\n\n    #[public]\n    fn toBeMinted(\n        tokenA: AztecAddress,\n        tokenB: AztecAddress,\n        fee: u32, \n    ) -> u128 {\n       storage.liquidityToBeMinted.at(tokenA).at(tokenB).at(fee as u32).at(context.msg_sender()).read()\n    }\n\n    #[public]\n    fn currentTick(\n        tokenA: AztecAddress,\n        tokenB: AztecAddress,\n        fee: u32, \n    ) -> i32 {\n        let pair = FactoryV3::at(storage.factory.read()).getPool(tokenA, tokenB, fee).call(&mut context);\n       pair.slot0.tick\n    }\n\n\n\n    #[private]\n    fn addLiquidity_private(\n        tokenA: AztecAddress,\n        tokenB: AztecAddress,\n        fee: Field, // uint24\n        recipient: AztecAddress, // address\n        tickLower: u32, // int24\n        tickUpper: u32, // int24\n        isTickLowerNeg: bool,\n        isTickUpperNeg: bool,\n        amount0Desired: Field, // uint256\n        amount1Desired: Field, // uint256\n        amount0Min: Field, // uint256\n        amount1Min: Field, // uint256\n        lte: bool,\n        nonce: Field,\n        secret: Field,\n        sqrtPriceX96: Field,\n    ) {\n        if (!recipient.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, recipient);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let mut finalLower = tickLower as i32;\n        let mut finalUpper = tickUpper as i32;\n        if(isTickLowerNeg){\n            finalLower = - finalLower;\n        }\n        if(isTickUpperNeg){\n            finalUpper = - finalUpper;\n        }\n        let tick = getTickAtSqrtRatio(sqrtPriceX96);\n        let sqrtRatioAX96 = getSqrtRatioAtTick(finalLower);\n        let sqrtRatioBX96 = getSqrtRatioAtTick(finalUpper);\n        let liquidity = getLiquidityForAmounts(\n            sqrtPriceX96,\n            sqrtRatioAX96,\n            sqrtRatioBX96,\n            amount0Desired,\n            amount1Desired,\n        );\n        let mut isNegTick = false;\n        if tick < 0{\n            isNegTick= true;\n        }\n        \n        let _ = RouterV3::at(context.this_address())\n            ._addLiquidity(\n                recipient,\n                tokenA,\n                tokenB,\n                fee,\n                sqrtPriceX96,\n                liquidity as u128,\n                tick as Field,\n                isNegTick\n            )\n            .enqueue(&mut context);\n    }\n\n    /// @notice Add liquidity to an initialized pool\n    #[public]\n    #[internal]\n    fn _addLiquidity(\n        recipient:AztecAddress,\n        tokenA: AztecAddress,\n        tokenB: AztecAddress,\n        fee: Field, // uint24\n        sqrtPriceX96: Field,\n        liquidity: u128,\n        tick: Field,\n        isNegTick: bool\n    ) {\n        let factory = storage.factory.read();\n\n        let _ = FactoryV3::at(factory)\n            .initialize_pool(tokenA, tokenB, fee, sqrtPriceX96, tick, isNegTick)\n            .call(&mut context);\n        \n        let liquidityToBeMinted_storage = storage.liquidityToBeMinted.at(tokenA).at(tokenB).at(fee as u32).at(recipient);\n        liquidityToBeMinted_storage.write(liquidity);\n    }\n\n    #[private]\n    fn _mint_private(\n        tokenA: AztecAddress,\n        tokenB: AztecAddress,\n        fee: Field, // uint24\n        tickLower: u32, // int24\n        tickUpper: u32, // int24\n        isTickLowerNeg: bool,\n        isTickUpperNeg: bool,\n        recipient: AztecAddress,\n        amount0Min: Field, // uint256\n        amount1Min: Field, // uint256\n        lte: bool,\n        nonce: Field,\n    ) {\n        if (!recipient.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, recipient);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        \n        let mut finalLower = tickLower as i32;\n        let mut finalUpper = tickUpper as i32;\n        if(isTickLowerNeg){\n            finalLower = -finalLower;\n        }\n        if(isTickUpperNeg){\n            finalUpper = -finalUpper;\n        }\n        let getSqrtRatioAtTickUpper = getSqrtRatioAtTick(finalUpper);\n        let getSqrtRatioAtTickLower = getSqrtRatioAtTick(finalLower);\n       \n\n        let _ = RouterV3::at(context.this_address())\n            ._mint_public(\n                tokenA,\n                tokenB,\n                fee,\n                recipient,\n                tickLower,\n                tickUpper,\n                isTickLowerNeg,\n                isTickUpperNeg,\n                amount0Min,\n                amount1Min,\n                lte,\n                getSqrtRatioAtTickUpper as Field,\n                getSqrtRatioAtTickLower as Field,\n                nonce,\n            )\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _mint_public(\n        tokenA: AztecAddress,\n        tokenB: AztecAddress,\n        fee: Field, // uint24\n        recipient: AztecAddress,\n        tickLower: u32, // int24\n        tickUpper: u32, // int24\n        isTickLowerNeg: bool,\n        isTickUpperNeg: bool,\n        amount0Min: Field, // uint256\n        amount1Min: Field, // uint256\n        lte: bool,\n        getSqrtRatioAtTickUpper: Field,\n        getSqrtRatioAtTickLower: Field,\n        nonce: Field,\n    ) -> pub [Field; 3] {\n        let liquidityToBeMinted = storage.liquidityToBeMinted.at(tokenA).at(tokenB).at(fee as u32).at(recipient).read();\n        assert(liquidityToBeMinted > 0, \"NOTHING TO MINT\");\n        let factory = storage.factory.read();\n\n        let return_values = FactoryV3::at(factory)\n            ._mint(\n                tokenA,\n                tokenB,\n                fee as u32,\n                recipient,\n                tickLower, \n                tickUpper,\n                isTickLowerNeg, \n                isTickUpperNeg, \n                liquidityToBeMinted,\n                lte,\n                getSqrtRatioAtTickUpper as Field,\n                getSqrtRatioAtTickLower as Field,\n                nonce\n            )\n            .call(&mut context);\n        let amount0 = return_values[0];\n        let amount1 = return_values[1];\n\n        // assert(\n        //     amount0 as u128 >= amount0Min as u128 & amount1 as u128 >= amount1Min as u128,\n        //     \"Price slippage check\",\n        // );\n        [liquidityToBeMinted as Field, amount0, amount1]\n    }\n\n    // #[private]\n    // fn swapSingle_private(\n    //     tokenA: AztecAddress,\n    //     tokenB: AztecAddress,\n    //     fee: u32, // uint24\n    //     recipient: AztecAddress, // address\n    //     amountIn: Field,\n    //     tickSpacing: i32,\n    //     sqrtPriceLimitX96: Field, // uint160\n    //     lte: bool,\n    //     zeroForOne: bool, // The direction of the swap, true for currency0 to currency1, false for currency1 to currency0\n    //     nonce: Field,\n    //     secret: Field,\n    // ) {\n    //     let _ = RouterV3::at(context.this_address())\n    //         ._swapSingle(\n    //             tokenA,\n    //             tokenB,\n    //             fee as Field,\n    //             recipient,\n    //             zeroForOne,\n    //             amountIn,\n    //             sqrtPriceLimitX96,\n    //             lte,\n    //             nonce,\n    //         )\n    //         .enqueue(&mut context);\n\n    //     let amount1 = 0;\n    //     let amount2 = 0;\n\n    //     let _res = Token::at(tokenA)\n    //         .transfer_to_public(recipient, context.this_address(), amount1, nonce)\n    //         .call(&mut context);\n\n    //     let _res = Token::at(tokenB)\n    //         .transfer_to_public(recipient, context.this_address(), amount2, nonce)\n    //         .call(&mut context);\n    // }\n\n    // #[public]\n    // fn _swapSingle(\n    //     tokenIn: AztecAddress,\n    //     tokenOut: AztecAddress,\n    //     fee: Field,\n    //     recipient: AztecAddress, // address\n    //     zeroForOne: bool, // bool\n    //     amountIn: Field, // int256\n    //     sqrtPriceLimitX96: Field, // uint160\n    //     lte: bool,\n    //     nonce: Field,\n    // ) -> Field {\n    //     let factory = storage.factory.read();\n    //     let return_values = FactoryV3::at(factory)\n    //         ._swap(\n    //             tokenIn,\n    //             tokenOut,\n    //             fee,\n    //             recipient,\n    //             zeroForOne,\n    //             amountIn,\n    //             sqrtPriceLimitX96,\n    //             lte,\n    //             nonce,\n    //         )\n    //         .call(&mut context);\n\n    //     let mut amountOut = 0;\n    //     if (zeroForOne) {\n    //         amountOut = -return_values[1];\n    //     } else {\n    //         amountOut = -return_values[0];\n    //     }\n\n    //     amountOut as Field\n    // }\n\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/authwit/auth.nr",
      "source": "use crate::{\n    authwit::authwit_interface::AuthwitInterface,\n    context::{gas::GasOpts, PrivateContext, PublicContext},\n    hash::hash_args_array,\n    macros::authwits::authwit,\n};\nuse dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\npub global IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n#[authwit]\nstruct CallAuthwit {\n    msg_sender: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let authwit = CallAuthwit {\n        msg_sender: context.msg_sender(),\n        selector: context.selector(),\n        args_hash: context.get_args_hash(),\n    };\n    let inner_hash = authwit.emit_as_offchain_effect_and_get_hash();\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "68": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "69": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{\n    gas::GasOpts, private_context::PrivateContext, public_context::PublicContext,\n    returns_hash::ReturnsHash,\n};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\nuse crate::test::helpers::cheatcodes;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateStaticCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<N>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateStaticCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateStaticVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateStaticVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PublicCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicStaticCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicStaticVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicStaticVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for UtilityCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T, let N: u32> UtilityCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for UtilityVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T, let N: u32> UtilityVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\npub trait TXEPublicCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field);\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicStaticVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\npub trait TXEPrivateCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field);\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n\n        let (_end_side_effect_counter, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns: T = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_end_side_effect_counter, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateStaticVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\npub trait TXEUtilityCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self) -> T;\n}\n\nimpl<let M: u32, T, let N: u32> TXEUtilityCallInterface<T, N> for UtilityCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self) -> T {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let returns_hash = crate::oracle::simulate_utility_function::simulate_utility_function(\n            self.get_contract_address(),\n            self.get_selector(),\n            args_hash,\n        );\n\n        let returns: T = ReturnsHash::new(returns_hash).get_preimage();\n        returns\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEUtilityCallInterface<T, N> for UtilityVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self) -> T {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let returns_hash = crate::oracle::simulate_utility_function::simulate_utility_function(\n            self.get_contract_address(),\n            self.get_selector(),\n            args_hash,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n        returns\n    }\n}\n"
    },
    "76": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        include_by_timestamp::IncludeByTimestamp,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: IncludeByTimestamp,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: IncludeByTimestamp::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp =\n            IncludeByTimestamp::min_with_u64(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: IncludeByTimestamp::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "77": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> u128 {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> u128 {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "78": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n\n    pub fn get_preimage_and_assert_empty<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n        assert_eq(self.hash, 0);\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "79": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "82": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    // TODO(#2707): Consider making this a u64 as we already cast this to that when encoding the message. This would decrease\n    // the likelihood of collisions without any extra cost.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "84": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    }
  }
}
