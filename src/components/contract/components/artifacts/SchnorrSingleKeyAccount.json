{
  "transpiled": true,
  "noir_version": "1.0.0-beta.5+0000000000000000000000000000000000000000",
  "name": "SchnorrSingleKeyAccount",
  "functions": [
    {
      "name": "entrypoint",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "app_payload",
            "type": {
              "kind": "struct",
              "path": "authwit::entrypoint::app::AppPayload",
              "fields": [
                {
                  "name": "function_calls",
                  "type": {
                    "kind": "array",
                    "length": 4,
                    "type": {
                      "kind": "struct",
                      "path": "authwit::entrypoint::function_call::FunctionCall",
                      "fields": [
                        {
                          "name": "args_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "target_address",
                          "type": {
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "is_public",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ]
                    }
                  }
                },
                {
                  "name": "nonce",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "fee_payload",
            "type": {
              "kind": "struct",
              "path": "authwit::entrypoint::fee::FeePayload",
              "fields": [
                {
                  "name": "function_calls",
                  "type": {
                    "kind": "array",
                    "length": 2,
                    "type": {
                      "kind": "struct",
                      "path": "authwit::entrypoint::function_call::FunctionCall",
                      "fields": [
                        {
                          "name": "args_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "function_selector",
                          "type": {
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "target_address",
                          "type": {
                            "kind": "struct",
                            "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ]
                          }
                        },
                        {
                          "name": "is_public",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "is_static",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ]
                    }
                  }
                },
                {
                  "name": "nonce",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "is_fee_payer",
                  "type": {
                    "kind": "boolean"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "cancellable",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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O47tPLZ5bGvfru9Oz+Pd6Xm8Oz2Pd6fn8e70PN6dnse707ftEa+OeHXE2/7mxC7aKewU/RR+ijjFOMU8xfoa+n78zYlNrH9zoq2379sfnTiUSXUplwqpITWlUqpOZWKYGCaGiWFi2Pb6+H78DYpDbS+q9+OvUByqTtW319/P4w9RHMqkupRLhdSQmlIpVadyMVwMF8PFcDFcDBfDxXAxXIwQI8QIMUKMECPECDFCjBAjxBhiDDGGGEOMIcYQY4gxxBhiDDGmGFOMKcYUY4oxxZhiTDGmGFOMFCPFSDFSjBQjxUgxUowUI8UoMUqMEqPEKDFKjBKjxCgx1uRu672OLYtUkzKpLuVSITWkplRKidHEaGI0MZoYTYwmRhOjidHEaGKYGCaGiWFimBgmholhYpgYJkYXo4vRxdjyfL3lsi3PdxVSG8NXNaVSqk615fmu2vm7W57vSowtz/efCykxXAwXw8UIMUKMECPECB1H6DhCjBAjxAgxhhhbnu/KpLqUjmOIseX5rqZUStWpphhTjCnGFGOKMTVWU8cxdRxTxzHF2PJ8Vxqr1FilxirFSDFSjBQjxUiNVek4SsdROo4So3Q+SmNVGqvSWJUYdTL6skg1KZPqUi4VUkPqZPQlpc6x6m2RalJiNDGaGE2MJkabUiml4zAdh4lhJtWlXCqkxDAxTAwTo4vRNVZdx9F1HF3HoTzvfUhprLrGqmuslOfdxXAxXAzleVeed+V5V5535Xl3MULnQ3neledded5DjBBDed6V51153pXnXXneledded6HGEPnQ3neledded6HGEMM5XlXnnfleVeed+V5V5535XmfYkydD+V5V5535XlPMVIM5XlXnnfleVeed+V5V5535XkvMUrnQ3neledded5LjBJDed6V5648d+W5K89dee7Kc19Ohi9Dakql1DlW3sRoYijPXXnuynNXnrvy3JXnrjz3JoYtUk3KpLqUGCaG8tyV5648d+W5K89dee7Kc9f13HU9d+W5K89dee66nruu5648d+W5K89dee7Kc1eeu/LcXQzX+VCeu/LcleceYoQYynNXnrvy3JXnrjx35bkrz32IMXQ+lOeuPHfluQ8xhhjKc1eeu/LcleeuPHfluSvPfYoxdT6U5648d+W5pxgphvLcleeuPHfluSvPXXnuynNPMUrnQ3nuynNXnnuJUWIoz115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",
      "brillig_names": [
        "get_auth_witness",
        "decompose_hint",
        "lte_hint",
        "notify_enqueued_public_function_call_wrapper",
        "call_private_function_internal",
        "debug_log_oracle_wrapper",
        "notify_set_min_revertible_side_effect_counter_oracle_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "directive_to_radix",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/7WTPQ+CMBCGi2KUjzjgoD+jBAyM+LG4OLpXCkpUSAB3frqQXENtwKjAJU17FJ5736OVUB0SzDLqEAyyglmBecTtj8vhQY67hakIdfvku9i2lQZ/Peq3FGBKw/Ax4w/UfzwFzr6o+bwXVndWDo1b66g+H0P5Z/9vSP+LD5418GpAXnmew/oS5Nt74t+Oz8c5SNnXTR1EgnIxdK5CSd0lcZ4SP99QmgZZJhJGDWTUQlU56pVE8YG26fmRdgrSLEpikSZ/Sav6yu6lXLyr8eA57hCOizHTMAb+BDV3X+b2+feXkKuCJ+bT+1Nn6BAztEhI1oRS2yeGwK+CP38vlizs4eEFAAA=",
      "debug_symbols": "nZPbjoMgEIbfZa69ADmIvErTNKjYkBA0VDfZGN99oYFWN2Gz6Q3jOPN//Jw2GHS33m/GjdMD5GWDzhtrzf1mp14tZnLh7wYoDpiAJBVgCpKFwEA2IXCQ7b5XkPtvi9c6th8AATsrr90C0q3WVvCl7PpseszKPeOifKiiCrQbQgzA0Vgdv/bqrUZlKUaM8iTHiCP2QoTsBMFlSCMyQiD6AjTkpK/LelazpGfsvQZMxX8NCNJkA6wtGaBlPSVt0lMuPjIgaDbQipIBXtaHjU96XvNPDLR1nQAtYSUD4g8DIl+iBv06gmtIVW/86W7vEeWN6qxO6bi6/lBdvudcyW9j9lOvh9XrSDo8kDBesKhqct3jbD8=",
      "brillig_names": [
        "sync_private_state"
      ]
    },
    {
      "name": "verify_private_authwit",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "inner_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "19458536156181958": {
            "error_kind": "string",
            "string": "Function verify_private_authwit can only be called statically"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZ3Rjtw20oXfZa59IVYVWVV5lUWwcBLvwoDhBE6ywI8g7/6LEs9he7LNtNWzN+Zxz+gUWeJHUpRa88fLTx9++P3f//z4+V8///ry3T/+ePnhy8dPnz7++5+ffv7x/W8ff/68f/rHy9b/0fbynb57UT+LOIs8CtvOopyFvHxX90LPws6inkU7Cz+LOIs8irqdRTmL06WeLvV0qadLPV3q6VJPl3q6tP3D9u7Fd7PYi3IWchZ6FnYW9SzaWfhZxFnkUcTpEqdLnC5xusTpEqdLnC5xuuR+XO7F/ptl28v9V4vsZR3l/stlz1T6KGOUe9Ri717KtkHskUvtQiAUopu2LipEg+i+3kVA5BClO0cXBUIgunN2YRAVYneWrQuHCIjdWcouZIMoELuzSBcKYRC7s2gXDcIhunNvu+QQukF05952FQiF6M697VohunNvcu+ypwiIno1ew95xpbe9d91D9F4kvcltgygQAjFOa2kGUSEahEMERA7Ru+YpCsTuo4eoEA3CITpxvc69ax6id85TdO56VnsHPYVCGER37untHfUUDhEQOUTvvqcoEALRnfXPXfVBofcL7en3UXarnvzutGe69wn1/beFvx3nT23bP9X+aR8ZyjkylHNkKOfIUM6Rofy5/ybGo3/+9uXDh37UzQC1D1u/vP/y4fNvL999/v3Tp3cv/3n/6ffjl3795f3no/zt/Zf9p3saP3z+aS93w399/PShqz/fzaO3+4fWnujj4OqNhxfLRw2ip+UwiJjx69cVkPvHm+P4WnQeXx+OHzg+S96Lb4v4HcDjeJN65fgqOL7aheNr5Di+lbvx/f7xbQscLzcnMOVhA0MCWi2XDBoy0FrcNViloFWmoN1LQR/W7hlopuIkbNu00BIPe9hGEmwzu+jhSY+9/c967NPlNQ8pwU6t5aJHbfRoec1DN8KlxZ/3uCH0mzzM2D+sXuwfFuwflhf7R5Wcg4U871Ev9o/WeG6bXzy3Ps+Ll7joUXlevPnzHn6/fyzGn5Y+HHzzK0Owo2e0aFcGQMvy3+bAx+egMB5vzx0v25XjG7tklHvHr+bwDTNI3M5h/tXxao/NYXrJIOYpjGsGG/vQ3RqsUsAZLDIvHJ9chmX1uw3I+wb7BZRjGt513mQhHq2EVANJ0soc3/YLuK+70oJnEUMmRdr08K+bYoslpW6Jlmi5WZK8ttBFNqpz+tu1Tyoky9cui04hRWAixW7Gpu3V2FQXNREucPcLx7zmoQ29a78g3O57rNoiXOaJ+P22rLrHnEL37qH3u8eim1opc3lUZzX84cFmv1bPjRmttt2txwq3jbjpzZL1665RF31Uss0+elOHffj6ymLRR2VfKWLYky11srJfiHxlYquhl0vF2G7y+bqb10X3cjecE/ds9z3agtl5GXVzDSDllYOvOiivpEQ3ue8Rq0GQnXzfCKrXPPbhBx4qcdejrbqXVY7m1xz2fTW2ZGv12Vp4vXZOvHAAdN3u12LRQ/edIg5envfPa6tP57M+m4uVw8NnZJWLnH0rZdHHV7OjbBj+VG4Hr69HHl8OoVww7luXcm/8W1qoTIu23bVYDaFc9MnNJF9f7Vvoat2/cdWXN5enrxY8vho+ZyXidrXy2mJRC9+nRYyecnNxetWi2TWL5Biu5ZpF4bJrl9caYkILk/tnZNEr6oYlaA271yuirOYA4fKg3OyIqX9diVh1zWAq5LZnXfa4uSz6Jo/ktCrp9rxH6NW2kNXUqzmd8/tlj6xltiUuelh7yGPZx3jFvPe2+23J8nwfe9hj0ceWHg/2sYc9Fn3sb9ryUB9bezzWx/6mLQ/1sbXHG/QxqcE+drOW/TaPmGvZ0p73WHH7sEd7Oh+XPUy5hjO7mFOrnF+s6dV6lOlhFz14o2G/3ScXPbh1uk+V29V6xPS42D8qr0DL7c7Ca4+y2kkuyQsN2VSumcg29zjKoreXoqs9fg5l+9m92aBoVz30vsdyL07K3IvLRWMWV/b7zXv296i3NwhfeayuI5W7caI388NfPBbX5doMjdF2szT8Jg/nRprGVi56VH/eg/197eHLyyeeXKsXPRrHw/26o170mNi56Bt4tPsey84+10Iq98eyIv70JWWRePqaclmPBy8qH/e4f1X5Nx4PXVauPR67rlx7PHZhue4gc+IWa3FxfpjXp1Ll4iqkCWfdfVC76MEbVrvMpz18MfsvL9d56/P26ZNXl+vFFjtJ+41e7mfddo99w/GVyeoJkm1ux2+rO+LL+07KW9GquV00MWdz6hYXTWoE5zppF03mHf59vlk8RbJOLHc9d/5XzfHnb1IUi+fvUpTV7afHblOUuj1/n6LU8vyNirXJg3cqyuou1GNb60uLR3fGH62H14tnZo5n+2pXFyb+FkmN55Ma/9t8PHj3Zr/kev72zdGhn8zHyuLhTrZszIP3X9YTlnD6Vr3Z3PnLhNXaGwyJzd9gSGzx9JDY8g2GxOUdpUeHxGVNHu3yqzXNw13enx9X/S3G1WVj3qTLm7LL3z4i9pcu775a6HHprLdP07ze0fDVzfmcG2dpd5/0Wnrs9085TWxy92GvY1l6d9nLHlJvH/eKb6nF3CLeWt6vhfxPa3GML2O763ZTxb/Jozzvwc3d6x63o5Dc7xuxnP0n+prlmoeVucksb+FRL3rI3CA2u+rBzd19R/L5tlz2uNnsjnja4/bK7Js8apkeN0+Av/bI9iy161qQuFIXtGQ8W4v1pMBc7JOC3J0UjudV7t/u54RdN/N7k8LSwzKDHrcd7LWHPL1l/w0e97fsH09qWyR19aiScabd7zTF/cYsemlzzpLNZbvmEXx+dt+xb9c8kn19r5Fc8ujbn9wJzaseXCfvHnrJY1/p80H5Le939rK8Dsp5L7Vs2t7EJa+1R7lbHmr381rqm7SnvkF7Hn6y7mbCfPVk3WokCj6Dv89SN+Btr9uyuoaxeQ1jOnuJP/xlgjqfwd/3qO8/qH3cHlxs27d5C2Im9NWT2iLLLUh+j+3mXuo3fDt1n5s4gmzl1aPe3+//ff/jxy9fvxSgf23cji9Tj9JGWUfZv6O/nV8NPsr+Lf1yfvm3X4H2rwYfZRml9NFrL3WUNsrac7SXbZQ+yhhlnmX/kvhRllHKKHWUNsrhp8NPh58OPx1+Nvxs+Nnws+Fnw8+Gnw0/G342/Gz41eFXh18dfnX41eFXh18dfnX41eFXh18bfm34teHXhl8bfm34teHXhl8bfm34+fDz4efDz4efDz8ffj78fPj58PPhF8Mvhl8Mvxh+Mfxi+MXwi+EXwy+GXw6/HH45/HL49Xcs9FGhv2PhKNsofZQxyjzL4x0LpygQAqEQBlEhGoRDBAScC5wLnAucC5wLnAucC5wLnAucC5wFzgJngbPAWeAscBY4C5wPeHy8Y+EQBz4+3rHQh5PjHQunUAiDqBANRzkEnA+OYrxjwfGOhVPA2eBscDY4G5wNzgZnQ50r6lzhXOFc4VzhXOF8gHUIhwgI1LnB+aDLx8sfTqEQBgHnBucG5wbnBmdHNhx1dtTZUWeH88Gaj9dBnALZcGTD4RxwDjgHnAPOgWwE6hyoc6DOAedAnhPZSGQjkY2Ec8I54ZxwTjgnspGjzrJtEAViOMumEAZRIRqE46iAgHOBc4FzEQiFMIgKAefiEAExsiGyQcBZ4CxwFjgLnKVBoM6COgvqDAZFCwSyociGIhtgUBTOCmeFMxgUMChgUMCggEExOBvyDAYFDAoYFINzhTMYFDAoYFDAoIBBAYMCBqXCuSLPYFDAoIBBaXBucAaDAgYFDAoYFDAoYFDAoDicHXkGgwIGBQyKw9nhDAYFDAoYFDAoYFDAoIBBCTgH8gwGBQwKGJSEc8IZDAoYFDAoYFDAoIBBAYO6DWfdCoRAKIRBVBzVIBwiIOAMBhUMKhhUMKgFzqVCNAiHCAg4C5zBoIJBBYMKBhUMKhhUMKiYBxXzoIJBBYMKBhXzoGIeVDCoYFDBoIJBBYMKBhUMqsHZkGcwqGBQwaAanA3OYFDBoIJBBYMKBhUMKhjUCueKPINBBYMKBrXBucEZDCoYVDCoYFDBoIJBBYPqcHbkGQwqGFQwqA5nhzMYVDCoYFDBoIJBBYMKBjXgHMgzGFQwqGBQA84JZzCoYFDBoIJBBYMKBhUMasI5R54NDBoYNDBo23C2zSAqRINwiIAYdTYwaGDQCpyLQhhEhWgQcC5wBoMGBg0MGhg0MGhg0MCgCZzFIQIC2QCDhrWoYS1qYNDAoIFBA4MGBg0MGhg0g7Mhz2DQwKCBQcNa1AzOYNDAoIFBA4MGBg0MGhi0CueKPINBA4MGBg1rUWtwBoMGBg0MGhg0MGhg0MCgNTg35BkMGhg0MGhYi5rDGQwaGDQwaGDQwKCBQQODFnAO5BkMGhg0MGhYi1rAGQwaGDQwaGDQwKCBQQODlnBO5BkMGhisYLBiLVo3gVAIg6gQDcIhAmLUuRY4lwIhEAphEHAucAaDFQxWMFjBYAWDFQxWMFgFzlIhGoRDBAScwWDFPFgxD1YwWLEWrQpnXA9WMFjBYAWDFfNg7Qz2m7+1M1j6jn+148161pV1dbz5sVI1KqcKqoSqxwv2WleFSqiUyqgq1RGjN6EeMXpFa1AlVNuoCpVQHTGyK6OqVI3KqYLqeDlhz8vxosD+Gsh6vCnwVEKlVEbVY/RNz9opLX3PsHZMx2fBzxKfdVLPzzqqRY73afYYcvxUqYyqUjUqpwqqhMqNqlAxRjJGMkYyRjJGMkYyRiJG2zaqQiVUSmVUlapROVVQMUZhjMIYhTEKYxTGKIxRjld+Hvt1ThVUPUb/jkDrRA9VqIRKqQzHdqyHYgxx/l5QMYYyhjKGMoYyhjKGMoYyhrIdynYoYxhjGGMYYxhjHJyfqlI1KrbDGOPg/FAH56cqVELFGJUxKmNUxqiMUZmrynY0tqOxHY0xDs5PxVw15qoxV40xGmM0xnDGcMZw5srZDmc7nO1wxnCeD2eunLkK5ioYIxgjGCMYIxgjmKtgO4LtCLYjGSN5PpK5SuYqmatkjGSMZIxkjEQM3zaqQiVUSoUYvlWqRuVUQcUYhTEKYxTGKIxRjKpSNSqnYoyC8+GyURUqoWIMYQxhDGEMcu7k3Mm5k3Mn566MoUrFXJFzJ+eujKGMQc6dnDs5d3Lu5NzJuZNzN8Ywng9y7uTcyblXxqiMQc6dnDs5d3Lu5NzJuZNzb4zReD7IuZNzJ+feGKMxBjl3cu7k3Mm5k3Mn507O3RnDeT7IuZNzJ+fujBGMQc6dnDs5d3Lu5NzJuZNzD8YIng9y7uTcybknYyRjkHMn507OnZw7OQ9yHuQ8NsSITamMqlI1KuexQcUY5DzIeZDzIOdBzoOcB+fz4Hwe5DzIeZDz4HwenM+DnAc5D3Ie5DzIeZDzIOehjKGFirki50HOQxlDGYOcBzkPch7kPMh5kPMg52GMYTwf5DzIeZDzMMaojEHOg5wHOQ9yHuQ8yHmQ86iMUXk+yHmQ8yDn0RijMQY5D3Ie5DzIeZDzIOdBzsMZw3k+yHmQ8yDn4YzhjEHOg5wHOQ9yHuQ8yHmQ8wjGCJ4Pch7kPMh5JGMkY5DzIOdBzoOcBzkPch7kPDfEyK1QCZVSGVXlsY3KqYKKMch5kvMk50nOszBGqVSNyqmCijG4bk9ynuQ8yXmS8yTnSc6TnKcwhuB8JDlPcp7kPLluT2UMcp7kPMl5kvMk50nOk5ynMYbxfJDzJOdJzpPr9jTGIOdJzpOcJzlPcp7kPMl5VsaoPB/kPMl5kvPkuj0bY5DzJOdJzpOcJzlPcp7kPJ0xnOeDnCc5T3KeXLenMwY5T3Ke5DzJeZLzJOdJzjMYI3g+yHmS8yTnyXV7JmOQ8yTnSc6TnCc5T3Ke5DyTMRLno2wEfZdlSpkScXZpU9Yp25Q+ZUyZlER+l2XKGa3olDZlnbJNOaMR/V3Otslsm8xoMqPJjCYzmsy2yWybzGgy23aOAsefBDmHgePvfJzjgB/yiJaH1Cltyjplm9KnjCmT8hwQTlmmnNFsRrMZzWY0m9FsRrMZzWa0OqPVGa3OaHVGqzNandHqjFZntDqj1RmtzWhtRmszWpvRjoGino8A1SnblD5lTJmUx3AxZJlSptQpZzSf0XxG8xnNZ7Rj3GhHLzkGjiF7tPGskkypU/ZofjTzGD3i6J7H8BF6yB4tji53DCD9a9O7TMpjCMmjIx5jyJA9Wh6+xygypB1vjjlk/2Mt2/m7bUqfMqbM47Ux7/rzVduUZUqZUo/3yhzSpqzHt2gO2aONP4jjU45nzsr5LNehyhHLDlmmlOMbNIc8/rhNf/rzP++/fHz/w6cPv75890d/hPL3zz/iccn9v7/93y/4Cf7K0i9ffv7xw0+/f/nQH608nqrcxj//6FUWte+PP5Lyj/6MqGzt+56H/sM9I1Kk/7f0/2rdf9f7c5rnX2U5fsfeSfaPZH7k71T6R9o/6r772GIC11re1fb9n/2Bz/8H",
      "brillig_names": [
        "get_auth_witness",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_to_radix",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "1752556835457866331": {
            "error_kind": "string",
            "string": "No public functions"
          }
        }
      },
      "bytecode": "JwAABAEqAAABBRhSVSgKJhpbPAAAAQ==",
      "debug_symbols": "XY1bCoAgEEX3Mt+toK1EiI9RBkRl0iDEvWeRIH3ee+6jgkFVnKBg4wHrVkExeU9O+Khlphi6W9sCQ4rMiN2CiW97D0hN/C+dkkkqj5+0JeiJ5isNMk4TR42mMD5LL2t7uwE=",
      "brillig_names": [
        "public_dispatch"
      ]
    }
  ],
  "outputs": {
    "globals": {},
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "app_payload",
                    "type": {
                      "fields": [
                        {
                          "name": "function_calls",
                          "type": {
                            "kind": "array",
                            "length": 4,
                            "type": {
                              "fields": [
                                {
                                  "name": "args_hash",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "function_selector",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "inner",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                                  }
                                },
                                {
                                  "name": "target_address",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "inner",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                  }
                                },
                                {
                                  "name": "is_public",
                                  "type": {
                                    "kind": "boolean"
                                  }
                                },
                                {
                                  "name": "is_static",
                                  "type": {
                                    "kind": "boolean"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::entrypoint::function_call::FunctionCall"
                            }
                          }
                        },
                        {
                          "name": "nonce",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::entrypoint::app::AppPayload"
                    }
                  },
                  {
                    "name": "fee_payload",
                    "type": {
                      "fields": [
                        {
                          "name": "function_calls",
                          "type": {
                            "kind": "array",
                            "length": 2,
                            "type": {
                              "fields": [
                                {
                                  "name": "args_hash",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "function_selector",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "inner",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                                  }
                                },
                                {
                                  "name": "target_address",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "inner",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                                  }
                                },
                                {
                                  "name": "is_public",
                                  "type": {
                                    "kind": "boolean"
                                  }
                                },
                                {
                                  "name": "is_static",
                                  "type": {
                                    "kind": "boolean"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::entrypoint::function_call::FunctionCall"
                            }
                          }
                        },
                        {
                          "name": "nonce",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "is_fee_payer",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::entrypoint::fee::FeePayload"
                    }
                  },
                  {
                    "name": "cancellable",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "SchnorrSingleKeyAccount::entrypoint_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "SchnorrSingleKeyAccount::entrypoint_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "SchnorrSingleKeyAccount::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "SchnorrSingleKeyAccount::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "inner_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "SchnorrSingleKeyAccount::verify_private_authwit_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "SchnorrSingleKeyAccount::verify_private_authwit_abi"
        }
      ]
    }
  },
  "file_map": {
    "106": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "145": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "147": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "148": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "149": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "160": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "192": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "211": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "273": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "290": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "291": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "308": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "318": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "367": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "378": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/schnorr/v0.1.1/src/lib.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\nuse std::hash::{blake2s, pedersen_hash};\n\npub fn verify_signature<let N: u32>(\n    public_key: EmbeddedCurvePoint,\n    signature: [u8; 64],\n    message: [u8; N],\n) -> bool {\n    //scalar lo/hi from bytes\n    let sig_s = scalar_from_bytes(signature, 0);\n    let sig_e = scalar_from_bytes(signature, 32);\n    // pub_key is on Grumpkin curve\n    let mut is_ok = (public_key.y * public_key.y == public_key.x * public_key.x * public_key.x - 17)\n        & (!public_key.is_infinite);\n\n    if ((sig_s.lo != 0) | (sig_s.hi != 0)) & ((sig_e.lo != 0) | (sig_e.hi != 0)) {\n        let (r_is_infinite, result) =\n            calculate_signature_challenge(public_key, sig_s, sig_e, message);\n\n        is_ok &= !r_is_infinite;\n        for i in 0..32 {\n            is_ok &= result[i] == signature[32 + i];\n        }\n    } else {\n        is_ok = false;\n    }\n    is_ok\n}\n\npub fn assert_valid_signature<let N: u32>(\n    public_key: EmbeddedCurvePoint,\n    signature: [u8; 64],\n    message: [u8; N],\n) {\n    //scalar lo/hi from bytes\n    let sig_s = scalar_from_bytes(signature, 0);\n    let sig_e = scalar_from_bytes(signature, 32);\n\n    // assert pub_key is on Grumpkin curve\n    assert(public_key.y * public_key.y == public_key.x * public_key.x * public_key.x - 17);\n    assert(public_key.is_infinite == false);\n    // assert signature is not null\n    assert((sig_s.lo != 0) | (sig_s.hi != 0));\n    assert((sig_e.lo != 0) | (sig_e.hi != 0));\n\n    let (r_is_infinite, result) = calculate_signature_challenge(public_key, sig_s, sig_e, message);\n\n    assert(!r_is_infinite);\n    for i in 0..32 {\n        assert(result[i] == signature[32 + i]);\n    }\n}\n\nfn calculate_signature_challenge<let N: u32>(\n    public_key: EmbeddedCurvePoint,\n    sig_s: EmbeddedCurveScalar,\n    sig_e: EmbeddedCurveScalar,\n    message: [u8; N],\n) -> (bool, [u8; 32]) {\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    let r = multi_scalar_mul([g1, public_key], [sig_s, sig_e]);\n    // compare the _hashes_ rather than field elements modulo r\n    let pedersen_hash = pedersen_hash([r.x, public_key.x, public_key.y]);\n    let pde: [u8; 32] = pedersen_hash.to_be_bytes();\n\n    let mut hash_input = [0; N + 32];\n    for i in 0..32 {\n        hash_input[i] = pde[i];\n    }\n    for i in 0..N {\n        hash_input[32 + i] = message[i];\n    }\n\n    let result = blake2s(hash_input);\n    (r.is_infinite, result)\n}\n\n//Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\nfn scalar_from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n    let mut v: Field = 1;\n    let mut lo: Field = 0;\n    let mut hi: Field = 0;\n    for i in 0..16 {\n        lo = lo + (bytes[offset + 31 - i] as Field) * v;\n        hi = hi + (bytes[offset + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    let sig_s = EmbeddedCurveScalar::new(lo, hi);\n    sig_s\n}\n\nmod test {\n    use std::embedded_curve_ops::EmbeddedCurvePoint;\n\n    use super::verify_signature;\n\n    #[test]\n    fn test_zero_signature() {\n        let public_key: EmbeddedCurvePoint = EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860,\n            is_infinite: false,\n        };\n        let signature: [u8; 64] = [0; 64];\n        let message: [u8; _] = [2; 64]; // every message\n        let verified = verify_signature(public_key, signature, message);\n        assert(!verified);\n    }\n\n    #[test]\n    fn smoke_test() {\n        let message: [u8; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n        let pub_key_x: Field = 0x04b260954662e97f00cab9adb773a259097f7a274b83b113532bce27fa3fb96a;\n        let pub_key_y: Field = 0x2fd51571db6c08666b0edfbfbc57d432068bccd0110a39b166ab243da0037197;\n        let signature: [u8; 64] = [\n            1, 13, 119, 112, 212, 39, 233, 41, 84, 235, 255, 93, 245, 172, 186, 83, 157, 253, 76,\n            77, 33, 128, 178, 15, 214, 67, 105, 107, 177, 234, 77, 48, 27, 237, 155, 84, 39, 84,\n            247, 27, 22, 8, 176, 230, 24, 115, 145, 220, 254, 122, 135, 179, 171, 4, 214, 202, 64,\n            199, 19, 84, 239, 138, 124, 12,\n        ];\n\n        let pub_key = EmbeddedCurvePoint { x: pub_key_x, y: pub_key_y, is_infinite: false };\n        let valid_signature = verify_signature(pub_key, signature, message);\n        assert(valid_signature);\n        super::assert_valid_signature(pub_key, signature, message);\n    }\n\n}\n\nmod bench {\n    use super::{assert_valid_signature, verify_signature};\n    use std::embedded_curve_ops::EmbeddedCurvePoint;\n\n    #[export]\n    pub fn bench_verify_signature(\n        public_key: EmbeddedCurvePoint,\n        signature: [u8; 64],\n        message: [u8; 32],\n    ) -> bool {\n        verify_signature(public_key, signature, message)\n    }\n\n    #[export]\n    pub fn bench_assert_valid_signature(\n        public_key: EmbeddedCurvePoint,\n        signature: [u8; 64],\n        message: [u8; 32],\n    ) {\n        assert_valid_signature(public_key, signature, message)\n    }\n}\n"
    },
    "50": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/account/schnorr_single_key_account_contract/src/auth_oracle.nr",
      "source": "use dep::authwit::auth_witness;\nuse dep::aztec::{\n    protocol_types::{address::PartialAddress, public_keys::{PUBLIC_KEYS_LENGTH, PublicKeys}},\n    utils::array,\n};\nuse aztec::protocol_types::traits::Deserialize;\n\npub struct AuthWitness {\n    keys: PublicKeys,\n    signature: [u8; 64],\n    partial_address: PartialAddress,\n}\n\nimpl AuthWitness {\n    fn deserialize(values: [Field; 77]) -> Self {\n        let mut signature = [0; 64];\n        for i in 0..64 {\n            signature[i] = values[i + PUBLIC_KEYS_LENGTH] as u8;\n        }\n        Self {\n            keys: PublicKeys::deserialize(array::subarray(values, 0)),\n            signature,\n            partial_address: PartialAddress::from_field(values[76]),\n        }\n    }\n}\n\npub unconstrained fn get_auth_witness(message_hash: Field) -> AuthWitness {\n    let witness: [Field; 77] = auth_witness::get_auth_witness(message_hash);\n    AuthWitness::deserialize(witness)\n}\n"
    },
    "51": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/account/schnorr_single_key_account_contract/src/main.nr",
      "source": "mod util;\nmod auth_oracle;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract SchnorrSingleKeyAccount {\n    use dep::aztec::prelude::PrivateContext;\n\n    use dep::authwit::{account::AccountActions, entrypoint::{app::AppPayload, fee::FeePayload}};\n\n    use crate::{auth_oracle::get_auth_witness, util::recover_address};\n\n    use dep::aztec::macros::functions::{private, view};\n\n    // Note: If you globally change the entrypoint signature don't forget to update account_entrypoint.ts\n    #[private]\n    fn entrypoint(app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.entrypoint(app_payload, fee_payload, cancellable);\n    }\n\n    #[private]\n    #[view]\n    fn verify_private_authwit(inner_hash: Field) -> Field {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.verify_private_authwit(inner_hash)\n    }\n\n    #[contract_library_method]\n    fn is_valid_impl(context: &mut PrivateContext, outer_hash: Field) -> bool {\n        // Safety: The witness is only used as a \"magical value\" that makes the signature verification\n        // in `recover_address` and the address check below pass. Hence it's safe.\n        let witness = unsafe { get_auth_witness(outer_hash) };\n        recover_address(outer_hash, witness).eq(context.this_address())\n    }\n}\n"
    },
    "52": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/account/schnorr_single_key_account_contract/src/util.nr",
      "source": "use crate::auth_oracle::AuthWitness;\nuse dep::aztec::prelude::AztecAddress;\nuse std::embedded_curve_ops::EmbeddedCurvePoint;\n\npub fn recover_address(message_hash: Field, witness: AuthWitness) -> AztecAddress {\n    let message_bytes: [u8; 32] = message_hash.to_be_bytes();\n    let public_key = EmbeddedCurvePoint {\n        x: witness.keys.ivpk_m.inner.x,\n        y: witness.keys.ivpk_m.inner.y,\n        is_infinite: false,\n    };\n\n    // In a single key account contract we re-used ivpk_m as signing key\n    schnorr::assert_valid_signature(public_key, witness.signature, message_bytes);\n\n    AztecAddress::compute(witness.keys, witness.partial_address)\n}\n"
    },
    "53": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/account.nr",
      "source": "use dep::aztec::{\n    context::PrivateContext,\n    protocol_types::{\n        constants::{GENERATOR_INDEX__COMBINED_PAYLOAD, GENERATOR_INDEX__TX_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::Hash,\n    },\n};\n\nuse crate::auth::{compute_authwit_message_hash, IS_VALID_SELECTOR};\nuse crate::entrypoint::{app::AppPayload, fee::FeePayload};\n\npub struct AccountActions<Context> {\n    context: Context,\n    is_valid_impl: fn(&mut PrivateContext, Field) -> bool,\n}\n\nimpl<Context> AccountActions<Context> {\n    pub fn init(context: Context, is_valid_impl: fn(&mut PrivateContext, Field) -> bool) -> Self {\n        AccountActions { context, is_valid_impl }\n    }\n}\n\n/**\n * An implementation of the Account Action struct for the private context.\n *\n * Implements logic to verify authorization and execute payloads.\n */\nimpl AccountActions<&mut PrivateContext> {\n\n    /**\n     * Verifies that the `app_hash` and `fee_hash` are authorized and then executes them.\n     *\n     * Executes the `fee_payload` and `app_payload` in sequence.\n     * Will execute the `fee_payload` as part of the setup, and then enter the app phase.\n     *\n     * @param app_payload The payload that contains the calls to be executed in the app phase.\n     * @param fee_payload The payload that contains the calls to be executed in the setup phase.\n     */\n    // docs:start:entrypoint\n    pub fn entrypoint(self, app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let valid_fn = self.is_valid_impl;\n\n        let combined_payload_hash = poseidon2_hash_with_separator(\n            [app_payload.hash(), fee_payload.hash()],\n            GENERATOR_INDEX__COMBINED_PAYLOAD,\n        );\n        assert(valid_fn(self.context, combined_payload_hash));\n\n        fee_payload.execute_calls(self.context);\n        self.context.end_setup();\n        app_payload.execute_calls(self.context);\n        if cancellable {\n            let tx_nullifier =\n                poseidon2_hash_with_separator([app_payload.nonce], GENERATOR_INDEX__TX_NULLIFIER);\n            self.context.push_nullifier(tx_nullifier);\n        }\n    }\n    // docs:end:entrypoint\n\n    /**\n     * Verifies that the `msg_sender` is authorized to consume `inner_hash` by the account.\n     *\n     * Computes the `message_hash` using the `msg_sender`, `chain_id`, `version` and `inner_hash`.\n     * Then executes the `is_valid_impl` function to verify that the message is authorized.\n     *\n     * Will revert if the message is not authorized.\n     *\n     * @param inner_hash The hash of the message that the `msg_sender` is trying to consume.\n     */\n    // docs:start:verify_private_authwit\n    pub fn verify_private_authwit(self, inner_hash: Field) -> Field {\n        // The `inner_hash` is \"siloed\" with the `msg_sender` to ensure that only it can\n        // consume the message.\n        // This ensures that contracts cannot consume messages that are not intended for them.\n        let message_hash = compute_authwit_message_hash(\n            self.context.msg_sender(),\n            self.context.chain_id(),\n            self.context.version(),\n            inner_hash,\n        );\n        let valid_fn = self.is_valid_impl;\n        assert(valid_fn(self.context, message_hash) == true, \"Message not authorized by account\");\n        IS_VALID_SELECTOR\n    }\n    // docs:end:verify_private_authwit\n}\n"
    },
    "54": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\npub global IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "55": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/auth_witness.nr",
      "source": "#[oracle(getAuthWitness)]\nunconstrained fn get_auth_witness_oracle<let N: u32>(_message_hash: Field) -> [Field; N] {}\n\n/**\n * Oracle wrapper to fetch an `auth_witness` for a given `message_hash` from the PXE.\n *\n * @param message_hash The hash of the message for which the `auth_witness` is to be fetched.\n * @return The `auth_witness` for the given `message_hash` as Field array.\n */\npub unconstrained fn get_auth_witness<let N: u32>(message_hash: Field) -> [Field; N] {\n    get_auth_witness_oracle(message_hash)\n}\n"
    },
    "57": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr",
      "source": "use dep::aztec::{\n    prelude::PrivateContext,\n    protocol_types::{\n        constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD,\n        hash::poseidon2_hash_with_separator,\n        traits::{Hash, Serialize},\n    },\n};\nuse std::meta::derive;\n\nuse crate::entrypoint::function_call::FunctionCall;\n\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u32 = 424;\n\nglobal ACCOUNT_MAX_CALLS: u32 = 4;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\n#[derive(Serialize)]\npub struct AppPayload {\n    function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\n    pub nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Hash for AppPayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__SIGNATURE_PAYLOAD)\n    }\n}\n\nimpl AppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..ACCOUNT_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n\n        bytes.storage()\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    pub fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_calldata_hash(\n                        call.target_address,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_args_hash(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n"
    },
    "58": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/authwit/src/entrypoint/fee.nr",
      "source": "use crate::entrypoint::function_call::FunctionCall;\nuse dep::aztec::{\n    prelude::PrivateContext,\n    protocol_types::{\n        constants::GENERATOR_INDEX__FEE_PAYLOAD,\n        hash::poseidon2_hash_with_separator,\n        traits::{Hash, Serialize},\n    },\n};\nuse std::meta::derive;\n\n// 2 * 98 (FUNCTION_CALL_SIZE_IN_BYTES) + 32\nglobal FEE_PAYLOAD_SIZE_IN_BYTES: u32 = 228;\n\nglobal MAX_FEE_FUNCTION_CALLS: u32 = 2;\n\n// docs:start:fee-payload-struct\n#[derive(Serialize)]\npub struct FeePayload {\n    function_calls: [FunctionCall; MAX_FEE_FUNCTION_CALLS],\n    nonce: Field,\n    is_fee_payer: bool,\n}\n// docs:end:fee-payload-struct\n\nimpl Hash for FeePayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__FEE_PAYLOAD)\n    }\n}\n\nimpl FeePayload {\n    fn to_be_bytes(self) -> [u8; FEE_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, FEE_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n        bytes.push(self.is_fee_payer as u8);\n\n        bytes.storage()\n    }\n\n    pub fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_calldata_hash(\n                        call.target_address,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_args_hash(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n        if self.is_fee_payer {\n            context.set_as_fee_payer();\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "70": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "73": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "77": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    }
  }
}
