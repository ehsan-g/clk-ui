{
  "transpiled": true,
  "noir_version": "1.0.0-beta.7+0000000000000000000000000000000000000000",
  "name": "FactoryV3",
  "functions": [
    {
      "name": "_createPool",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "tokenA",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tokenB",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6687445788383290001": {
            "error_kind": "string",
            "string": "ALREADY CREATED"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "9889304366186256219": {
            "error_kind": "string",
            "string": "ZERO_ADDRESS"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15847354018858285526": {
            "error_kind": "string",
            "string": "SAME_TOKEN_PAIR"
          },
          "16540924638517508128": {
            "error_kind": "string",
            "string": "ZERO_SPACING"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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JwIgBAACKiAHISQCABwAAAcfIwAABygtCiEdIwAABzEtCgcdIwAABzEGKhsdGRQqGhweJAIAHgAAB0gjAAAHUicCHwQAAiofGRkcChkaBBwKBBsEKQIAHASAAAAADCoaHB0MKhscGgoqHRobFgodHhwKGR8AHAodIAAEKiAfHSoCACAAAAAAAQAAAAACKiAfIRwKHh8ABCofIR4AKh0eHxYKGh0cChoeAAQqHgQhAiogBB4cCh0iAAQqIh4dACohHR4EKh8eHRwKHR8AKQIAIQD/////DiofISIkAgAiAAAH7yUAABA5HAodHwQWChsdHAodGwQAKhwbHQwqHx0bJAIAGwAACBQlAAAQSwQqGQcbHAobGQUcChkdBBwKHRsFHAobGQQpAgAlBH////8NIgAlgEUAHycCJgQAAyIAJoBFACckAgAfAAAIWCMAAAhhLQonISMAAAhsLgiARQAhIwAACGwpAgAlBH////8MKiUHIicCJgQAAiomByckAgAiAAAIkSMAAAiaLQonIyMAAAijLQoHIyMAAAijBiohIx0UKh8iJCQCACQAAAi6IwAACMQnAiUEAAIqJR0dBCodBx8cCh8hBRwKISIEHAoiHwUcCh0hBAwqIRwiCioiGiEWCiIaHAodIwAcCiIdAAQqHSMiAiogIx0cChogAAQqIB0aACoiGh0EKh0eGhwKGh0AKQIAHgD/////DiodHiAkAgAgAAAJMyUAABA5HAoaHQQWCiEaHAoaHgQAKhweGgwqHRoeJAIAHgAACVglAAAQSxwKHxoEAioaGR0tCh0ZHAoZGgQcCh8dBBwKGx4EDCodHBsMKh4cHRYKHR4KKhseHQwqGhweCioeGxoEKhodGwoqGx0aJAIAGgAACaklAAAQXSkCACEEf////wwqIRkbJwIiBAACKiIZIyQCABsAAAnOIwAACdctCiMdIwAACeAtChkdIwAACeApAgAhBH////8MKiEHHicCIgQAAioiByMkAgAeAAAKBSMAAAoOLQojHyMAAAoXLQoHHyMAAAoXBiodHxoUKhseICQCACAAAAouIwAACjgnAiEEAAIqIRoaJwIHBAEAKhoHGS0KGQccCgcZBBwKGhsEDCobHBoMKhkcGwoqGxoZBCoZGhsKKhsaGSQCABkAAAp2JQAAEEscCgcZABwKGRoGHAoaBwAcCgcZBgco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",
      "debug_symbols": "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",
      "brillig_names": [
        "_createPool"
      ]
    },
    {
      "name": "_mint",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "tokenA",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tokenB",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tickLower",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "tickUpper",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "isTickLowerNeg",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "isTickUpperNeg",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "lte",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "getSqrtRatioAtTickUpper",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "getSqrtRatioAtTickLower",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 2,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2125632064870291657": {
            "error_kind": "string",
            "string": "TMS2"
          },
          "2852997348194806652": {
            "error_kind": "string",
            "string": "LA"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4236375919801895216": {
            "error_kind": "string",
            "string": "Input must be non-zero"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6302762939807105431": {
            "error_kind": "string",
            "string": "TMS1"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7746884635884052893": {
            "error_kind": "string",
            "string": "M0"
          },
          "7790603980827850929": {
            "error_kind": "string",
            "string": "NP"
          },
          "7975540805721646923": {
            "error_kind": "string",
            "string": "M1"
          },
          "8706431785795792289": {
            "error_kind": "string",
            "string": "LS"
          },
          "8990147487291335284": {
            "error_kind": "string",
            "string": "TUM"
          },
          "10810264164364750393": {
            "error_kind": "string",
            "string": "TLU"
          },
          "11988312628175324067": {
            "error_kind": "string",
            "string": "LO"
          },
          "13265554733035650515": {
            "error_kind": "string",
            "string": "BigNum::validate_gt check fails"
          },
          "13462284035020069151": {
            "error_kind": "string",
            "string": "Denom must be > 0"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14875087550202939583": {
            "error_kind": "string",
            "string": "TLM"
          },
          "15690125140784469321": {
            "error_kind": "string",
            "string": "bad denominator"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBID1JwAABAMnAg4EDScCDwQAHwoADgAPgOYdAIDogOgEHQCA6oDqBB0AgOuA6wQdAIDsgOwBHQCA7YDtAR0AgO6A7gYdAIDvgO8BLgiA5gABLgiA5wACLgiA6AADLgiA6QAELgiA6gAFLgiA6wAGLgiA7AAHLgiA7QAILgiA7gAJLgiA7wAKLgiA8AALLgiA8QAMLgiA8gANJQAAAOYlAAAOEAAiAQICKAIAAwSA8ycCBAQCLgIAAoADLgIAA4AELgIABIAFJQAAgHQoAgACBIDzJwIDBAI7DgADAAIoAIBDBAAsKQCARAT/8nYYKQCARQQADYnoKQCARgT/////KACARwIAYCsAgEgAAAAAAQAAAAAAAAAAAAAAACwAgEkAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAsAIBKADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAKACASwYAACkAgEwGAAEAAC4AAAGATSgAgE4EAAQBAAABgE4AASgBgE0EAAEBAIBNAAKATi4AgE6ATy4EgEuATwEAgE8AAoBPLgSAS4BPAQCATwACgE8uBIBMgE8oAIBOAQAAKQCATwYAQAAALgAAAYBQKACAUQQABAEAAAGAUQABKAGAUAQAAQEAgFAAAoBRLgCAUYBSLgSAS4BSAQCAUgACgFIuBIBLgFIBAIBSAAKAUi4EgE+AUisAgFEGAQAAAAAAAAAAAAAAAAAAACsAgFIGAP///////////////////ykAgFMGAAH//y4AAAGAVCgAgFUEAAQBAAABgFUAASgBgFQEAAEBAIBUAAKAVS4AgFWAVi4EgFGAVgEAgFYAAoBWLgSAUoBWAQCAVgACgFYuBIBTgFYoAIBVBAADKACAVgQABCsAgFcGAIAAAAAAAAAAAAAAAAAAACgAgFgEAAEoAIBZBAAOKACAWgQAAigAgFsEAA8oAIBcBAAaKACAXQQAFCgAgF4EABAoAIBfBABEKACAYAQAUCgAgGEEABsoAIBiBAAVKACAYwQAOCgAgGQEADIoAIBlBAARKACAZgQAQSgAgGcEAGAoAIBoBABFKACAaQQAUSgAgGoEAGkoAIBrBABjKACAbAQAHCgAgG0EABYoAIBuBABWKACAbwQAWigAgHAEADkoAIBxBAAzKACAcgQASCgAgHMEACooAIB0BAAFKACAdQQAfigAgHYEABIoAIB3BABCKACAeAQAMCgAgHkEAF4oAIB6BABhKACAewQAVCgAgHwEAEYoAIB9BAB8KACAfgQAUigAgH8EAHooAICABABqKACAgQQAZCgAgIIEAHIoAICDBABsKACAhAQAHSgAgIUEABcoAICGBABNKACAhwQAZigAgIgEAFcoAICJBABbKACAigQAdygAgIsEAHQoAICMBAA6KACAjQQANCgAgI4EAD0oAICPBABuKACAkAQASSgAgJEEACUoAICSBAArKACAkwQAHygAgJQEAAYoAICVBAB/KACAlgQADSgAgJcEABkoAICYBAATKACAmQQAQygAgJoEAE8oAICbBAA3KACAnAQAMSgAgJ0EAEAoAICeBABfKACAnwQAaCgAgKAEAGIoAIChBABVKACAogQAWSgAgKMEAEcoAICkBAApKACApQQAfSgAgKYEAC8oAICnBABdKACAqAQAUygAgKkEAHsoAICqBAB5KACAqwQAcSgAgKwEAGsoAICtBABMKACArgQAZSgAgK8EAHYoAICwBABzKACAsQQAPCgAgLIEAG0oAICzBAAkKACAtAQAHigAgLUEAAwoAIC2BAAYKACAtwQATigAgLgEADYoAIC5BAA/KACAugQAZygAgLsEAFgoAIC8BAAoKACAvQQALigAgL4EAFwoAIC/BAB4KACAwAQAcCgAgMEEAEsoAIDCBAB1KACAwwQAOygAgMQEACMoAIDFBAALKACAxgQANSgAgMcEAD4oAIDIBAAnKACAyQQALSgAgMoEAG8oAIDLBABKKACAzAQAIigAgM0EAAooAIDOBAAmKACAzwQAISgAgNAEAAkoAIDRBAAgKACA0gQACCgAgNMEAAcoAIDUBACALgAAAYDVKACA1gQAgQEAAAGA1gABKAGA1QQAAQEAgNUAAoDWLgCA1oDXLgSAWIDXAQCA1wACgNcuBIBZgNcBAIDXAAKA1y4EgFqA1wEAgNcAAoDXLgSAW4DXAQCA1wACgNcuBIBcgNcBAIDXAAKA1y4EgF2A1wEAgNcAAoDXLgSAVYDXAQCA1wACgNcuBIBegNcBAIDXAAKA1y4EgF+A1wEAgNcAAoDXLgSAYIDXAQCA1wACgNcuBIBhgNcBAIDXAAKA1y4EgGKA1wEAgNcAAoDXLgSAY4DXAQCA1wACgNcuBIBkgNcBAIDXAAKA1y4EgFaA1wEAgNcAAoDXLgSAZYDXAQCA1wACgNcuBIBmgNcBAIDXAAKA1y4EgGeA1wEAgNcAAoDXLgSAaIDXAQCA1wACgNcuBIBpgNcBAIDXAAKA1y4EgGqA1wEAgNcAAoDXLgSAa4DXAQCA1wACgNcuBIBsgNcBAIDXAAKA1y4EgG2A1wEAgNcAAoDXLgSAboDXAQCA1wACgNcuBIBvgNcBAIDXAAKA1y4EgHCA1wEAgNcAAoDXLgSAcYDXAQCA1wACgNcuBIBygNcBAIDXAAKA1y4EgHOA1wEAgNcAAoDXLgSAdIDXAQCA1wACgNcuBIB1gNcBAIDXAAKA1y4EgHaA1wEAgNcAAoDXLgSAd4DXAQCA1wACgNcuBIB4gNcBAIDXAAKA1y4EgHmA1wEAgNcAAoDXLgSAeoDXAQCA1wACgNcuBIB7gNcBAIDXAAKA1y4EgHyA1wEAgNcAAoDXLgSAfYDXAQCA1wACgNcuBIB+gNcBAIDXAAKA1y4EgH+A1wEAgNcAAoDXLgSAgIDXAQCA1wACgNcuBICBgNcBAIDXAAKA1y4EgIKA1wEAgNcAAoDXLgSAg4DXAQCA1wACgNcuBICEgNcBAIDXAAKA1y4EgIWA1wEAgNcAAoDXLgSAhoDXAQCA1wACgNcuBICHgNcBAIDXAAKA1y4EgIiA1wEAgNcAAoDXLgSAiYDXAQCA1wACgNcuBICKgNcBAIDXAAKA1y4EgIuA1wEAgNcAAoDXLgSAjIDXAQCA1wACgNcuBICNgNcBAIDXAAKA1y4EgI6A1wEAgNcAAoDXLgSAj4DXAQCA1wACgNcuBICQgNcBAIDXAAKA1y4EgJGA1wEAgNcAAoDXLgSAkoDXAQCA1wACgNcuBICTgNcBAIDXAAKA1y4EgJSA1wEAgNcAAoDXLgSAlYDXAQCA1wACgNcuBICWgNcBAIDXAAKA1y4EgJeA1wEAgNcAAoDXLgSAmIDXAQCA1wACgNcuBICZgNcBAIDXAAKA1y4EgJqA1wEAgNcAAoDXLgSAm4DXAQCA1wACgNcuBICcgNcBAIDXAAKA1y4EgJ2A1wEAgNcAAoDXLgSAnoDXAQCA1wACgNcuBICfgNcBAIDXAAKA1y4EgKCA1wEAgNcAAoDXLgSAoYDXAQCA1wACgNcuBICigNcB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miUAAISMLQgBAycCEwQWAAgBEwEnAwMEAQAiAwITJwIXBBUAKhcTFy0KExgMKhgXGRYKGRkkAgAZAAAR4S4MgNgAGAAiGAIYIwAAEcAtCAETAAABAgEtDgMTLgiA1wARIwAAEfkNIgARgGIAAyQCAAMAAIAlIwAAEg4tCxMRASIAEYBYABctCxcTASIAEYBaABgtCxgXASIAEYBVABktCxkYHAoYGgQcChoZABwKGRgEASIAEYBWABotCxoZHAoZGwQcChsaABwKGhkEASIAEYB0ABstCxsaHAoaHAYcChwbABwKGxoGASIAEYCUABwtCxwbASIAEYDTAB0tCx0cASIAEYDSAB4tCx4dASIAEYDQAB8tCx8eASIAEYDNACAtCyAfASIAEYDFACEtCyEgASIAEYC1ACItCyIhASIAEYCWACMtCyMiASIAEYBZACQtCyQjHAoeJQQcCiUkABwKJB4EHAofJQMcCiUkABwKJB8DHAogJQMcCiUkABwKJCADHAohJQMcCiUkABwKJCEDHAoiJQIcCiUkABwKJCICHAojJQEcCiUkABwKJCMBASIAEYBbACUtCyUkHAokJgYcCiYlABwKJSQGASIAEYBeACYtCyYlASIAEYBlACctCycmHAolKAYcCignABwKJyUGHAomKAYcCignABwKJyYGASIAEYB2ACgtCygnHAonKQEcCikoABwKKCcBASIAEYCYACktCykoASIAEYBdACotCyopASIAEYBiACstCysqLQgBEQAAAQIBLQ4TES0IARMAAAECAS0OFxMtCAEXAAABAgEtDhgXLQgBGAAAAQIBLQ4ZGC0IARkAAAECAS0OGhktCAEaAAABAgEtDhsaLQgBGwAAAQIBLQ4cGy0IARwAAAECAS0OHRwtCAEdAAABAgEtDh4dLQgBHgAAAQIBLQ4fHi0IAR8AAAECAS0OIB8tCAEgAAABAgEtDiEgLQgBIQAAAQIBLQ4iIS0IASIAAAECAS0OIyItCAEjAAABAgEtDiQjLQgBJAAAAQIBLQ4lJC0IASUAAAECAS0OJiUtCAEmAAABAgEtDicmLQgBJwAAAQIBLQ4oJy0IASgAAAECAS0OKSgtCAEpAAABAgEtDiopJwIqAAktCAErJwIsBAMACAEsAScDKwQBACIrAiwtCiwtLQ4qLQAiLQItLQ4BLScCLAQtLQgA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AMsKLQIAAC0KDgEtCg8HLQsBBgAiBgIGLQ4GAS0LBwEAIgECAS0OAQcuCYBNAAEAIgECAS4GAAGATS4JgFQAAQAiAQIBLgYAAYBULgmAUAABACIBAgEuBgABgFAtCwMBACIBAgEtDgEDLQsIAQAiAQIBLQ4BCC0LBwEAIgECAS0OAQcuCYBNAAEAIgECAS4GAAGATS4JgFQAAQAiAQIBLgYAAYBULgmAUAABACIBAgEuBgABgFAuCYBNAAEAIgECAS4GAAGATS4JgFQAAQAiAQIBLgYAAYBULgmAUAABACIBAgEuBgABgFAtCwgBACIBAgEtDgEILQsHAQAiAQIBLQ4BBycCCgQMLQgADC4IgE4ADS4IgE0ADi4IgFQADy4IgFAAEC0KCBEtCgcSAAgACgAlAADLCi0CAAAtCg0BLQoOBi0LAQoAIgoCCi0OCgEuCYBNAAEAIgECAS4GAAGATS4JgFQAAQAiAQIBLgYAAYBULgmAUAABACIBAgEuBgABgFAtCwMBACIBAgEtDgEDLQsGAQAiAQIBLQ4BBi4JgE0AAQAiAQIBLgYAAYBNJwIKBAwtCAAMLgiATQANLQoGDgAIAAoAJQAA2NctAgAALQoNAScCCgQMLQgADC4IgE0ADS0KAw4tCgEPAAgACgAlAADaJi0CAAAtCg0GLgmATQABACIBAgEuBgABgE0uCYBUAAEAIgECAS4GAAGAVC4JgFAAAQAiAQIBLgYAAYBQLgmATQABACIBAgEuBgABgE0uCYBUAAEAIgECAS4GAAGAVC4JgFAAAQAiAQIBLgYAAYBQLQsHAQAiAQIBLQ4BBy0LBgEAIgECAS0OAQYnAgwEDS0IAA0uCIBOAA4uCIBNAA8uCIBUABAuCIBQABEtCgcSLQoGEwAIAAwAJQAAywotAgAALQoOAS0KDwotCwEGACIGAgYtDgYBLQsKAQAiAQIBLQ4BCi4JgE0AAQAiAQIBLgYAAYBNLgmAVAABACIBAgEuBgABgFQuCYBQAAEAIgECAS4GAAGAUC0LAwEAIgECAS0OAQMtCwgBACIBAgEtDgEILQsKAQAiAQIBLQ4BCi4JgE0AAQAiAQIBLgYAAYBNLgmAVAABACIBAgEuBgABgFQuCYBQAAEAIgECAS4GAAGAUC4JgE0AAQAiAQIBLgYAAYBNLgmAVAABACIBAgEuBgABgFQu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AgoqBAoIJAIACAAAxWwjAADE8wsiAASASwAIFgoIBC0LDAguAgAIgAMoAIAEBAAEJQAAvM4uCIAFAA0AIg0CDgAqDgMPLQ4EDy0ODQwLIgAKgEsABBYKBAgtCwsELgIABIADKACABAQABCUAALzOLgiABQAKACIKAg0AKg0DDi0OCA4tDgoLIwAAxWwBIgADgFgABC0KBAMjAADDtyUAAIC6ASIAAYBYAAMtCwMCHAoCAwAcCgMCACsCAAQAAP///////////////////w4qAgQFJAIABQAAxb8lAADmAwEiAAGAWgADLQsDAhwKAgMAHAoDAgArAgAEAAD///////////////////8OKgIEBSQCAAUAAMX8JQAA5gMBIgABgFUAAy0LAwIcCgIBABwKAQIAKQIAAwAAAf//DioCAwQkAgAEAADGLSUAAOYDJioBAAEFuBi3vusXfdM8BAIBJiUAAIC6ASIAAYBYAActCwcGHAoGBwABIgACgFgACC0LCAYcCgYIAAIqBwgGASIAA4BYAAgtCwgHHAoHCAACKgYIBwEiAASAWAAILQsIBhwKBggAASIABYBYAAktCwkGHAoGCQACKggJBgUiAAaA5AAIACoHCAkLIgAJgNgAByQCAAcAAMbPJwIIBAA8BggBASIABIBaAAgtCwgHHAoHBAABIgAFgFoACC0LCAccCgcFAAIqBAUHASIAAYBaAAktCwkIHAoICQABIgACgFoACi0LCggcCggKAAIqCQoIASIAA4BaAAotCwoJHAoJCgACKggKCQIqCQYIBSIAB4DkAAYAKggGBwsiAAeA2AAGJAIABgAAx14nAggEADwGCAEBIgABgFUABy0LBwYcCgYBAAEiAAKAVQAHLQsHBhwKBgIAAioBAgYBIgADgFUAAi0LAgEcCgECAAIqBgIBAioBBAIAKgIFAQsiAAGA2AACJAIAAgAAx74nAgMEADwGAwEmKgEAAQWmXwrRirhDozwEAgEmKgEAAQUnl+H47EhrfDwEAgEmKgEAAQV403WUnYctoTwEAgEmJQAAgLoLIgADgNgABAsiAASATgAFJAIABQAAyBclAADmFQQqAQIELgmATQABACIBAgEuBgABgE0uCYBUAAEAIgECAS4GAAGAVC4JgFAAAQAiAQIBLgYAAYBQJwICBAUtCAAFLQoEBgAIAAIAJQAA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CgIJAAgABgAlAADk8i0CAAAtCggFJAIABQAA0xIjAADTgy0LBAEtCwEFACIFAgUtDgUBJwIGBActCAAHLQoBCC0KAgkACAAGACUAANjXLQIAAC0KCAUtDgUELQsDAS0LAQIAIgICAi0OAgEnAgUEBi0IAAYtCgEHAAgABQAlAADomS0CAAAtCgcCLQ4CAyMAANODLQsDAS0LBAItCwEDACIDAgMtDgMBJgAiBgIJACoJAQotCwoILQsECQAqCAkKDioICgskAgALAADTwiUAALXrACIFAgwAKgwBDS0LDQsMKgsKDBwKDAoGGSIACoDgAAwAKgwLDQ4qDA0OJAIADgAA0/klAAC16wIqDQgLDioIDQwkAgAMAADUECUAAID1AioLCQgOKgkLDCQCAAwAANQnJQAAgPUtCwcJLgIACYADKACABAQAByUAALzOLgiABQALACILAgwAKgwBDS0OCA0tDgsHLQ4KBAEiAAGAWAAILQoIASMAANC4AyiAlAABAAgAIgICCgAqCgELLQsLCRwKCQoALgiA1wAGIwAA1JAMKgYICSQCAAkAANSzIwAA1KIBIgABgFgABi0KBgEjAADP+gAqBgEJDioGCQskAgALAADUyiUAALXrLQsHCw0iAAmAlAAMJAIADAAA1OMlAACHpgAiCwINACoNCQ4tCw4MDSIABoDQAA0kAgANAADVBiUAAIemACIEAg4AKg4GDy0LDw0EKg0KDgAqDA4NLgIAC4ADKACABAQAByUAALzOLgiABQAMACIMAg4AKg4JDy0ODQ8tDgwHASIABoBYAAktCgkGIwAA1JAAIgQCCAAqCAEJLQsJBhwKBggALQsHBi4CAAaAAygAgAQEAAolAAC8zi4IgAUACQAiCQIKACoKAQstDggLLQ4JBwEiAAGAWAAGLQoGASMAAM9wASIAAYBWAAkNIgAJgNAACiQCAAoAANXIJQAAh6YAIggCCwAqCwkMLQsMChoqCgYJLQsDCy4CAAuAAygAgAQEAAolAAC8zi4IgAUADAAiDAINACoNAQ4tDgkOGCoKBAkQKgkHCgMiAAGAWAAJDSIACYDQAAskAgALAADWLCUAAIemACIMAg0AKg0JDi0LDgsAKgsKDQ4qCw0OJAIADgAA1lElAAC16y4CAAyAAygAgAQEAAolAAC8zi4IgAUACgAiCgILACoLCQ4t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",
      "debug_symbols": "vf3ZjvU6eqWN3kse+0DsSd9KoWBkubIKCSTShbS9gQ3D9/6L4+1GrIWpb4amYp1EPIOU3slOJMVO//Wn//2X//Wf//df/vr3//Nv//6nf/4f//Wn//WPv/7tb3/9v//yt3/71z//x1//7e+n63/96dh/Sj/an/45/dOGpZCqQj4M3MWuKXZXMZdq17TzrgY4r5kb+rYDvz5PyptGN5rppALqRutwak77l+pJ46hO0ygVIwRtB2DUw6k6LaM2jHpyct/hdwx3m37HykoTidVByygXp2lUuhFCJeS+ze9o7tb9jpGM5r53gc5Y5p2mc6eVkrmt43DabjudVzqc3C27285ipWVU3K24Wy1O06hlp2HU3W3HQ2j4rw0PwXDL039tuuXlv7bUcj2O7LQt102Im1Bz2pbbpp0LQqU4DaOanJqT39v8juZ3dHfr7jbcbfi90+0t/43VldKRnJqT3Zt2ec4dNI1ydupG5XBqRtXddrlX2lbmptaN9nNZEqg6LaPhbsPdprvtPBJa7rbsunycoS8VNI1SdupG2d2yX1f83uJu1a+r+96xqVWjXdaEdglTOlOjHqBltEOv5G7L3Za5lR16pWG0Q690hqCWTTk5NadlVNyt+nXV723u1vy6tu/duVV2uRJCPECzOJ3p0hCW/XzUBRpKdT8fSu6W3C25G0Iv1Ix2aVI606UV0DLaz77SMGru1vy67vd2dxt+3dj37njU/XwI7XiA2n4qlM606juWbT/dSs0ou1t2t+Juxd2qu+1nQWkZ7dAL7TZAaRiN7ORu06+bFr6+w9x3ue+7PPcM2r67xPadkkrTqLrvbi2V3HeX595Bw2i4G8KC63b6Ke0Y7XLfd3lW2m77OUd7ievGLgdKOwQ7p8cuB0ruVpJdt3NfaOe+UHPfZiEY3X27hW8M9x1uZbrvcivLfOdhVmZKTmYF7aqSWZnFfXdIx86FuXNaabvt/Ji7thgFtIy6u3V3G+423G2623S35W479GOHYO10VnK33T8YDbSMsrtli/kqFqNVLT9WtfxYzd2alZzVq5OVnDXcd/cURgc1o+VuS93acRxO7pa0TJ40jXbJHgM0jIq7Wegb2lClZdTctycn90XNACuoGUAzO3WjHXql5rSU0lGcplHKTmYl7dKu1JzcCmo9IbdS3Uq18KXmVppb6YeTW+luxWOZPJZpuhWPZfJYol1VsvBlj2U+zEr2WGaPZc6HU3NyK8WteCyzxxItrJDHMnssc3MrHsvssczDrXgss8cyT7fiscwey7zMSvFYFo9lScnJwlc8liVXJwtf8ViW4lY8lmiJ57Fpx1KpGe28VHK34W4j3JbRbp2VptF+S5gFNJTqbiuUmlFyt+TX5ezkbsWv27Xe3M8q2mQhxENoGe08mgs0jXZJVHK36W7T3RB6oa6E1lnpDMHKm3ZtoVSdplF2t+LXFb+3ulv163ZPdbVNu64T2vEQ2iVM6UyXNTftEqbUjZa7LXNDO63UnJYRQi+038GOtBGvcorDcWeEYbjWuLaGhRauLa7FK+ex6z95qzx21OW1Ejh3vWzYApfdNtNwzM2xxAU1LmhxwZiOeN0W3E+h4Aq7K+yuUhyb34YmSHFkx2W39eMojik5lupYs2M7HEfcNuO2aXHrqNkV8xE4Hbfd1UHdaD8gSgjhBC5HvHAL4o1bMVxnuM7puErgMMxHDnQLGaMFghJuQQ9OLuFa4trigcxScNZGDEykY+N+ftMeTjlxOKI4KXbDgpKl2ByRPXugpaOCVUQgFYdjyYHhWsMVgyyCu99lGK69BE7HERZm/PAMCytcUcgU3W49/NqajkC/Fi89hh5NVKxpj+d01KyKGKhRhN0JnI54tBXDtYdrD1eJm2C4zrgWpVtw+a81ySzB5phhbBeChkonH0CUvh3e1lJgd8Q4XC7AbSzDdRyB4TrDFRmguBxXuC537XjgFacjHlfF4ZjDFXkhiCcgD2ANXI4S450OveXA4YhHRLEFLscRFkbcNuO2Ga4rXJe7jqMEut2R/NcGHhxFco1rS1jAM5R3bg48Q4rdETWjYg1cjj1cZYQViCK3x2P6QG4q7mv3WMqJ20LZNeJAbiq66zxq4HTEUKtiuOZwRVUhiKpCsTvWFBiuiKYifngCpyOeLEX8xI7mlGgKdkeJsWANnI4rblt+2zpyYLimcE1uAa9xiuUIbI41XGtcW8MCyu8eVeoYOVVE+VVsgcsRY9OK4Yq6RBHGdr0ujbEirj0fsnHICLrgdJQxdMFwzeGawxUZq9gdkbGK+OG5ERmrWAOnYw/XEdeOsDDDdca1yM2WNiILgQlxE0S+KWLsvm5EG6DYHUu4lnCt4YoIKS5HREgRwRkbUVIVhyN6FYrhOuPaGRZWuC6/Nh+YCTiAyxFxE0RlI4gy2QuwBi7HGq41XFu4ylwEcA9JGQ5HmZjowO6IzFKsjitcl19bjhQYrukIhIXzaTnHnzBJMoDTERWIIFo9xea3IS8EJbzAGRcsv6AdfgFeXBRR1gVl8gYYdlvYbXgggf3w23o6AqdjTYFxG2oCwRm3zbhNkm/jSH7byH6bzIAJNr9t9LhteNyG2N2PiLx9KA7DiSTZI11DXkQEESHFcM3hmsl1OZZwrXEtslCwxa8hHQRR+hSnI5pxxfiJGa7Tr11osPeI3JBqew+/nYgLdoFZeOYFJWQL2BxbuKJwybUoBIrDccQFEjLgjAvQqxBjyM2N5ytfCrTgnOlfA6dfgFpZMVzxiIwDOBzRq1DsjhIhwRa4HHsYk1QHormdGdgd0XlSDNcVrstdE/q0iuGaUuAOzmwbUaIUa+B0LOFa49oaFlq4trgWz8WcG/FcCOK5EJw5cKfkKhtRVex3yBOnobzrKQ7HFK4pXHO4ovERRF2t2AJ3XqydsVJXK05H9B8Uw7XHtT0sjHAdce2OZt5jCxMVtOE0RK2suHMo7zeJE5sjppAVw7WEayHX5Yh5ZMXpiJnk/aJ74nDsKbA5jnAdce0MCzNcV1wrk+Rn1XbWQMURcVNcjpgU32+AJ8K1bsQksuJ0rOFaw7WFKyIkiAgpdkdMj+8XvBNb4HKcJTBcl1/bjiOQXP3ahlnlvTBgopOe9zvkRCddEVPHii1w+W0yww9EXgguR9S0ikhUQVkEABzVEZm1ccl8vGBtjs2MLQzrK6bumKvjWI7TjSUP2TmadQS6sewhW5jPNXRjJUKGAV3BehyBbgx9DcWRAt1YKx7eVt1Yi5D1w8PbPbNWj5Bh4YzidGM9QjaqhxfTc4oRMry0KWY3NiNkmOVSXG5sRchWPwLd2PKQnTU8qo29DuNkWXii3IIzuWdyL+QuoVKewbIMRRlhHGBZiqLcgyXEyuQ+6PpBdia5T7oeleR+bd/cnNGmnbU4WAqtuEspEJZkBaOdMM5hJ9e4F0N9xoPuXXGvVMTKJe7FpIZxj3ulThSuR9xbcyGewaUH10TcPL5SxykjzMqLeTk3xF0Zy4SUx0E8nXsJ++gyO4dNTHEbp7CJcRjjEWEeM2wOCie6osYtbE4KJ0bIjXPYXBROWcKkvNxmOiKcCV0t4z6CI5xJlvcYz+AIZ8JLoXPYzBHOhIk543kQh01pkpVbIg6bNUX4MUVlTOHEq5XxCpuNwolRSeMeNhuFE+9P51ylcA9Gs2JM7pncM7lL2JQr8QqWuHfhGYz6xLgHd3LvdP0gO4PcJ12P+mSvUjpZyp4y3NfmIWkLdyxjNEbDpTzCDsbvlGeKe2eJe2eNe6c8s8I9EYfNKc/jEp7BM8K55LeE80Ec18tiP2V57oQl7puz1O3KtQfLMwiWBXPGK1jKuXCn60cOnh62swce16O3bVxL8KLrV4RNusPKLa6XLqpxhE16m3vgdfNyrlIPKM9gSU/lESxlWzls6nOnTDYL2ZR4KW+bVRjPuHEj3uHcK9JORnoaz2CkrXEPRjob072TbC5yX2Gz4Xnfg4cny4JOZVw/hFdwJnf01/R6dNiU0V7s0cLNPVjivoR7XC/xVcay0QMsyzuVyR3luSqPYPTHjLtzRz/BuBGv4FSIZzDqhFaEe3BJxFhK2sGoN4wr8Qxu5N7p+k52BrkPul7SAWkodZoy8ld4IE+Nd/rs1XEnow437sGZ3DO5F3KXha7KK1gWuypj0SzyceA5NR7BeGaNyX3Q9YPsTHKfdD3qsT6Fl/OU+Aqjn6aMenIk4Uq8ggu5F3Kv5I44KqOdMh7BiOMe99rcg5GnxjV4kvuk6xfZWeEuC82NYWc/jyVJHJtwC0YfyXgG42VI78XbkPEMnsQSBnCm38XyJGPkqTLaIGEZmzAOm1gSpIxlOs5hU+pk5RFhlnrPOGxieta4JeKwiYUnxjlsdgonlnoar7A5KJyjRfgxI2hM4ZS3fuUSNieFc64IPybBjCmcmI0yHmFzRTjPJu4gnsERzopRP+cVHOGsGIozXgdx2MytBPdEHDaxwDvvlVlJlng7z+BE7oncM7kjbMqol4x7MOK+12ptbsQrGGE2JvdO1w+yM9idrke9NKswwrzr5yrlVtyrhFlYwiPc4946U/CKe1uKe7F0y7jFvZgBMZ5xbz/i3p7jXulvK/e4tw+6F/0HZbSnxmFTyr/Ed0h8hSXMwpUY/RxliTtYxkSU0e4oox5WnmFfxkWEZWBEGW2ocdiUsRFwO0oiXsERzrP7k4PTQTyDRwmeiThsYtzYuIXNHOFsMoagnMNmoXCWGeEvK2xWCqcMcCr3sFkpnC1H+FsJm43C2VaEX8uPMIVT+iTGYbNTOEdNxGFzUDjlXUk5H8RhEysQ8l71eDLe+4xH8CD3Qe6T3CVswqjHjBvxDudeB5matKfGMxhhNib3TNdnslPIvdD1aHP3vMbmHea9rvJklFt1R5jBXcYulHMORl2n3GbwoHsX3StxBCfkr3LKxN3C02WMVxlD1cryW8Kdrh9xfUZ/0ngFlxE86foV9rFQzjjSp2OZsDHqEGGsOHOOsGGhmfGg62cijrDJc6FcI2ytRdjkGRGWZ0Q5RdhkrGwO4RaM/pVxJZ7BUjcqj+BBNqVOE55kc5JNqYuE0W9ZysNZ6nBjhH+BJT2VK/EMlnKo3IML3VvIZiX3SjZ3/6Tspbkn7/6JMbbIHUW4BQ9yHy2u322x89hcwbtcOcMdeTSP7NdjTt25bu7CKziTu5RnYfSrjWewPOPKPRh9UeNGTDbRhzRG+iCtMO/uPIJnJib3Re4r3NfOd+cWLOmgvOO7V6huXsG7nXIewYXcC11fyU4l90bXN9hBvmDhlTHiq7yfWeddTva82sm7PnduxgPba5zJPZG7xFF5BksclXfYMLciS6+ce/Au287k3uj6RnY6uXe6HmUbcysnz2DEVxmbPo13emJ+ZGAbjvMMTuSeyD2Tu8RRePc9nHsw4ojxYVmQ5byCkafG5N7p+kF2BrvT9XiWMT48MHZXMIY2MHZnjE2txiN4tzt6L6aOjcsI7sQSBmH63YYtsMrIU2VsfhXG2JFxCpvobxvPgzhsYsxZGdv6nMPmoHBObNhVLgdx2Jwrwi/PuHHYxM4B4xE2V4RzHqUF1xIc4ZQFJMapBkc4J9baGc+wmSKcsqjCuIXNHOGcJa3gHDYLhRMr1J3DZqVwYo7MOWxWCieWnBnXgzhsNnk2Gxh1717Vuxl2Bngl4u7cj0RM7oncUyNewWiDjHcYMD45u2zcVh7Bux/iTO6Nrm9kp5N7p+sH7CThHWaMG0/0JdQdS7CNJTzCLe7FIQ/GM+7F8jbjXIhnMOoi5ZqIm4dnSryEkdfK8lvCK65fR1yPVWbOM7h7fBeW6RrnRLyCB12PTfvKaIuFU4nrUx3BzcO2sLTJOB3EM7jT9SPCho1/yiXH9aVE2EqNsBWpk5twJV7BUjcqj2DEy7g7Y5mGcyMOmzUV4hkshxMo92DUe8YI/xBewaivjEewlEPlRkz3drLZyX2QTdQVmMtYFc++cQ9GXWTcnLFKyLkSz+CUicMmtt07072Z7i10b6F7UY/VKlyJV7A8O8ojGH0V4x48yCbaUGOyOckm2j7lRTZX2JS60bgRh02M2TqHzZ4zcYQfczTOZJPSpFOaYI7GmNKkU5r0TjbxDGJOamGOxnkFT3Kf5I76UxjzNWWvmD8ZbYFxD0a+G69g1PnKqA+VUae1LLyCUbcrow9gTO5or5XRXhtPZ3mHwvzXmhJm5R6cyT2TO55f4xWM59d4Bjf6LeSFciebg35rkPsk90m/tSgMK35L2gXj+C2M/ziTeyZ31FHGLbiSeyX3Ru6olxrKFcYznWcw6qKGOhCr+JxH8CL3Ze75kPcgZbQpxpV4BedCPIML2ayZmNwbuXf6rU5h6PRbg8Iw6LcmhWGS+wp3rE9w7sGJ3BO5Z3KXMtnBqCuMVzDqhz2XunkGo34w3nHfc6Ano8407sGoM43JfdL1k+wscl9xfUY70pvwDEYclVFXGO+47DnQk9E3M57BldwruTdylzgKow407sFyEFASbsQrGHlqTO4rrscYoDO7x/WYMyp7DvRk5KnxCkZZVUZZ3XNSm3sw+gbG5N7JvZO7xFG5Eq9gxHHPSW2ewchT4+6M8XznuF76SMbknul6lOE9J5WPjjjOJDyCUbco43k0rnEv2gJlvA8KYzzQeQbT7w7UscYrGPWPsNThyv0gDpsyvqRcEnHYXMvDnI4jB0c4k9QzyqMERziTjG8o17CZIpwJ60WNU9jMEc6EZf3GM2xmCifmH41b2CwUzpoP4rBZKZxY2+kcNhuFU/psyuMgDpvyzqhcE3HYxNpO4xQ2B4VTxmCVZ9gcFE7pA+w5nc0tGG2lMblXcq/svoJRLxnPYIn7Eh7B6BsYt+BJ7pOuX2RnhbuMqxhvO+sAo+zt+Z2TUW7VHWFWRniUp9+bcViDcU7BZQW3EYw4KiN/jckm6iKE53zARjDqWGFpB43j+lTiejl4ThlpIixtkHKN63FgjTHGE4RLpE/G/L4x6hDlQdfPRBxhk2dBuUbYaouwyXMhLM+FcoqwyTOiPA7iCFuX8l+FZ7DUycojWMq5cg+Wcq5MNqVOE65ks5JNqYuUEXdh1J/GlRjh72BJT+URLGmr3IhX8KJ7V9gcRyEOm/LOsueSsqwrM0ZdYVyJV3Ahd/RJlNGWGZPNRjYb3dvo3k73drp30L1ou/e8Z5b1Zsaox4xHMOo04+485VlQrsQrOBXisCnjusZks5BN1I3GZLOSzRrhl3bWmGz2REw2O9mkNJmUJjLHZEzh32lyDvYIN2esT3Oum4vwCt5p4jyCM7lnur6QnULula6vsIMyifcp416CRyLumxd4HsQteJH7cvdyHAdxJZ7BEkflHbY953XyznfnHoyDII3JvdL1lew0cm90fYedJjyDEV9lHMtpvNNzz3mdjMMtjacz5picyT2Ru8RRGAddGvdgxHHPeW1uxCsYeWpM7o2u72SnsztdP2Bn140F7UjNSB+spVGWgzuNR/Cu0/RebE40ziO4EUsYhOl3MUZnjDxVrjV4hf1+hE3MBRiPgzhsYu2NMtbeOIfNQeHE2hvjfBCHTezmNl6JOGyuFuHHscPGEc6K/WXGpQRHOOVoXmUcImEc4aw4zcF4hM0U4ZRja41r2MwRzor3R+MUNguFE2cgOYfNQuHEeLJz2KwUTpwWZFwO4rCJte51z7FmOfbUeQRPcp/kvshdwgbGWnfnRrzDuedYT95jPs4zGGE2JvdC1xeyU8m90vWol/ac7OYd5j13djLKrbojzMJDwiNc4l609cY97h0z7kWb67yCkb/KORN3D8+UeAmjjlWW3xIedP2M69HPd17BNeKLd1XhhndV43QER/o0vLcaow4Rxrpu5xlcevCk61ci9rDJIZPGLcKGc0aU5RlRThE2PWxZWMp/E27BUicrV+IZLHWj8gieZFPqNOFFNhfZlLoIjC3ltSiPYNThxgj/AEt6KlfiGSzlULkHV7q3ks1G7o1sNticYPRDjEcw+iTGPXiSO/okxit4kc0VNrHvz7kRx73YmO5M98oR21W4BaMeM67EMxhtt/EIbmQTfRXlTjY72UQ7rjzI5iCbqBuNyeYim4vCv8JmPwpxhB+npjmHzU5p0ilNeiablCY4drrueeosZ1TWfRxUlkMqa8VzhDkmZ3JHOalNeAYPckdduk8mz7L+1hjPiPFyxrtbrVN4BCO+xrC5wKgzjUcw2nFjckebbtyIVzDi25LwCN7vJs773oa0wvua8wxGfJVR17UivJylXTAmd5R55ZyIe3Ahd/RRlSvdi3xUbuQu8RLudK/ERZndKWyT7Eyyj7beOMKJ8SjnRhw2sZbPOWxi3so5wiztWkMZxklpFXMlcgCpMZ7ZNoQr8QpGWTUewXhmjWFzlz1Z51wxn3LyCpb8Uh7BknfKjZjuLXRvoXsr3Vvp3kr3Nrq30b1oK43JfZDNQTYH2Zxkc9K9K+7FmQbOlXgGp0y80xBzQ13euYwb8QpGHWVM7ijbxghbB6Pe3gePZTnB1RhlwBg25XqUc+MWjLbMeASjbBtPZ+wvc17BaMf3cWNZTnN1rsGF3NF2K6OPZzyDG7kjr5U7uXeyI3GswvjdKbyC5cMRyiMYeW3ciONe+RSGcdyLs4CcGzHdm+neTPcWci/kXslmJZuVbDa6t5F7J3e0U8qD3Af9FsoA5u861hEZowwYT2es+XRewYi7ck7EPRj9t5GFRzDia9yIVzDia0z3drq3072d7h1076B7J9076d5F7ovdw2Y7CnHYbCkRk3smd0kT4ULuJX4Lexwq5kl7kzgq9+BB7oPc8U5kvILRLzWezjhfwnkEp7ApfS1jci/kXuK35D3UmH6rFWL6rU5h6OQ+yB3jAMYteJH7CvdxHMRwb2C86xnPYDynxggD6rch+SKMOllZ8gLPEebdjCWcyuS+yF3SHzylLCmPYLQpxvFb0kdSLgdx/Bbm7JzJvdFvNQpDp9/qFIZBvzUoDJPcJ7mjr2u8nGXM2ZjcE7mjzhxoQ7GHy1jqDeURjHoDc+6yl8EY5UoZcZl4pmSc2bgHo/+DuVHZy2CMesB4GA8cT1gxByT7F5xbcCZ3vHcoo71TRju+j+Hb3IPRjmP+dMj4gzLatb2HKMt+BGO0a8ZIhwnG8248naUPYwz3BUZ9pYy+qDG5oyxhTnNgf7rztrmS8AruZH+QTZQfvQbPCOb4BvY1O8NmEV7O+PhHxfzawHobY/m4UxPeYca80sjygSflHixxQTpkiYtyJZ7BeEaMyR3tizG5T7oe5UoZddRCOki/Qhlth3EPxqdLMHczsGe/HUm4Ea9gfJ7KeAQ3ct/xMu7k3un6/by0Iwv34Enu+GAL5noGDhdsRxXuzlh77FyJZ3Ai97SCM7lnun7XCe1owiO4kjs+RIN5pSGf4jKewfhQi7LES7kRr2B8oMsYv4uyhPGcdiB/MYbTMMc00L63dAj34Eruu+4y3mWvpSS8gju5I8zGIxjhN27OaNMb5qEG2nRjfALImNwrfgt5ivbaeQZ3cpffrcI9GB+3Ma7E0xnrbJ3JHWloTO6Zrs/xW2ijNTw4C8UYzwLm1Ab2Nhq3Hixpq4x7kb9D0lYYH2IyJneUeeO4F2MdzuQu8RLOibgHF3KXeAlXulfiItzIvUXYML/sTPbHQUzhHBTOSTYpvhj3cA6bmF92bsRhc0ncp/AIljxVJndJBzxHaN9bxjOCea6G+cSTV3An907uyEdl5CPmE+Uc4rY/A7GXDLRg1EXKu0/YMDck5wsbF3LHs2zcg/EBWIyHy8nCxp3cO9w7GPliXIlnsIRfuQcvunfRvSvuxVkKznEvzlVwrsR0r6SDMrkXslnIZiWblWxWurfRvSi3yp3cO7kPch/0W5N+a0Z6JqlndvmRo4mdR3Ai90Tumdzl2RRG+2vcgiVeA4y6RVnyWrkS0/USL2W6d9K9k+6ddO+ie1fci/W6zpU47sWnPJ3p3kz3Zro3072S7xMsea2M65fwCkYdZTyCUUcZt+BB7pImwpPcJ10/6bfQRmPeU/YeKmNdgXMPRvk3rsGZ3NEHUy7kXuj6Qr+FfgjmN6d+JFQYn5IzbsQruJM76gRjdqfrUVcb028t+q1F9664F+MYznEvxjGcGzHdm+neTPcWurfQvYXurXQvpU+j9GmUPo3SBx8cMMazU7LwCEY5MW7EK1jKiXK4Y52hM7mnQhy/1aMfMns5iGGnCK/gSu54Ropcj+eioO7CnibnHjzIfZD7JHeJr/Ai9xXXS7/LOH5X+l3GMxj1QD2EZzDaQWXkEebLpvSpMC82sU7AGJ9/NN6/W8U+2jVjcl/kjvAL42sMzuSeyB3lVhnPsnElXsGF3PEsK9dMHGHD2RHOFIZOv9UpDOiTYF5vTkkH5Rks6bCERzDy0bgRL2fsk3KOe1dKxOSeyT2TeyE7hezX+F3sk3Jmd7q+kx204w3lBOegGqPuMp7BeLfC/OPCOg1nckf7hTnHJf0xzIUtjLc0zJUs7Jd3JvdG7njulNH3MCb3Qe547pTx3Bm3YPTHjNl9OcunWo0jbPK5VuMIg3yy1TjCgPV7DXN2Sz7caryCJR2W8AxGH8y4B6MMG1diunfQvYPcJ7lPcl9hB+vVneN3M8qqMblnuj6THdRF+zs/e5lqD0Yda7yC8Q6LObKF9fANe7KW9MeUB7kPcke8jEfwIvcV7kU+4a3cg9HfMG7BmdwRR2OEYYDR7zIewXgHwZzOwl4qYzynxpV4BqPMG9O9g+4d5D7JfZL7Ijsr7MuYj/EKTuSe6PqciWEfeY2vEzo34hWMcm48gxu543lXRjuL+SnZY24snymuwtsOxvyX9LWMyX2RO8qAMM7ydSb3RO7yIV9h+SyzcgvGM27M7isYccdY+pI+lTKecWP8FuLeJO7KjXgFSzooj+BJ9066d5H7CnfsJXcOO9KnMo7f7fIhY2VyL3R9ITso/xjzX/iovDHKv3ElnsGoB4zJHfWbMWyircH+cWWc2dUwL3ByD07kjvzFmP/Cub7O5I5623jHF3MBC2dzOZO7xKULr2C0WcpoZ5XxPGKOYGG+yZnckReYF5BvYxhncsczaIzwI/2npL8yuaOPhDmCJX0kZbQpykhn5clM16M9Nca9TXg5Y47JGe6Iu4w7Gc/gTO6Z3Au5o4wpI47GPRhlzLgRUxgkvsr0W4N+C/XJniPYWxlwbwJL+JVHMMqScSOmewvdW+jeSvdWurfSvY3ubXQvPl6/5yOK7B93XsE7Xn2P1RfZP973mHyR/ePOcO/gBfchDHekA/pIfY+lbx7Bu/50JvdM7pncSyJuwXvswrkSr+BGYWgzuNNvdfqtQb+16w3jSb81KQyTfmtRGFb8VqZ0wPhVT0hnjF859+Ddl3CuxDO40L2F7t1lw5ncpZxLGFD/GM9g9CWMe/CgewfdO+jeSfdOunfRvYvuXXFvORCXLNyD00GMdOjCO80TyluR9FGGO8peKXAX+7tO7hnpgDGunpPwDEY5MSb3Tu6d3He959yDd9vq3IJ3OjhTGNZyxrpr5/gtnM/mPIJzIo4wYIzLuRHTb1E6VEkHpHOVdFAewag3jBvxCh5076B7ZyYm94WyKmHY/Q3n5YwxLucRnBJxI6Z7M92b6d5C9xa6t9C9FXGpwiO4JWKkA8ob1l33vIRb8H52ejmEt3sR+6hPShaGexFewSgnxuGOMS5nct9tjfMIRr1q3IORDsYRBpzn40y/Vem3Gv0WnhflTr/VKQyDfmtQGCb9FqVDl3RAOndJB+XpjHEw5x6MesO4EtO9KBvG5I56NRfhHixp0oRrMMqDcQ/u5N7JHc+I8QzGM2I8ghfZkTIAxjlvxukgZne6PldiGwM8Ge+kxiO4ITyob6eEGXUs1lH3grK9ZBwe7kvG4ZUr8QzGu6Ex3VvoXtTbNQnP4D2O57zTsyIuC+lfuzDcxQ7Sv07hFozn0ZjcJ7lPdl/B6OcYT2M5N8N5BKOO2mNom3sw2nfjSjyDUQ6N6d5K99YW3Mi9weYhPIPxbBr3YEkTZbp30L0on3vsbnMPRrtmvO/d43ibd7rtMa6SsGap7zXqm+GO9MFeV+cZnMk9k3sh911WjdHnMe7BSBPjRowwIK0wPuY8g9G+G/dglBNjunfSvSgnxuGOeczeDuEejOfXuBLP4Ez3Zrq30L2F7i10b6V7K93b6N5G9za6t9O9ne4ddO+gewfdO+lelJm9xvtk1Gm9CcMd5QRjbr1PYbgj3bC2ypnc0f8Zh/B2HyiHOPPfbOLZ2etyS8I4mzPcCxh1yKjCLRhtujG5D3If7L6C8a5kPIP3OJvzcMa3Wpx7cDqIG3H8FtZZOcdv4RuvzvRbNRPTb1E6VEqHSumAtVjOFIZBvzUoDJN+a1IYFv3WijDgXEfnRhy/hW9pOcdvSX/POH4LZzk602/VREy/1SgMjX6rURhQ5gfKGMbKej+El7P004zJPZF7IneE33gEI/zGiBfq0i75OIXhjucC+4WdyR1t4kzC232KTdRjMwvv8Ew8F9LvmlV4OeMsI+ed/hPpIH2tieca37rqcwivYPSdjMkd/UnlTveizlEe5I7nTnnSvXjWlBe541kTlr6TMp4vY3bfYVtIH+k7YfwkYc6xL6QV5hz7KsIzGO8OxuTeyL2RO+pY4x6M+Bq3YLRBxhQG5J2yxB1lA9/d6Av5hTNApC+XpB+1kF/SjzImdzzvxisYz/vqwjN4kjued2U878bdOGOfmrOHLR/SjxWW9xflEVwK8Qyu5F7peumrC6OtX8ISlykM9wWWuCiT+67Dx15nu3lu3uUk45PvY6+tLRl7zMdeW7sZ7g28n4uBsbWMsaw0xH3XRc4zeJcZ5xWM76Mbk/ug6/c7uPF+lhPGRrJ89V0YY1POIxhfsjfuwRJ+5Bf2eQ2M+2WsmzLuiLtc32fwDpvxTMQ9eNG9O8zO2w7GsuT7lcb7+R0YI8qYjzPO5I701+t3mXEem5FHOM/QGe7II3zM3a5HvIxr8KBrBsKGNMdYkDO5L6RtF95lAGNTGeM/zisY6a+8+zzOI3i3Ec7kXun6SjYb/W6nezvdOyg8+7kwnuQ+6XqKC/bLO8e9WF/tHOHBOczO5F7oeooLxmSMG93b6N5O4dl9Nmd2p+spXjj3Q8s52nFnlEPhVIjJPfdgPC/G5F4r8dqMZwfzXM7k3gvx8GetyzMlPA/iFrwScTynmP9ybsQrWOKCZ3BIXJbwdsf4oZwtNiTdcLZYkmdh7GfHeQWj7lJGvhi34Enuk66f0xnt+MBYYkY7PjBWI9+pHBnPGtZpD4zXZZyX2OVydE8Up6MM+gkuR3QBFcO1x7XoS22UY6YGhrAKpmkGhpUKlhYbo0oxXsGoUpR3sjjHvZjmGBiWkaOcjHcz4TyDO7mLnQlGUcGrfcFr7KhZeAbvLoTzcMZrrDO578fZOFdici/kXsi9knuNMODIXGf6rd1FNB6wk8CzEM9gNNm1Cg9nvHI69+BE7kWa2iZikqiFhbS2SGu8RrrohcUksVuOUwwIFHkX8qNTxCSxCgvykfbDBfukTGI/0uf4Bn4H6zJOIT4FHQmMVpcqkTMxSTT2aezT2QdNiYnBPoPvkZia4BCgPRkYMC+YFDCBE/9DsE9in8Q+ubBgn8L31IMFhQBD/yE6iY57MOJfmvTMTCwSkgYmBomZWXQSi01LgojAqowQ7JMOFhJQPCo9Hywaico+QxKkiFgkZmExSKzEorEgA+MgnyEBNcE+WULQREhxwSODhsdFrSwWCS2jQ8Qkgd6Oi05iHCwqCzYw2fRkn8WmF5nGsZYhKgsyMFNmwQay+OA5xcbhEJJuyO0p0ZaKfUq0VXT2kUdT6sYplZCJTkJqJBOVxSSx2MAiA0vKqAn2kdxWIbUlehBlyVuOCn2YVLDPYJ/BPpI/JthnxT31kCwx0UikxIJ9Mt8jCY8+kHwPOElnpGKRRZLeSD2kiKELUnGsySm6CKkCGsRMZECeLBUaahUrRNJQi9CnXsUXH75HqkEVlSKX6iLRKgv26ezT2WcUFuwz+Z51sKAQ5COx6CTkwTAxSOTCYpIolQUFJ3O0MQoegn+0c3A6/+hgn8H3SDUohaJoqLOIEYWiyOMshQLnilihwAuqFQq8obqBSjlX2sGCcrv0xIKKZRnsM/ieQSWkSi5gHly+v+wCL2/yllyx6tOF5ALemWuVXNB7pL5WIa0MXoPlE84uGvtIfPQeqbhMDLpMKi4T7CPtqd4j5c1EDYEFniEooNqNMCHxQf5oN8KE+AyIQgGVd1UXFJ/W+LImoZ4Q0jKZYJ/BAZ0HCwnoErFILPKRtlHGaau0jTLQWaVtNNHZB8XFRYdAcOTlzEUjseQe/Ki0ZjKIWrEQ0X0K+6CEyPhqxVrEEIuEhNrEJDH4nsHWJvtM9pGAYiC3SpslI6dV2iwX7JPYJ7FPZh/UOy4Wico+lX00ciomic4+nX0Gh2ByCCb7LPZBdSuiSQvogn0S+6RJIhcW7FPYp7BPZZ/WSfTEYpEYlQX7TLY2+XcW+yzySZSNLVE2tqTZWCE0G1U0EuVgwT6VfSr7NPZp7NPZp7PPYJ/BPhptFZPEkoepiRgh8KYeQnw6hD6aKthH00AF+xT20YdWRGUfTQMVknMDokmeThGLRGefzj5Dor1EoLrFaHvL0s0zwT7SBRWhb/hNuAdjwMi4Ea/gXIhncMnEZLPSb1WyWckmBviU5TnFLHSTUWEX5CMNskw8NmywCDFIFPYp4oPfwYRvktnKhh2tSaYQm7S0MofYqhRLE+wjxRLTiK1qQFX0EO1ILKTFQC40eeYw99iaPHOYcGwy8Cszjk1ey00U9pF6FJOOcshpiEZisI88P5iQbDLQa2JWFuyz2GeRD044DTFIyMNkopOQh0kFnp+KoZaGOVoXKOQm0Li6qCwWicU+i3wwPRtikkiZxSCRE4tOohws2HThH0UdjwOrtxgkJKYmOglko4vGAqYxutLkTdzFJDEzi04CZdQF+cibuIvKgkxL38UFG8hsIDcWFGp8zDwEm65surLplliIaTwlU5NKRWUxSUhBMsE+mlR4mLAhI8QMgW2oCWfubjFJaIKo6CQ0QVRUFmygsIEySFT2kQTB4FXD7owQjYWkNZ6spQmiYpIYmcUgMdlHyw4qSBklcCHWdm3ZD02dCZESC8msBSEJgqGWLn0knFxc5ATVhKOLixybGgIG9gbsPZgnBqoIMdAg8D6HM4hPIUMGh5hGN1xmn/shrzwmKosZIsn7j4lOQoZATLBPPliI6SJikZA3VxXy/qNC3vQwBd6TDFFhbrwneVnFRFtP8rKqQpt35IL0d2ReuOuQgYlOIrGPhk2EvKiZGCQq36OhVsEGGhtobKCzgc4GOhsYbGCwgckGJhuYbGCxgUUGCidIORoLMlBSYcEGMhvIbIATsXAiFk7EwolYOBELJ2LhRCyciIUTsXAiFk7EwolYOBELJ2LhRCyciIUTsXAiVk7EyolYORErJ2LlRKyciJUTsXIiVk7EyomIdXku9JFRUVlMEj2zYAODDQw2MNjAZAOTDSw2sNjAIgM6oGKCDLREBhqnTuPUaZw6jVOnceo0LmKNi1jjIta4iDUuYo2LWOMi1riINS5ijYtY4yLWuIh1TYMlQgaV0BR0qZFMsI/UoyYWCR1UUjFIVLamI0wq2EBjA40NdDbQ2UBnA4MNDDbAJaRrCZFoy6iuiHEcLCYJfX5UDBJaQlSwNS0hIgobKGygsoHKBiobaGygsYHOBnYhnxjz6/hSs/MI3r3miaHAjuUFzuS+B4CcV/AOxsRYn5zsatx78KjBE7yEtx2MPssJrhODz3KC68SQrpzg6kzuidz3MM/E8HTH7lpjxEW5Jg8DZmNmkXv3m5bxfn9x7sG72XYexgOdKucVjLApZ9iswo14BRdyr3R9ZXe6HmmOvvbADlnjnokR/g4emXgEz0K8gpEXwjiF3jlsopvlDJsTnDNxDy7kXuj6Su6Vrm/43SZciXc40UEdGH8y3u2Ecw/eDYPzCN4tqHPYxGnzxgk2s3AlXsEob+g9D4w5GUt8lRGeAkY5NG7EKxj5a0zuvRKT+6Drkb/ocg+MMznPYOSvME5sc27ByF/jsInpH2fYHOBSiEewxFe5Bzdyb40Y8UK6FclfYclf5R4s+as8giV/lcNmlfwVRv5iB9DADgXnFYz8NZ7BhdwRX2XEtxXhEbzHEpxnMPLUeAWjXlKeZBP1kjLqJazhkVNhlTGY5dyCJb7K7L6CJb5DeAWXGow6yrgHI0+NR3Anm30Go13ADqOBqSHnFrwS8XBGX8V5BqdKvIJzIyb3QtcXslPJfqXfRRx7Eu7Be5jDmdxR9xrPYLSDxuS+6HrEVxg7Rp3DPhaiOFfisIkdo86IC+ptrIp0bsGSv8qVeAajjjJGOFEmMQ/nPIOR18rIa+MWjLw2DpvSbzGGTZRVjHQ5j+CciFtwOYgRHpRDnFrv3IIlr5dwD5a8Vib3Qe54fpUnuUu+K++4YBfYwK4H5+GMYS1nckf9bNyDM7kj7sa7zGOp58BJI84zGGV+KI9gpINxI17BqMeMyR1tkzFsohxidGpixH9iJ4XzCkYdpSzxUu7BaGeNyWYtxLDZwehLGM/gTu6drh/kPuh6tDuY5Zj4as/EfMPJwxmDVM4zGM+p8QqW/BIuibgHI48wNTHxdR5j5JExuXe6vpP7oOtRVjGtMrHeReOVpHwKS/lUHs4YxXJuwaiXjLdNTJpM6Tspo14yHsGIu3EPruSO59QYNhMYzyBmUeRUW2O0ocYjGPEyns44vdY4HcQtGGUSKxMmdnEao54xJvdK11dyb3Q9yidmjiZW3zqPYMk75R6MegbLGSYm6IxRPo2HM1bdOs9gyS/hfBC3YOQRlkFMnNRhjLrUuBLPYLQdxjs8WMwwsV7GeQbjGcSUsZxAa4z+rTG5L3JHngrjRA7nEYy6FHPNEzN8xoi7MbkXckc7YryCK7lL3IXRD8TKlImhHOdGvIIRd2PYEcZzaryCV3PGOlvnHox20zhsYhenM2wusMRReQZXcq90fSP3Rtfvumhh0H/ixDPj3UY4r+DdNzDegzTO3Rn9IucRnGCzCK/gPV5lXA7iHryfU+cR3Mhmm8EdNpvwDJZ4KY/gmYh7sMRxCHdnnDrrDDtIT/R/nHtwJvdM7iURk3s9iHdcMEo2Mc5jjLgbk3sn911HGe9+rzO5I+7GyN8qvIJXJd7piRVjctKs8whOiZjckQ7G5F7o+l13LSwFlFNnjSUdlGfw7gca737gwrq9ibk7cx90zaRrJq5BPY8TOeSahS/7ODe7fuEENrl+YSnTwpjbwladhbGsM5VqcMvBEjblbRPjbAvLeJ178O7POM9ghNN4OWMBr/FuH51hM4NzIm7EK3jXLc7kXgsx8m6BWyJuwRJfZdiswisYz6PxCEaZNO7Bi9xXI4ZN5BfWJhmnFpwPYoQH+YhTL5xbMOoc4xGMPDWewZ1sShyFB2xO4RU8KzHsIK2y5K/ycMZknHMjXsGpEpN7LsTbJsYkF8aInGcwyrDy7gs5t+DdVjqTTdQzxrCJNMcpFs4jGHlq3J0xb+bciHe8sLZjYdLMeQajnsFY6MIYkbHEV3kF1xYs8VXuwZ1sSnyFUYYxqS8nxBrj+TUmd9SlwjihwrkHJ3JHGVbO5J7JjsQRZalJHJXJvZI7yrMyyrPxDgPWFyysIHYewYiv8QpGeVZGu2kcNtH/cYZN1Cfo/zj34EzuiKMy6ihltJXG7L6CG7k3siNxLMIjeJA76iWsn1iYi1pYMSEnvjr3YImL8gzGM2i8ggvZlLgowybyZaBMGjdi2EHbJP0cnJCzMLbjvILRvivjuTPuzhjbcQ6bOBXWGTaRhjjRwnkGF3IvdH0l90rXoxxiHHjhi0UaL5yc7xzxxRyW8wzGc9eq8AxGvWq8nPGVImM8d8Y9OGfiEYxnDWNuckKscc3EPRj5aNyIER7kKU4YMx4H8baDk1sWVmg7t+BF7svc9/akg5jdVzDyd49Jbp7BiLsxuRdyR/9HGe2mMbkj7sYoA0V4BuN5NB7B6CN15RGMvDaewahjjZez9JGUUyLuwRLfJtyD0Uc1bsQrGGXbGOEZYMTXeAUjr/fY48nIa+MaPMl9svsKXuSO/rkwFm2vcQiPYMTdmNwzuaN/qIw+kjG7r2C0L3vccjNsCqOcK+PdRBl5arzTeSD98bUj5xaMsm0c7pgvM0YdsscYT0Y7ZYzwIF8wP+VM7gvuXXg4V0lD5Jf0Jfa438ko//MQnsFIB+MVjHRQRt/YuAcPsokwK6PvNLPwDEaYjbsz5pucyR31m/EuMxPpI/0K4xaMMm88glG/Gc/gRjZRzpVRzifSE8uqnWvwJPdJ1y9yX3Q9yvlEXuBUDecVjL6TMsq2cQ+WfFQmm5KPytvmQl5IX8J4BqPuMh7Bg9xRzpUlvkO4Eq9gtFmrCC9nLMs2Rp4a92DE13gEl0I8g1F3rS48gzHOYDyC0UYb92Dk7xrCjXgFozwbj2CUZ+Nwl/EW40YcNqV/YjyDUZ+vJNyDUacZN+IVjDJgPIOxDv04DhGTBLZYuVgksIPABBbmu+gkFpvGQkIVsp76OIqIQSJlFp1EPlg0FhI2PJ+yzczFJFEzi04CC8xdsE8/WLDpzqYHmx6DxBTTTUQjsQ4WYno/okk2oLloJFJiMUjkzGKSKGy6LBJVTC+IdrCoJDr79E5Co61ikpjsMweJxT6LrCWJ9h6+2wLW9rjVKbDt1MUiIeVABXaSuOgkJOtNsGmsdHMhpiuE5PYeLaty7ulOcRGTxCwsFonVQmSNnIpOImUWg0QW00vEJFEyi06iJhbsIxlsApHLhwiYzkgD2XPmYpGQp16FlGsTnYRksAkyXeSpNyGmkdZFMtjEJJHZB5tuXHQSksEm2EeebRPs09maRhsJj/VAIRoJjbaKQUKjrWKGwKqgEItEEtN4GqvUbyYqicI+Gm0RGm0Vk0RjnzZIdPbpbE2jvUQgbAUlpEodb0J8MgR2FLnoIWTRs4tJAutbXSwSmUw3ibYJMY3MknXOLhqLRUIKuQn2kabNBFJnD/OdYojpJkLu6RCzspgkJOtNkI9sjnPBPimzkMghF7rU5CYGiVJYLBK1kpAH3QSb7okFTFfkaZf6zUQnIVlvopFY7CMNmAmJKQr50HKgYpCQ1qwWEYOEpIGJSUJaMxOLhJQDFY1NSxqokOJfq4hBQrLeBPtIHW9ikZA63gT5yB46F+yTCgv5HZQ32TZnQnLbxCQhT72JTkKjrUKsIa2nZL2JTkKzXsUkodFWsUgsMr2kaTMhplGHLM1gFY1EZp/M9xT2KXyP5jYemVULi0lCaj4TnYSmgQqYbnjql2S9iU5COjImJglsk3GxXGTtsqnADg8XYrpASCE3MUhI1ptYJORBVyEPugk2LTE1waYH+wy+Z7K1yb8zOQQa7SZihpBtcy7YR5p3FdLOmegkCvsUvkfTQERln8q/0zgEjU13Nq1Zr0JMDwhp9FRogqjoJKTCNzFCyLmxLsh01jQQoWmwRFQWi4SWAxWDhFQBJhA2jEfK6bMhBglp9DA0KAfQupAqwAT7TPaR/o6KxT7S8IsoUh/sQ+23aCwWicQ+iX2k32tikijsIwmiQroE+3T7KifVutAEUTFJSJ/PxCIh5UDFZNNSDlRoGkwRM4ScOehikdBoi5ByYKKTKJnFIFHZdGWfxvc0ttb5dzqHQKKNcc8sW+BcTBKTfaThN9FDaJ/PBPukg0UjkdknVxYUglbYdGHTkvUmJHJNxCIhvUETYjpDSDkwsUhIOVAh5cBEJyHlwASZ1g6gCTGNAtulF2BikpB2YSQRnYS0jSYai0VCKkgTYhoFtksamFgkpFCokEbCRCch9YEJNi3tggkxjSImZxua0HKgopPQaKsYJOSpN8GmNaYiGptuX3z4ns7WOv/O4BBItDFonYdkvYlGYrGPNAUipmS9iUUisU/ieyQNTLBPSSwaCzZd2bRkvQqpHDBgnnWcT4UkiIlFQoq/CmkOTXQSi01rGkDoOB9GzrOO86mQ9x8TnYTUByYaCwkbiph2DVXUg4VYQzbq0J6JRqKzT2cfeQ828cVnkZDu8VwiJglNEBXhU44js+gkpK9sgn00QVSgXGPsdn8WkEUjIXWiiUFCyoGJSaKzaSkHKiQNMLhe5HgFF52ERNvEDJGkHJhYJBKZ1q6hCTKtXUMTfE9ha5V/p3IINNpNxCAh5cAE+4zCYpGQKsAE+yy+R9MAQruGJuh35EgGF40FmdZ+ogkxfUBI22hikNByMEQMEpogKiYJLQcqFgktByImm9ZyIELLwRLRQ8gpDC7EWhexSEhf2cQkIRWkiUECFWQ6kohBAn1lF5MEGgkXiwTqAxODTaNdMDHFdBExSaAcuFgh5NwEE2gOXXQSObMYJEphwT6V76lsrfHvNA6BRhulquoR9ComicE+egq9ik5iZRbkg/VhIRqJxD6psqAQtJxZsGnNehViGiVRuoYuOgk9hF/FJNELi0VisGlNAxViGuVazqZ20VisENI1dDFJoG1MKYmYJPBm5ALWMHVRsIwsxCRR2aeyTyss2KdnFogcZkWKdA1dNBKTfeYXn0VCvrhignyGJIgJlOuEZ1sORHAxSeRKAo2Ei0ZCyoEJNi3lwISYnhDyLJhYJDTaIjTaKjoJeRZMkOmpMVVBpmdin8T35MyCfke6hi4QNkzsFKy9D1FJNPbBq6IJyXoTk8Rgn8H3SBqYYJ/Fv7M4BItMryOzGCTkgzuYhdPTsU3kg4WYzhBSDkw0ElIOTAwSUg5MTBKdTUs5UCHlABNIeta2Cfk0hwmxhodWuoYuhouKhfohGgmpIE2I6Q4haWCikZBCYWKQkEbCxCTR2LS0CyqkOcQ0kR7W7aKTkObQxCQhzaGJFSIdZDppTFWQ6ZTZJ/M9ma2VwoJCIFPACVNYNUnWq8Arggv2kabAxCIhWW+CfSbfI2mgYrHPot+R07pcNBZkWoYQXYjpDCHF38QiIcVfhRR/E52EFH8TbFrTQIWYrhCjsJgkpByY6CTkG08mJGwoYkXTQEUnIc0hZq30uHATObFgn8I+pZOo7FMbC4ncgpBnwcQk0dmns49UkCYGick+miAipIKsSUQPIYdtuRgkpJEwMUlIOVBRDhaNhKQBJsSqDCGakHJgYpKQaJtYJORZUDHZtMRUxWLTi3zakVg0FvQ72jU0IWFrENItMjFIFPYpi4RkvQqpAkx88eF7NA1UsM/g3xkcgsmmJ5vWrFchpg8RM4T2E02I6QGh5UDFJKHlQISWAxWNhJYDFWxay4EKMY0Cq11DE4OEtAuYXqvaNVQhfWUTlcUkIRWkCZjGvFnVrqGJSUIKhQppJEw0ElIfmGDT0i6YENMoYjKE6GKRkOZQhUTbRCchT70JNi0xNUGmtWtogu6Ro1dd0O/MnFhI2FCq5IsoLiqJyj7SFKiQrDcxSXT26XyPpoEK9pn8O5NDMNn0YtOa9RBy7nzCvFnVrqEKTRAVk4QUfxOLhBR/FZVNaxqI0DRYIjqJnlg0FouEvC6bQNgwC1e1a2hikZDmEJNoegi9i0oisU/64rNIZPbJkwRGixLmzZp2DVVIgphgn8Y+UkGq6AeLLz6LhFSQmDfTg+tNaIKIkDrRRA+RpByYGCRSYTFJaBpMCHkWTDQSGm0Vg4SUAxOTRGfTGlMRg00P9pl8z2Rri39nUQi0a4jJrSbrBk1IOTDBPvKqaGKSkCrABPtUvkfSQEVjn8a/0zkEnU13Ni1Zb0Ii1yCkbTTRSUg5wLyZHlyvQvuJJgYJKQcmJgkpByrKwaKRkHKAWbimXUMV8rpsQqwlEZOE9JVNSNhQEoumgYpJQgqFCo22ihZCe4MmyLR8xM6FmEbZ0d6giUVCoy1Co62ik9CsV8GmNaYq2PRgn8H3TLY2+XcWh0CijVmrpqOGJiqJxD76KV4RUvxNTBKFfQrfI2lggn0a/07jEDQ23dm0ZL0KaRsxIda0a6hCEsTEJKGfJVaxQsgX7UykxKKT0DSoIjoJ6QmZaCwWCRktMiFhQxHrmgYqFgmp/TE7dibBwaKSmOwzv/gsEot99NvMELKiMGFCrOlAoQpNEBXsk9lH+kgqpD4w8cVnkcDUUsKEWJPDUk1IgqiQOtFEJyHlwMQgMdm0lAMVkgaYwtIj+l00EhJtE4OElAMTk0Rh0xJTFZVNV/ZpfE9ja51/p3MINNpNRCch5cAE+0hzaGKGWFIFmGCflFkMEpl9Mv2ODhSaYNOFTWvWqxDTKInyfSIXk4Q0hyrkWTDRSEgLaIJNaxqoENO7JOpx+y4GicQ+0htUISVehVQBJthH3gpMfPFha4h23ofdb7FIINom9OPSKjoJRNvFILHYNKKtIh1iuohYJPTj2SrYB9E2URKLQaKyT+0kGvs0tqbRrhCyQXMIi+UGMRuLRQL74dDkddnnKqz7XIUlLtgR0+WjQxlzP12G9Uwg1zJma7oM65mQ4JsYJNCAu5gkUFebmGxaIqNiiekmooeQ9X8uKotFIrFPmiTwwGZMaHRZ/2dCPntuYpGojUQ7WHQSnU3LR91VyFfdMciux+abQDPtopNAd81FY4GwYZ6gywYQF5NEyiw6CfmgvQn2KQcLNl3YdGXT8ll4FVIochMxSEjqmJgkpFCYWCSkUKhYbFoKhQhZGZgxndBxPpqLlFiwTy4sFgkp/ibYp1YW7NPYGk4plsenySnmYAy2GeM04pSFx2aUfOyyde7BOJ3OuAY3cscJl8qd3Dtdj9PplHGqJaZEO9beTXlE8I1hY5zAZ9yIlzPW4BnjxEFjdqfrcVqbMsVXvmlfxR0fb1feZcq5Ea9gfMjdeG5GXuAkM2dyl4+WD+EZvMh9wR1PMMbEjPdIoDPCgJZryofWlckdH1pvqGgxAObcg3d+DQwUdpzkMRrKBk5mdSZ3fEweo3Idg13GqztjdMsZ9yKvcdK889iMdMPXgpx7cD2IK/EMxkfjjcm9k81ONiVeyAuMWuEb7JtxL9IWmyCch/E4JF7KjXgFp0pM7rkQk83dfg+MlQ0MWxmjTBrPYHxSzngFI++UB9ncPRTjCZtFeASvRNycsXfVmd1X8O6mDIxvDPRSjHMNLgdxD8Yn9IxHcCObyFNlPGs4mWNgdMoYz5rxCJb4KpO7xFd5xwvDOAPDUs49eDdozjMYeWq8ggvZRBk2hk2kGzauOjfiFdwL8QweCE8VHsEzETfiFbzbCOdwxzZW57CJU+2dw2ZBXWQMmx2MvDZuwchr4xGMesl4BneyibxWRl2EnuTAl4yN8Swbww7KDHYzOA9nDD0NDGYMjDwZI6+NZzDiaLyCEUflSjaR18qII8YwBnYwGPdEDDsSNjy/xj0Y5dl4BqO+Ml7OmHU0xicwjWET5R+f53FuwYXcUS8p10K8ghu5N7oe9bAxuQ+yP+h3B9mcZFPiK4w8xVrQgX6OMvo5zisY5VYZ5da4B5dMPIIR35WFVzDqYWW0oasKN+IVPMh9kDvKrTG5I0+NER7kHYaJnHtwIvdE7hJf5RZcyB39B2OkJ54jbERwXsGor5RRho17MOooY7KJPDWGzQVGvWQ8nbHj1Bhl2LgH50xM7ijDxuReyQ76tDjAY8hXepQbuePUdiyO1ZPp8YI8MLxjjP6q8XCW0+iNZzBOjFbOB3ELxonReLMe6BcZo09uTO44Kdl4BqMfbkzuOGnemNwn2ZE47rp3ytd7sJxTT51XlrgIS1yUe7DERXkEV7KJU5+Vkf4YJJjo5xjjxGtjcseJ7Mo4udx4BC9yX90Zs3DOYQd7JQferSZGMAZOOJhY5z6wAmtK3wCnC0ycc2GcyR1lElvxJ1a1D6x2mvhmoNlH/0Tto35T+ytsliMTkzvaaLGPpURqH+X2nN/JEBgbGVhoMmX80sUiId+YNzFJyKcYscP7LO1irYkYJORrXiYai0Wi8D2VL5MP4OF1SQ4PdqFRUDFJyGfuTCwSk300PkjlJV+OhpADhUMsEqmymCRyZsHWisRnQtSDRWUxSbTMopPobKCz6cE+g00PNj3ZtHzIDW+I69A8VbFCyMCkCfmgn4lJQtOgiegkysGCfeTThXj/XLKyUF5AFzrpLjDs4qKHkGNnpFyvrAFVsUgk9knsk9kns09hn8q/U7/4TBKacyo6ic4GOhuQr+5JGugXQpv4aLRVtIi2DEG6+OKzSMijidfvJUOQJjL7ZEnrClEyi06i8o9WygX9pqeJSUJiaoLDNthn8D1SRk3w7ywOwSJrVcbI8HK4ZAexi0kCEzwZ73tLdoaY6OwjQ4MqZODUBPtM9pnss8hH9gmbkNFAE4NE5ns0PnhO5bvnGedELvlqpfvgMrxTriZjmJidXzL3akLGcU3MELL4zoSEzcQikcV0FrFIFPaRAVq8mq4uuYD3wiUzrBkvXEv2ZWS8xS05syVjbmHJVgyNqay3c9FIYAVJxeojOdw3RCeBuspFZbFIIOErjlZdchiLCfl2tYlOAs+Ci0aisQ/Kmws23cV0EtFJINou2Geyz2Qf+bK3CfKZR2IxSKTMYpLI7JP5nsLWKvu0QqIfLBoJjtycbGCRATlyxQUZkP0SLtgn8z3yPXIccbr0e+Qq5FvcJlAOMH61ZBrUxSSh2aiCfTrf09lnsM9gH/kEuQn2WXzP8rDt1XKVhJRrE198+J5cWAwSJbNgn8o+lX3kI/Um2KfzPZEGpxgcgsFhm+wz6R7ZSlv3qrpTaDY2EZOERkGEFr4uYpLo7NMHCS2JQ0QnMdlnLhLyifhd9zY5sDeEGFgQUkZ3rbwFDOx69BQSHxPsI7mgQnLBBEzvGvYUkgsm2EeeORPyO0XEIjHYR0qiCQkBEl62uNbRRIgP0k16G3UgQYqURBPsI4XPBLJkIKlkjtMF+2hMRWhMVYhpJK98J9zFJCHlzcQiMSsL9ll8j8YUQpak1YlsrJKNE1ki21VNSJ1oAgGdyAVZeOZikpACa2KRkJwzwT6D7xkSAuScTFG6WCS0QmkiVoimBVaEVqoqBomcWbBP4Xu0ORQh9UFF1uMI4RDSBh8ipA1GfOTwORWyBsyENuIqJgkpYmJaln25aPE7vbKByqal2VUh9YEJClvXsCFFuzwYJsQAHgzrh0wRnYQ8GCqkmTIxSUilOvEAyhJ8F5KnSN4hiTjlR+UJNoEfnUgDObijTjEtAZ0o13JymwuEYCGpZHdmXUmE+CANZEOmCbzP1VVEIKALAZXjOVwgPguhllX3dXUR4oOAav9gIaBTisuSsEmrqUIip0IiZ2IbaAeiICdyuBgQiI8soGoHoiCdBRcVoohYEIiCrJlqB6Ig5+u66BCIjxzC0Y4hYpHoEpwpYkIg1NI/aEkCiibHBeKTJNTo2bUkAZWY7qnqpqfotj13vgVM7wntvZJcTHeInFgsEhI5E2JgQEjkVDT5nSlCQrAgJHImkNZ7V2vTg3PbXiuyhfhkCImcCQQnS3zQuLYs8Vnig/jIAETLXYR33U+RBoncSJSDxJJFE4hP1pUaItLBYpLQxRlTBHwKIicDAy4WCVmko0KWoZjoJGQZigk2Le+aJsQ0kgqfIAoxSazMYoQoR2bRSWi0l4jKYpGQNChVxCKhaSBC1meZ6CQ0DVQMEp1NaxqIkNfY0kUsEvK+bWKQ0DRQQT7SiLuQ/EHkqrztmugkZH2WiUlC1meZWCQqm5b1WSZguiLh5aAyF43FIiHlwMQkIe/1tYgYJGRtkonGYoWQReYu2EeWGZog0y0nFmRazrB1Iabx0EqXwEUjIYXCxCAhD4aJSWKwaSkUKmR9Fhr+1GQFogp56k3AGroEqUsamFgk0FSbkGib6CTw9uGCTcuohwkxjZyTdeUuJonOPrKo1EQnIVlvgn0W3yNZL2IcB4vKgkIwUmZBpoemgQoxjYSXLYcuOglZmmdikpCRHxOLRGfTmgYqxDSycWgaqBgkZMhNKvyhuQ0xpRo0wT6JfaTEq8jso1kvQkp8P0Q0FotEZZ/KPpIGJiaJzj6yeFOFDoUVEYOEJIiJSUKKv4kVQgZUTKTEopOQNMCbeFqyOleFZL0J9tGhVxWLhCwuNsE+OvSqgn0GW0Pt31oSMUig9ncRPlmOI3PBPoi2C/bJfA9qfxOlsFgkMCNgQjpMJhqJzj+Ktw8Tg390sM/ke5b47KcxJw11gZBu3h6pb3rqrIlysKgkKvvURqKxT+N72iTRM4tBYkhwuohGYh4s2Gexz/ris0LI+REm0sGik8iJxSBRMotJohYW/KOaBiI6/2jn4HC08+DgTP7RycFZ/KOLfMpB9xTN7QGhoZ4Q8l6CmiJL98uEvJeYYJ/OPp19UPe6YJ/J90gUVCwOAepeFXJOrItFAr1OE/lg0UiUxIKCUznasgDcROMfbRyczj/a2WfwPfLG0vHMyeiKi0VCcs7EDCFdqdbxnEq3qKFSzU1yDlVablLeTAwSmnMqOonOPlL4TCwSGp8mQkyjIDWpR1XIM2eihcD3H0MsEqmwENMoll1zToTUliYmCc25JaKTkGhj5FTPbzUh75oYEs1dck6FxBQDn7lLTFXIM2eCfRb7LPKRURwXjYRUNSY6icz3ZLZWMotJohYWi4RUNSo6/2jn4Az+0cHB4WgPjrb0kVTIBrmGwd8sZ+k3DP7mqQmPsjM14VVIFJD1U39UhFTrJvgyTWsImdhxISEYIiYJKWIm2CezT2YfTWsVnURNLBoJaedMcHCk2sBIcF7SzpkYJAb7DPaZ7DM7icU+K+4psvPNxSQhtaWJRUKeORXS1pvoJDQNVPCPtsyCf7RzcDr/6ODgTP7R+cWH7tFRHAynFxmraRg0L3LCVcPIdpETrlxMEpV9Kvs09sEbpYnOPp3vkSiY4BBIha9CKkgTPYScXOCCflS+eOSCflROLnDB90idiGH7kjXUVYRc1iCkvJnoJCQXTLDPSizIR5aRuJAEGSImCXkaTbBPZp/MPvI0mmCfyvdIzaeicQik5jPRSEjNZ6KTmPyjUvOpWPyji3zqkVmItQkhFb6JRkIjh3KtvQ2MoBfZbtYwgl6qNNUmYBoj6HraqItJYvJlUvhM0GWy3axhCL7IXI4JebExwT6ZfTL7SLVhorJYJCTnTEwSjYPT2HRn05KNJtj0YNODTUueYkrhFIOElGsTjcUKIYM9LthHyrUKTQMVfE/heyrfUyk4vWUWkgZ4srqWAxWNxSKhaaBikpjso2kgYrHpxaYXmZbzpVyQaRn5aZiXKXKigAktLioaCU0qFV98FglNKhGNf0dTR0Rna52tdbY22JqmjggtIUPEIKGpo6KxWCGmlhAV7KMlRIRGWwXfI/Wbisr3VAqOfL3IRSehaTBFNBaLhKaBikFC00AF+2gaqGDTi0zrvJkJMqDzZiYk1Kj5lpYQFY3FIqFJpYJ9NKlUDBKNf0dTRwVb62xtsLXB1jR1VGzTHTOEBV/hDtFYLBdVOmYuJonEPnh+TCDaLvgetPUu+J4mwUkiOgmkgYvKYpIYhQX7zMyCTS82vdj0IgPpKCwk1BkiZRadRD5YNBKFfTSpVEwSlX9HU0eFjLs0EYuElBATko0FYlQW7DMLC/nRCrEyC/KRgSgTSeLTRDQSmX2yhKCLkBAMCE2DCaElZIkYJBr7aKFQgR/FHPL+KAkL9pGYmkBaY6q5ykCUC/KRuUMT6GC4kKce1orWByomiVJYLBIycmqCfRrfo/0qEZ1/Rwo5Jsj16NGOCfJ9nDIL8qmHpA5yTqb+1ICcNyA97yoHCXRMqleZxjPR2UeKmAopYiYmickGFl8mFbH8aDsqC/ZJhYSktQm+TAoSpvX1SFATlX2qhA2FT84O6Jjjr3Luk1nrHJzBP6o9bxHa81YxSCz2WXRP17cPEVJ1Yi1BldOdXLAPhgM7VhlUHE7gQgaz8UZZdVBJhb4dqpgkNHIqFonBPoPv0ZiKkEYC6xyqnNRkQqoAFXhNcoGExwqIKp/+ccE+UgVgbUSVI91NSLHEQokqi4ZMSLtgYpGQKkAFXhVdfPGRe1As5XCmjmUXeohnx9qIOjWmKC5TYypCY6pC4oOcmxpTFewjMcWihyodJhONfaSyMxHjVXo6p4tJQjrOJhYJWW1igny0J2RikJB1QhjVrTL21AvyVBYVuxgkMO7iopNo7IPWzMUi0cW0/GgX0ygH0t8xIXlqopGQatBEd9Fkp5OLxkJCUCHk0VQhjbgKjbYKSZAGUQsL9tE87SJk9Fh+VEbZVEiB3R9Sbe3QyKn44iMB3eWtJY3CgtA5MPGR4OwzhreYJBr7SLVuopOQ9tQEG5h8mXS29UcXhUBHi0wgoPuw6qbnXLr44oPIYeFH054DVlo07TlUJHzWOT0xrXN6KgYJeQMzMUnIcJMJ9hl8z+D4SGcBazCadhZEyFewXaDsVOS2jBZ1LMho2vBj9rIVTfgpopMY7CNdNhWzspgkFhmQw4lcrPhRnYEywT4a0CVikijsIw861no0mY7qmKdtMh3VMU+rp0yaaU14ETp3KEIm3kx0EjoFrIJ9Ft+zKD4y8lPR1jf5BKGLRqKwT2Gfyj7ILBONfRrfIyuzTXAIUJBcsM/ke2QlMzolTRbzmJCl9yJko1JFd6XJWpyKt4LWZRk9OgtN5plcsI8sLjeBH0U3onVZRm+CfWT9tQksTUWL3mR4xgX7yGrhLGGTxeVoxPWMx4pmt+lGJTS7TVcLq8jsI6uFVcgyerTOTXoOJir7SExNIOHRiLchmWWCfWSFsYlFQmIqaS2dBROywliEbjoyMUikzIJ9Mt8jZdQE/Y6OoUiTo7NWKmSUwAT7DPYZX3wWick+i++RmlyEHNjtYpBI7JP4HpnflhZQuxEmFgnptkrbqPNM0s7JB5xdNBIy7m+ispgkZADchJjez0/XNTImOgkZADdRWSwSmX3ktU+FzLWhQe46taQ+0tarj8ZUhMZUBRvQzBKhMVXBPhpTiCRZgta5y9CEicw+MniFZrfrghkTX3zwO2iQu3ym2QX7SK9GhcTUhISgQEhMTbCPRM6EmK4QknMitE+BlrbLfueGlrbLfmcX7COTTipkHsNE9xLSdTrKxCLRKol+sGgkBvsMvmdEsdSzFFtVUVksEvLqa2KQkBk1E5KIKGLyiRQXjcUiIWOQJiaJxj6apyI6m+5surPpwQYGG5CXSBMcaql3TLDpRaZ1XY2KxD6Z7tGJKhMUgsrRlh1IJjg+dbABjoJsfnbBPovvWRS5dhwsGgsJAR7apqVXxSShua2ik9CHVgUbKGxAo62CfbSXdogYJHTVnorGYpGQQm6CfXTlIoROIKE97TqBpEJCYAJhw4t0l2+SuBgkJvnoLA/eqrvO8qiPjOHj3bnrLI+KzD6Sonjx7LK+1wX7yDsGXhW7bH62H5X1FCZqCF1qi+18cpKhC1lhbIJ9CvsU9pHF5SbYp/E9srhcRecQyOJyFYN9Bt8z2ZqsNFexOASy1NYEmV66v14FmdZ1tyYoCtJZcFFZLBKyFwGLK/rSnfciZP21iU5CU0cF+8jGBBOVBZse/KOSVFjR0WWOxUUnIUllorkYsoXJRWWBH8Uo25A5loy1EUNGI0zIEmUT7FPYp7CPHIZsgn0a3yMrs1V0DoEsUcaqiSETLi4mCY1pF7FC6EnPJuSeASFPiYlBQp4SrD8YMrZhorCPrEFXIWfFYpnCkFEPE7IG3QT7dPbp7CNPiQn2mXyPbMFQsSgEWXM7i6gscA8G9If0XVxMEpLbJjoJSQMT7CM1hQk2Xdm0JIiJQaKz6c6mZZcClncMmWNxsUhI6pgYJGTXkgnykY+AuGgsyLR0i1xMEjmz6CQKm5b9C1hTMnQbl4nKYpLQpFLBPlLDmpAfxSMjozguGotFQpNKxSSx2EeTCqJqcVFB98gojgu5p0JI5WCik9A0UNFINPaRvTwmJonOpjub1jRQIaZRU8jnhl1UFpOEpoEK8tHDp010EtJIYKHE0I1XJhqLRUJqfxOThFQBJgYJaSixmmHI14JNSO1vorKYIfQgGhPsI3WiCtlihsUIQzdeqdD4LBGLhFRpJiYJjY+KTkKzRAWbRv1WMF8/5BseLmYIGd9x0Umg4XfBPmj4TaDNMlH5HhRLE43vaZUFB6dzcDqbHmI6iegk5sGispgkUCxdkM/UNFBBpnF8Y4jKgg3kwmKQKIlFI1HZtLaATQS1zroLy8QgIRW+iU5iiOksorJYJJbEFPWOHIhXsEhgLG3ERchGMhOVxSQhO6pMiDUERz7i5qKT6AeLRmKwj0ZBxSQx2fRk04sNLDYtXRw8jVM7cyYmCX2cVQwSmX20zRIhSWWCTTcpB11EJ9HZR9NgQGgaqPjiI9koprXEq2CfNUIkLeQqJAQLQh90FeyTKwuYxoKMKZ/tMCFPPVZaTBlhKlimMGVLlgv2kWdbBeo3F91L4kyawSoWCa3SIKTL5qKRSOyT+B59gkWU6ARP3SuvolYSOLIzyy04VtW4Es/g3XNy7s7oNzmTezqIK3HYxOyU89jcwPg8gHEPxtGrxpV4BrdCTO6dbHbYRDqgn+RM7jjGFCMDEwuWJ97rJ46rNk7knuCO8oWvZhjjiFXlloh7MD7bgAGBiS1SxvhUg7Bsky6olKacFGdCirYKPLcuvvjwPfLcopKdsoOnSLmQlteENDQiZJ+Oi05CCqMK1CkuxDSSUbbmuGAfeezwDjXxEQgXjX2ahA2JJqtTC14MpqxONSFPmopFl2kjiJ741HZPhYQaHekpy05dIHLo005p0Mxa7xEcGTXomAqculJBhUxgmmCfyj6VfWTK3gT7dL5HFpyoGBwCmb830UjI4gQT3cWSaQkXg0QqLNgn8z1ZrFUIWRRlYpLQeVsVg4Qs0MA6wiVfgTIhyzBUyEoFFYvukaNKOvZvrqShHiImCQ21ik5CVjuZYJ96sKgsxPSE0JwTIQtoTPBlspIEG9yXrotUIasbVGjkVIwQWTNLBfukxAJJhU2WSw5YMSExNdFJVEpemYno2GS5ZCbCxSSB3q6LQWKwz+gkpIyaENNZxCQhZVSETFi4kLCh8BWNqQjJYBODhDyNJiaJyj6V75FiiW2ep1gkZPmXCo2pikFCHkAVso7DhIQAaS1TDC7YR9b7YgPoqvoAitCirKKTkGKJDaBLtsy4YB+pUHCo3qqaCyoWicU+sjQNO0iXLJ/s2DS6ZFahY5+oHrbasflxyUSCC/aRFyq8pi/5HqaLRaKzT2efwT7aFIiY7DP5HulIi5B1kS46icQ+ie+RNhgv/UsORnMxScirI97Z9bBVaYP1sNWCt+wlr8ImJvtIg2xCfhS5oK/CJshH1kWaSNK0IbP0hdcEVh3grdROXsVb3JLW2URlH1mKYqKxiA7Gkl0lJqRTbGKQmIXFJLHYZ9E9U/shIiThschYD041Ib0NFdqVl3vkbQQrgZcsXjQh710qJHlNrBAyq2BCCoUKSV4srVmyP8NEYR/pU2BpzZKFiAVLa9bS9wfkjzTiLhqJxT4yArDFWZCPQkLeh0wsEtJp3GtmTiFldK+ZOQVqirLXzGwB07uLvhcqFBbi0yCkL7Z7zltMEpLBux/d9dTRsjvMp5AMNiE+CJtseyi737vFJJHEJ4kQH4RaGvFSEGppxEupIjoJ6WiWJgI+VUxLR9OE+MjvSL1T5Xek3qnyO1LvVDEtb7JVTGPQuVSkgexnKHWIGCH0/U6FVDUmxDRSR1YQmJByXZeIQQLPaWmHCPg0REEaVxcIaEN85MALF3IPIlek2mhVhPggctK4ltZFDBIStoYoyOB2aVMEYtoQUPmYogv2kWGUfohoJOSh7UmE+EhA5SkxsUjIEyxCdp26QKg7IieNqwv2yewjT7CJSQI9h9KROrKFwUUnoY/zFNFILPbRxxmi6eMsQgKqQsPWRXQSUvxNsE9ln8o+kiUm2KfzPTLWoWJwCOSpVzHZR56FjkKhzW5HFGQE2oTUVSYkBCgUciiYC/aRmI5DxCIhxV+FFDEVUsRGEjFJSHxGFjFISINsopOQnBtFRAsh54C5YB+pxUxICFCQhkZBBN4xXLBPYx8ZZ1YhT4kJ+VEUvqFRUDFJSEVsYoWQXZou2CcVFpJUyG1ZR2iiFBJS+FQ0vkcDihIix1qYjwZUhIzyipA1gWVMEZ1EYh9pnQeKi7bOJmTQ4hCxSBT2kUrVhPRDUFxklt6EtIAm2Ee7OFnEJLHCJx3aq1HRSUi7YGKSyHyZPAt7wnyLQUIKkolFQgdURMiDYeKLD98jMUVmJW3rVchTL0Jm3LGEdItJQo68PWAt6RpUFdKdrBCy2naPdG+xSMih1Spkta2JQUKWEptgA7KueA9UbzFJ6GpbiYKsK1ax2EfWFYvQU8lV6ALbCSFrhPegc09y0pX56NLoA0IXdIuQ49NVyAnJJjoJOSFZhax5NiGmd+HT80hdsI8u6M4iFgk55DkVEZNEYR85atuEhA05V+TgYROLhBy1rUIOHjbRSEz2mXyPZElCNuo54pK8enS4Ccn69d///U9/+tu//euf/+Ov//b3f/mPf/zlL3/65/9yh3//0z//j//60//78z/+8vf/+NM///0///a3f/rT/+/Pf/tPXPTv/+/Pf8f///jzP07fM2n/8vf/ff4/Df6fv/7tL5v++5/i7uP1redsztK7z9Hv5QbO1HjXxO5fVbWx277XRvKFkWN38MXG2bMhE+WLifLaxP68k5rYH0NyE2t9sVBfWzjHxi0pz6HxlxYuo7EsOc+qZL2MRv84GuNno7E7xpob83VurAsTOCJKTJw9oVeBSBcFa+GcbJg4X0PTh/E4h1VfxuMiEBOnK0pitj7dRKvvW/AysSdK7ljAWJRamOWOBXxPSiyMnu5YwFe5xcI56/DKQhofl+z9BvFh0b6Mx+EWzn7eq3jkqwpvTYvHOSGaqFTlt21gtBQmzu77SwtvxuMcjn0Zj3JVMKubaC2K9krvm5jJy/Y5I3jHxDmZYwXrnKM5boVijRUmXkfkomxmzKFJnp5dQTdxvrK/nSNrRkSO1zlyVWmWaEnPToWbyMfXhrRclc5pJesspxGPvt630LoX7/zaQr7qVRxmYqwWFdY5OPbVxkWmFq93a4oHPbf8fmpW79vsTS2vU7NdPKfDS+c4vjypv0mNftUK+aN6viKNl+F4t2yll/V3mQ+UrfVx2Vqflq09tvlp2ar507J1mZpvlq1aPy9btf1xZYs6Sb8pW3V8Xrbq/LRs1XVVh/s7RD5H0akOL++H4q3y2R4on+3j8nmZI2+Wz/Zm+cy9vyyf7aJ8jj0mLiZG5Oo58f9u6dwrLbx0jv6qdLartEjVX0XSOF6Gol2Ui3OE0rLknBYsrzqe7aJ4DnwTTExUeqn6jol4Izpx3TPhHZ0TX5u4TIsj0qLOVyb6ReN+Plx9xoM2oso452LetlLxJXJ5TmaZr21cVaA5KtBMD9s5mPO2jVy9/5nrah/baF86oO/bkLOC7J173bLxbpqO4/P0eNfGVXpc2Vgredt4jFsmxvSnhVulb1jAidqw0OY9C09k63uhuErLlO05Wam+HIMYD/RAx8c90PFxD3Q+0MLPj1v48UAPdD7QA50/2wP9Urbay7Gl+UAPdH7cA50f9x7X8XnZWunTsjUf6D2u8nnZWvWPK1v95ejr6p+XrTU+LVuXFt4rW+vzspWO49PCdZmcbxaudOTP303SUX7y5SQnL1y5vCxc6Wifv52ko3/8epKO8fH7ybWN915QfmHjrTeUX6THW68oKV1Vo9kzZn9A4WWn6doIVjGKkXLRd/uFkbrcyCgXRurnHftLI2fGRYVMaXJO7//GyEXmzNRjyvnCxEUZiUm5RhXZ701cRqXSjPNtIzRR2sdLI1d1SJSQVerLod2U0+czazn/5NTayjNiko/XMak/OC/2JRB1vQ5E/3hi7NrGezNjlzbenBq7Dsd7c2PpakLogcmxVatl7Kr95TBeuppVereUX80qPVDK6xExqa/b/MtZpY9LOQdivJ6NL+PzUn5p481SfmXj3VJ+GY43S/nVxNITpRwfJZdgcNf2t9lSy+dvG+lqaum9141rE2+9b6TaH3jhuJrJeO+F4zpJ333juJpdevd9NrXjZ19ouYy9XsCSruaX3i5jrXxcxi5NvFfGLieY3i1jrX9cxi6T9N0ydjWz8n4ZW39cGXu96C319EAZ6/njMnZp4r0y1usDZexqBP7NMnaZpO+WsT4eGDnp8ydHTnqMnPDy0N8tJzweGDkZ6fORk5E/Hzm5tPHmyMm1jfdGTq7T472Rk9GfmN29NPP2iMXlNMmbk2eXZdVL++rr5QKZNI8HasOriac3a8NLE+/VhrM8UBtezTy9WRteJum7teHsD9SGV9MlD9SGUcLG6+V9aa4HasPL6ac3a8Or6aeBb4GJjd6O1zbydWRiI0Vd+c6L+vCxuXXWJC8T9XIC6t3HdrWPH9tLE+89tlfzR28/tmt+/NheJumbj22+moV6t6Ocj/SzHWUuY/nlaGM+Hnjhz8fHL/zXJt4qY/l44IU/Hx+/8F8n6dtl7IEX/pyOP66MtZcrb3J64IU/p49f+PPVfMn5UPsY2/FltV35RjjeK6jpiYKaPi+o6YFRg5yeKKj5Dyuop7X8cvgz5ydKav68pObPC1l+YGgq54+Hpq6T9N1ClucThWz9gYWsv3wby+WBsalcPh6bujbxXiErD4xN5fLx2NR1kr5byMoDY1O5/OTY1Fk0MxXT+nL8M9ePd9Fdm3jzlS5f7XV685XuFzbeGhTKtT4xKHRp5t1BoXw1MfXuov9LI2fd7zmcR37CyLpn5L1F6tclfnlJ20d1vSzx7YlatX1eq7bPa9X2RK3aPq9V2xO1ahsPNN1XU1MPNN2/KWWvV4Hk/sBIau4fj6Rem3ivlPUHRlJz/3gk9TpJ3y1lvT9Qyq4mp54vZev1Rvz+wE78PD7ein9t4r1SNh7YjJ/H57vx+wPb8fN4YD9+Hv0PLGXl9Zh9fmJHVP58S1T+fE9UfmJTVP58V1R+YltUfmJfVP7hjVG/KWX19XE1T+yNyp9vjsqf747KT2yPyp/vj8pPbJDK7+6QunzbvZpOeeBttx5Rxmp5PcB8uannzbztD7ztrs/36f/Cxltvu+Vqgur9t91LM+++7ZarvVLvvu1eGnn3bfcbRtY9Iw+87dYZY4jteLl8uhwP1Kr4FNRnteq1ifdOa0oP1KolfVyrXifpuwc2pQf2nZZUf7jt/lLKXh/8V9IDe09L+njz6bWJN0vZA9tPS/54++l1kr5bynJ+oJRdzjE9XspeT7qVq5mqt0vZ1UzVm6Usf9yLKFfzVO+XsvVxKbtM0ndL2dWkytul7HKS6YlS1kr0EVt7udDl/ZL6+gjRUp4oqeXzklo+L6nliZJaPi+p5YmSWt8sqVfvMuVymunzd5m2YlNvT69rw8sppuXlo/GGtNbft/Huy0ypn+/q/4WNt15mLhO15xWJWl8/uFfbp2qfXlLHUV4n6pWNkafb4L2937Ixqtugs6m+ZWP59pi6+Lya2zZuxoULamqf23hd2C/Lx0hRPsbrYzBKe+J1qn3+OtU+f53qT7xO9c9fp9oTr1P9idep/tOvU19K2evNtaU/8TrVP3+d6p+/TvUnXqfG569T/YnXqfHE69Qof2Qpe729townOqnj807q+LyTOp7opI7PO6njiU7qfOJ1auY/spS9PpWszAf2ppT58d6UaxPvlbL5wN6UMj/em3KdpO+WsvXm3pTLV6FfbKL69FVoJvqGy+svRJSrKap3X4WubLz9KnS1AerdV6FrG5+/Ck3fYZuOdazXifrISfwPHMX/+Vn8xxOH8R+fn8a/njiO/3jiPP7jp2f9v5Sy1ydp1Sfmp+rn81P18/mp+sT8VP18fqo+MT9Vn5ifqj8+P/WllL0+g6E+MT9VP5+fqp/PT9Un5qfq5/NT9Yn5qfrE/FT98fmpr6XsZYtZn5ifqp/PT9XP56fqE/NT9fP5qfrE/FQtD4z61/Kzo/4rRv33hp2XZax8Pup/aePdrm4tn4/6/8LGx11d+fC0xuV8V3mdqFdbU4u/6PZyEZerXVAzCsgcM9+KSxzQs0+T6HemL1PzDyCeXPItGykeupRfLxquvzjbb3lNNkfKL4vqN6zketPKLF69z8lbOn5r5fIDPdhHa+mSb1tpkUO5tZtWahxxnNrrmap6dc5f9dOtKpWUMd+3cDY1vlX+5LJuhSOdc/VHWKnHTSs9UrZ1rgu+ZYVGJE6+G6ORI10Gb878rZWL+nF1/ybrGtxgtG/YGH24jXXTxozDnyfPnH3HxgobZ2Re2riassq5+hkTmfL37B7+xsjVAao42Vm6R7xrtv4uNpcfu0ndS2xPM98rJR1LL9RKma9L7OW0Valh5ZzuXxfpcjkk0CNKB3/A97fdpF8EprUIzCqvA/OL9PVcOrneTd/R41i1L6cr/TZ91yPpO44n0vc6Sq1GkWkXTdm1lRWrnMZx0ThfzmTRcis+4H7ctjHv2eiJnqL60sZligwcM6wpkvrrCnuMB1JkPJAi46dTJEejPMrFu8bVZFap0z9PUelTDKN9w0ac83riuGmj+hcuGr3zfMvG8NPezrq63LMx4yMZ67hpY/l2qxPvpWk9ii/sOcq4aaMlt0H7JL5lIzagnH3QfM9G8cNWak03bVSvnCt/yO+2DXpV+ZaN5q+Rp7XyuY3cXtq4fvpbDGaNNl53g6/3W43oBXMnaXzDxoyjUeddG/RmcPYDbtnIRxo+rNbXvXBEs5vTGDdt+JtfzsfNuGR/w89fvubyLRte2nNtd8PhX7fJlT4Z9C0bLb6n/OWk+e/YGF6T5THaTRvD83Ye+eNw3LaxfGAur3ozTVfzsr7oS5y/tXE9RLFoKGq1495AR4a3WDlf/8o9K5W+CHUOOI+bYWnxInAaqXetxDDSaeXmAFCOsdOTXw9TtKv5qDp8qqCO/nJw4NrGbFbHn4P1xy0b5wCWf/j1y2lp37IxhttYd210slHuxiWHjXtp2rIX18Y7UL9no1sd38qR7tkoqbmN/DIc1yW1pBh8Len1gvhfWMkx0Fhyum1l0OhEmzettBRh6evmQHAZxYf7y1j5Zj2QvSN/1o/5pZXLAf8RH5lLF8tJ37fRb+29Oqcro2Y8xssT7drlKYGHf0+7cD3wje9WnZfGgRb724ivA3Ld6KRoc8bLabZ2tf1qFjcy+fyW30wrtavprbx69Aio9/udzejnREzMTc35OkXq5x8AbPVHPwB4Fs+YU0rz9df32tWc0rvF7NLIx19Y+xqX9Xq+r11VIt0npgcdM3C2Qe+bSKn3mBzr1Hb+5uNmv7AyS9Qis738zNplkiyaEl7z3jTqFxtr3qvNFh1okV6uj2tX355695G5OibwzUem/ei3AL9W7ucA5evk+LyktkdKavvpkppzj7Y7vy6prT9QqfafrVRzzhSX15sFWv/R+vBrMFZ9HYyL1983vzl5beO9b05e2njzm5PX4Xjvm5PtaurqgW9Oplxixuk08rpvNz7/tmob5WfLeok5uDNe43VcfrZG5WDU19vI2/j8+6rXNt4s6+Pz76teh+PNsj7TD5f12L198r2FXKeNQuM7t97JMg2d5/n6q93vh6PeWlCWF1XKq86bNqL7sG6+Xy7Kl7XK5+F43cAcb4+ItNdt5UoPvF5efcHq3dfLy51TZfqo2ckzovPb89/a5ReXWonVW1SJ/PYt9RdhaTnWaixaI/T7sFwlS/bJr8n9st8ly+VuwREnwNFY8TfamZJotOrLXM9vy8nF2/+MMc159lRfx2V9Xtb61S6sN8tavzwk8O2y1q++vJSLr0o4K/n2sqxdGnm3wF6HpPsHNXPP82ZIUoxHptzvGanTTxxZV5HJTzx91wXlvafvegAv9XhyXu/n6Fd7sd58ci5tvP3kXG3GevfJudyL9f6Tk9oDT05qDzw5lyF598m5DMm7T86VkTefnOvcefvJuSwoTzw5tH4zvx6D71dbst59ci63db375FztH3r3ybncTvX+k5PHA09OHg88OZcheffJuQzJu09OHh8/Ode58/aTc1lQ3uzxXc+zeGHLK70+N/jSSDl8Xv/EctdITE6kY14YmR8nSb8+PfDzTnCpNBc3Xr5w9etvVDVfZ3gO+r7+cvm1lXerpPr5K1evj7xy9evj/958hi+/mJVidpE3QnzLSPdxvZGOCxOPvPpdZ88DTSgVk3KONr4sse2REtueKLHtgRLbnimx7YkS254ose3zEtueKbHtp0tsox0u4+WAZe9PlLX+wCBBf2aQoD/xVt2fGGnoT4w09GeewP5EN7ZfDvb7WH8a90y8+fz1z3ufffxwzrwbjmdGXvrnIy99tI+7fJc25uGrWmY6+k0bvpv+vo3kb0rne+y4GY733oXnI52Byw79m6l6beO9VL208WaqXofjzVRtD6TqL961SiwEK/PuCxsZqa/f+vrll6ver+HneqDduzLy9hjDlZE3K8brNHl7Qug6f0bkz8V3hX71Vj7jrXzcNJJSvNrTJrPfT5ONj2uCX9h4qya4tvFeTfCLcLxVE4zjifo1XX7CshdbfjB6vWvD971/YMOLyOi8Mu23KfKLM4LiEJi6Xh5oky73D/h6jEbrjms6vmHCV2J3WvH3LRPdN6h0WjfwexNXq6i8wzrL61CM46pGfPtba5dm3v3W2riclXrzW2uXRvLwkco80nzASG73jMQu0zZfh+O6jPjmzk6LqL9XzI4wUV6buDq68d0a5NrGezXItY33apB8PFCDtPVxglybeCs9rk28mRxPVKjHT46mv9nwHx83+8fHjf7xeZNfnmjyr47RPHyutPDxlb8Lx+V3r4tHJcrEb1e0XwbCH5EzPPVWNOI8iTxeF+/LzzMdqcbpNvm4FY7i47LnRE9/HY7LT7PHmVlnFZePO+GoXmOUWi+y9eol6hgjvvHEa0C/E44jzk6pLyuMcbXl6nzW4lDBY+Vb+dL8NJl9jMrrcFwOptLhqGkvpv1+OHLxjlxu+eVO46sKNMeBkznT+s/5vgV/nTyr+3XLgo9wnx2e446FeE7OZ2Hds+BhKLyG9X0L1TtMo/KK3m9YiFjwyUA3LaxbYYje5/m4pjsWutedY9zLTbbQxx0L0f8djfcRf8OCnwNwdpdupUPL0VHrL9NhXHWzUqyspheb3xxHOS4PCCy+7O984Xx9QOB44pTBcTUg/+4pg9cJEkeS0abs3yVIfSJB6hMJ0n86QaKE0CDp7xLkaty4+sHWs1Ib8vu4XDbubx7ldxkUStbZSn8dlHH1/nzOrvqoQs7Ujf1dwo7882ZSbJzPeynhzWwOI8frimC0B8r9pZF3y/3VnqRHyn322YFMH7b8XYKsJxJkPZAgM/10gnhsMq2v+W2CzHI1rugdmMaflfh9XOoTFcEsb+VNP3j06XdBuahfyzzicELaXV37cevBS6/L2dV8S+t+Clbr6youj9SvV0F5u8hf7rI6q/A4B2+kixrtysw5PJBj6ucid642N+2K2etofnJ+Z+QyJJ1Cku+Vk+JnOZf6+vG7PMXu7UN1xxpPlJRfBObNQ4vfTpXX3bU3LdDHdr9jgY50zy+bznm9iefdnJmXe5LezZlfBeaJnHnroPvrnPEDucq8SNfxTLrOR9J1PJGuV8Ow3RcKnHhnFGEOP4pjjnXPgh8POOdx5/17YuWNhuFYtyz4h24mtxDvWyhxsDC/O7+dE9WPRfkyDvL2/S2OeeO3/7fvL76w4cvJDu+H3+dX6qe/f/N+P1ai3Ep/L4S15Rv39+xlsBc+pv7ts2Q69SG/nOj6HQs+0154JOueBT7F8RsWfLD6nPgbH1qofErg+xaqz6d0rqXft3AO2/jQf20vc3OW9Hnn9drIm+9r+DrOp+9rVwnS4qNmba3XCdKeSJD2RIKMn02QOPwl9XGRIOuJBHngjX7W9LMJMlp8a4APgn7/oRv+2J4W6sskrQ+Mll4beTtJ+88m6YwvEE0aXvxdgswnEmQ+kCBXG5keSRD/BESa7XUJudpr83aCXBp5O0HqH1dC6vE6Qfp7cVmpXMTlPSPn4Ei+eDNq86etpDX9fLB9euTrlJ1Xk0jvDsddZc+KE4+/fMT7N9lzNQ1VD8/iE6nMv2/i7Ry+/CzUaI0+J0HTvb9P1frEaNy8mot6yMy7g3rzehbovUG9X4TkvUG9y9IWk43ronYc6c0ncFyMcFxV9EfUa/xhmt+FozxQS18aebeWvpxCeqCWXn6ufVrrdS19OQn1doKMJxJk/WiC5KNFCRmvX6/mj5dUmi3hYY/fhuOJkjqfKKnzZ0vqOePrX5VJLb9OkPFxgzXHAw3W5RTU+w3WtZm3W5pnZqHmE7NQ84lZqPnELNT1Mh3fOZAvRlkuv3Pz7uO3+gOP35o/+/hlP1XyKkHW1UaovGbsc6N8SeMbNrhubbRe4bcJso7801bOGZLY/nfOnNSXCbuOR7qvvzDz7mO8jv7jZt6tDdbxQPf1FyF5rzb4RVavFCu/F42B/z5Vrs3EgbfHmhdm0tWLV3yH/UTalPQdE76i/vzp9tLE5fqUNSlN1rwbGa9ZrkJymazpOOLUfe7Yf6eGi4XouZU7o4S5xcfz2nppASXp00bj2sibjQa+mv2TjQYlSD9ezhutXN6squ92pqd/rSp/+crjb8PxwBTBtZG3M+ZnpwjO3/a3i1XvTMflOGUlr9dTgqs8sKD62si7SVryjyZpORKd1HC8TpBHPra+yhMfW/9VYD5fxfE1VeaNglaO+Lby0frrdH3kI+vr8oS+99N1/Xi6Uqr0eitd06cWUvUvZ6f2cgh51Sdq1fpErVrHD1cBfDBmfZ0gT7T/9Yn2v/1s+1/StNHF/YXFlwly+Y2qt8ZsLk28O2azWnvkLe3azNuvV5dfiHrGzNtvaZfL5d99S7sOycdjNiXHAtf8uq1Zn09prSemtNYzU1rrmSmt9cyU1npiSms9MaW1fnhK68s+7v56QOxqSmsc/iXscfRyz0by4jbS6xVl1zaKD26MkvNNG/6p2FHq/NxGPz63MW6maY192PX16pbr3fVUOi5S44muwBO7qtb84a5A8/UGpaXX3fgn5rPWE/NZ64fns0rzKfHS+nidIOOJBBlPJMj64xJkvK6ErmZ+3t2Au1Z+4jVvvTcJfLkBd63L5X7v7pxdq/28mbc34F5lc1+ezePiJWnNJ7J5PZLND+yzPkeoH9lonY4j/wF2HsnpVfztb90b+1kxyrFeTzqecXlkM+Bp54ndgL8MzgPDP5y07c6WjnoUP+nveN1tTMflSX/fSNr0RI17GSFvga4idGnBp6frscotCz7fcVqoF4n6wLKBX1h5s1U/rfzswoEax2pUPvD3G6mafPl+Tf2iFsgPFdWcH6kFfhGcz2uBMzV8Z1p6Pa2VjqspqW8lTH8mYdqPJwyVmJlvlbm63MK6s+OtZtos/XqKLR1PbNT6hZW364If3qpVe/KtpD3f2YFX47DM2suthq/76bSnhYuGr4xH8mU8ki8/++pVZ/dRzznH6zSpD9Ww9Zkatv54DcsJs25VJMtLSl35orjVR7oE9ZEuQf3hLgHm4jVN2kU3qb057381zP62lettPaeZ/ONm3t8elI6r7VsP7A/6Um4v86h/OptybeMb+TyfmE/5lZ13Z0LOquv4eTvvTqmk43rK6r05lV+F5eNJlbq84NbLF/7enigxb1r51SPdx4+b+U7NcHW44CM1g5+H0Y6UXufReKRjOx7p2I6f7dieCVE9TV5PGJ3heKTcjmfK7Rg/buY75Xb8geX2Ko+uZsLebdHe3B72i3y+msf6Tot2bef9lmi2n7fzfot2Pan1bot2HZYHWjRfE9YudpymYz3S113P9HVX/nEz36kZ1s/2dVsM/LbLYdv1yDvaeuQd7Yf3e50J4SeYptdHHe2dFw+U23Q8Um7TkX/czDfKbTr+uHJ7nUefv6Nd2vhGPj/zjvYLO2+3RCkdP2/n7RYtpSfe0X4Rlo9btHYM7+um/HpgO6Un+rrvWvnVI53Gj5v5Ts2Qfrav21KPPBqvex0pP/GOdm3l3RYt5R9+R0t+DGLLR75Ik0fKbX6m3Obx42a+U27zH1duL/OofP6OlsoT72ipPPOO9gs777dEpf28nfdbtPLEO9ovwvJ5i5Z8GXa72KaSUn2kr1uf6evW/ONmvlMz1B/u6+YaedQveh2PzKOlR+bR0g/Po50J4Z8mzfP1aHl6ZB4tPTOPlp6ZR0sPzaOl9geW28s8euAd7ZF5tPTQPFp6aB4tPTSPlh6ZR0uPzKOlH55HO0td9HXn67Hu9Mg8WnpmHi09M4+WHppHSz88j9aKf3eplfp61DE9Mo+WHplHSz89j1aitiz9YkTrkXm09Mw8WnpmHi09NI+Wxh9Ybq/y6IF5tPTIPFp6aB4tPTSPlh6aR0uPzKOlR+bR0g/Po7XilUsr46L//8g8WnpmHi09M4+WHppHSz89jza9sLRZLvq6z3y767TzyHadtH56u86ZGr70YLbXS2by1TTYNxImH+mJhPlVcJ5IGCoxrxPmFxu+V3ws+rizqDxnn9HIeR4X2XNRUEYb/tXrRpPIaf7WyNUpGMVP1Cv8iZrfnJB5GrkaWXjvmM3TyNXuSFmkLdm7V8q9itC76XprQ1Uu/vGrXF6fxnxOQDzwWYVfWHm3j5zTz35YIRffFHkmz0VlcrU97N0dtKeVR+rY/OZetes9tPn60MO3976iU/Pjdp7YQ5tLoQfg9URevpo8+07Lkesj2f2L4HzecvTmNeUZqFsfNeuezb33csuCv632/voItTM11hO1U15P1E7lZ8/56N1XWfaRL2qnUp5Ik1IeSZP2w2ky/dN1fV08xFezZe/X2GU+8gi/uXPtFzV2faimrekPsPNEjd2Hf46uz9cf1jlDUp94AJ74WNhp5We/FtaH943P5Lnoxl1NmL37TfXTynrkAXjz22WXX1VP+eqIxQfeuftoHpBxMRqXrw5IfPe76qeVZ7oH7ZHKvz1yZN21nbeH0XJ74NC6X4Xl42G0Hi/c/eK7fSn3Z3b65v7ITt9fBefz/uQ4vLiceOdtdyT/YPVIVCX8bgDg8qTFHB/Kyj3fCkacKcin8n7Hgnfhxt0w+Iv/SDSg8g0LGMLSMNCgzrdiscLC/NRCuhWGnLNbKMeneUGN3nfC4Af9jNzuxaLUz8pDbd6+nLjuVFy1+4fKKvehv2Ni+PmwdZR7oRjeo6qDxqO+tSGoxMbqWi6agnlRdTZ/GWjHrcRoI1ZajrWugnHV5J9R8JbgZO55v39y05iRqPNevkwfJ6xz5I9NrNv5En3UfLN4jNiLdNzcFuInLrWjrXsmfHSlpXQzFLRNIN1clxnTJqmVeyZii8w5nXHLRFR/Ldebi8B6hGLeC8VcPlPC32u9HYp7JprPNTb+Vs+3TPiZ8K2nDyoez9jN+WXF8ws750PmXdCvD9w37aTqfdCzsNY7FWGbfqrfORuW7yZNO3zMePO8nzTxSeuTx307HJ6n7HDp+64dr5nSrujuZ3mO8JwvHvftpIPstDtFJ7Xe/MNiJ9ebRkbEqNPh2d8z4vOx56vI0e8ayWRk3jMyKINGHjeNtHgKxkwPGOl3ozPeC8n59nn5puuvqV/akW/ZiLnuMe7a6P1zG15KBn9+7ns2vD26b2P6q/9Md9N0HvNzG95VmfW4ayOvz234gMzs+baN43Mb/tI4Z71tI39uw0cSFleI37RRP7axPG+/vnr+1ka5GKJa87BEXbzKq/zOyNXKgRSfc06JT3X9vZnL6ax4m97HRPQLM9eTAt7zOrm222a8h72Pc7ofKTJzvg/eNjNamJnzthk/wWSf01AfMZP7A5H6yEx/NzSXpbj6CoCTx30zlDbtSHfNtBzPVKPDZr5tZoYZ2mv3XTMj0qYft9OmHxGpXuYjoXnITL0fKSp+nQasvmtmeac/jXQ7w/ucz5iJtBlXz9R1E+Vz1vN2MxdvIMeX0avvGYmWpVx1QK6muJp/7rmnl+P/1+HYM2MekHm3RybHoJqV12lyueK3efdy870X1RLfBD755vtU6fG959JTv2skotNzuWmE5h77uPeOWVaPkKyRbxmpNJL1ZU/N94x0MjLWTSNthZE5bhopMcDHH379lpFUIzqp38viWvwD5Se3m9GJT2GevO49OzW+cJi+HCr/TSORJrndTJOcIotzTzeNjJg8ymvdNRJpUo57aZK7L/xKmb9K9C0j01ehbb41wH7eGOPamY8c/5aR5dODJ6d600iK6KzcHwjJbSN+cs/J617ClkRNxs05rX0jGcnpgZDcNJKbv4VvvjeimFtUjyenm0aits/8uvA9I/EGdPL43AgvCv9eVZBpBU5ZN43EQHru82Z9QqujTiM3m4wR/b6T70XnfCGMIf27FXUr0e60Uo6bRuLZaSXdHNIvUVG30m8biTThvUnfM7JiKqrc7BW0Fm/IjV/7v2UkPmd7crk59VOjyTiN3JyEqp1CMm4biemwOu+mSaWQ3KzZWqPZvZZv9u1bii5oSzf79i2a0Xr3zeu8Njp+/WZ3q/aYmDt5PmDkbme4RxbX3m5HJz1h5CAjNzvDnbK4r5t9+z4ii0dKDxi5ncVs5GYWH74f4xzpvbWlI8UOiH1myEsT+yXm06GgSxP7fTaKa/oy2tC+Z8d3JO33wXnbTq70QtrSfTuLXrG/DIC8n0s5XtPzuJfRLcoK7+G+aaIf5ZYJqtj6l37STRPrYxM9f5wWN030eB3uc31sYs1PTfCmxrsm6sdF666JnGu8rOU2HjBykbFnbXUxCRdbmwvNuKb8WxNXFUfxxSyJ3wZ+Y+T9yMx6EZmrrVxv1e7XtReNlJQ0b1aBbCSXq8jUj3OmtZ/NmS+RqVftbhs/lzO5Fn/ucq3HvXpsxOD8181o73dkaA3ZaPfeI6Yv605z3etOrWgW1r05k3z4qNOJt7qX5ziTH4vQ7k265MNncvNx72Xoi4l1K0dy8nH0nO69OZwmZphY90x445TzcTMUfX1qIsdhL/nehM8XE/eWWebs875nNdxumvBt5OXeRFyOgxDzzRGqLybG/NjEvFe0is8Zn9bu1RfVtz6cI933cqT5TpJznPteWjR/yc83575zDMDsoep7ydn49J96qwP3GyOt3zTi4/4n9/aAkVEfiM5tI5NCsubnRvrxQO7cNtIThaTUB4zUctNIjQq19+MJI+uB6Nw3MsPIKg9k8V0j44g0GTnfMxJLpHcV/4CRdaR7RtYRLcVK8wEjeTwQnbtGVotOwOrpASPj5rOz/A1o83rAyJwPROemkb22yV/HjlIeMFLzx9F5yMi4myY+fnqOyJYHQnLXyDlCvcLIzV5BTb6AM9d8swX8aiTd6+TQOqeT83rASJkPROeuETqRs+Y5HjCy+gPRecJIKQ8UtjJu1Se1+dxD5X3Rbx8/k1acVrTWq/PQL8cifBFAPmjE/xsGopDyhohvGCgxrEPl82YIXkVhryN5bWP67pA57wShJqpHb62bO4cIabRw3DPRoyLut9bM5e6rDvLVLvsrEzFkmb/0Lr9jwh+LPPo9EzWeznbcOgMix2Ep5xTl56F4wEQ+7kXE98zl1u6Vzjh94RyCuFcumj9jud87UuPL0ffj4vywSxuxCXmf2n3vDTfHjshzuuG42a09UrwvHPfeF0pJcfL3veJxjrR1N3Gv5ikx1VHKulXzlBitK63cWtx6Dgq5iX5xjE5qVzNQvSQbCz7x9cjjr6z4ZEX/Ogf1PStxAmy9WF7+CytRhfSrIciEQbXX82F+dBTPnIzjGzZiT15Pt234zl3ecPs9G8MPXRm0TfZ7NmjfPS+E+Z4NX204uQP5PRteuU8eJPueDX/25rrMl4tSNpovsR3tYmdHav1qh22enTYy9HzXTjliH975RNdn7FydivMrOzMmtq9m/X5lJ84s3hPk67admKPZ+/aPm3XL6L4S+cS79dyIOeoxLvP82oo3ymPUedPKPDws87hM33GVvj1OgUz9ambzV3YyrafKudy3E5swe65327WZvbNw4rhrpfhozyztuG1lxZEj5XZYYrvEHOm2lZV7VKFXpWZeHeP69oLtX9p5c832L+28uWz7V3be3U5yncrr6HSYyd3aZqXkVlJJt8MSh7OkdNtK9ub7LEH1thXfib++vAV8z0o8letq5v9XVuLAmZpu53Stxa2M2zndfFpntVJuW4l0aeN2HjU/knf1cjuPuk98rz7n7efx3Z0U37JT79cP7+6n+HV40kN2DrJzvz5/d2PFL+28ubfiW3Y+yfc3d1j8qgX3KYFZ5u0+SZ1xfNmqD1j5MmL4TSt+/MCJ/bYV3yR4Bis9YOWDGFEv69rKL/qfNRb151afsdPL7fefHLsfS76sj39lp5CddN9OIzvj/vshba05bd6PF+2YPUcWP3jPpNNSymUv/Rd2GtlpH4SHzpEplz2LX9iJnaKnnf6MncsW/XJUzDeOf/kQy/dGxVJ8M+DuiNY4/GTNdHt0LgYDeI3h3RG+dnekcfiL4S9GCS/HXn2YsNd0d2Tji5V8tz04R059+LWM47aV+FJbvd2q9Ng33u+/u3+xUvsTqXvfCo/V11vL0M85A/8Ca733fYYvJtK9mZioIU+8NxNTYjLny/EE34lITGzV/LmJUj9OzpsmaG6slntn37819XJ8Ou9yfDrpcnw643J8Ot1yfDrXcnw60XJ8OstyfNrIH5+28Menzfvxadt+fNqwH5+26lcPdPIqIR/3DETleCsR4xyaL834dwzUTw3Yw1T4hfs7BvyrOcetp7H4GXDl3jEt1af5a7m1s6f5h87bvV1nLT7bce90wFbii4e3tkjFaq+ebm3T6iW+pnwrDfqMKu1WGsT3vb5u0v+GAf+ewL09dzG1cfOcrOFFed47QnB5L3jdO4GpFT+frvG7/jc2Ki//eFTiXQvfseDNY+LD+tp3FoL6Lk5e4P8NC/FJlcxzOt9ZGRaLnDN/svY7a8s8DIV2jX8rDLHn4riVDrnmDy0U76ucA1LzjgVeEEvjhd+yEAvOaYTmWxZiXe+93GQLq99LyRQWxp0niw4E5MNQziR5t46s0fNsNFY63v+Uc/Olm50bq29Y6PHp5E6rO75joYcFqmG+FQZ/xx/HrXQYZOFeLKZPKfVF25rftzBajhaLeh7fsND9bWzwafbjG3V19uPJT6ZZ1b1a8t0u3PQx6jr5bP7fmEgj5atHdMQ2Gxqs2IOx96w0qra/Z+XVAUzfDEu8puVBle8HVvLddEk5TjDh3VTfsxKHsbT5Oj6Xr41+VMWJkT3rO908L/ONvoD1HQu+227wIvpvWIj+9vnc3bOQ66cW/P138Az7byykka+O+dkri6xYpLruZEhO/oXiL2eg5Ja/YcJ7CIlW33zLxKIzUNZLE2lcHvLnKxe5ef2mjVjlTWMz34lKLhEV2pb6HROx3iHzcofvmBjezp/92KvEKPWnrXzpOdGKqG9aGV57pbHyXSsrJqxXvpc72aNzviPce2LifK6ztKR7oaDDLo5bEUlHNJO8DvA7JpJvOzwroHnPhJ8mldK8F4oSn5wp614oGp2PTStyv2Wix0nQc92LCC+nuBeRUukzMbciMvy1dVCv9BsGlo8ur3YrEis+cpfvhcDL1BrtwyjcM7DXL5uFg7JypbdzcsSahsELSd9+4UzxknPiuGUhyvQcXy38z1P9+V//+o9/+du//euf/+Ov//b3fz9v/O9t6x9//fP/+ttfVP6f//z7v5Lvf/z//5/5/K9//PVvf/vr//2X//ePf/vXv/zv//zHX7al7fenQ//8j1XPB2LVcvzPf/pTOvVZ35zTquffOU+Xcrqcc2r9n86J+H7qhjvO5nedwwz7jgMXnGOb57Ry3g5io579v/31uPQ//3tH4/8D",
      "brillig_names": [
        "_mint"
      ]
    },
    {
      "name": "checkFeeAmount",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14531954490500154755": {
            "error_kind": "string",
            "string": "NOT_SET"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZndbhs5DIXfxde5kERRP32Voijc1C0MGE7gJgssgrz7khoejpPFDNIxcmN/Q0vHJEVq5PHL7ufhx/Pv78fzr4c/uy9fX3Y/LsfT6fj7++nhfv90fDiL9WUX9CWSvOU7eefdlyrvWa5jUGgCUYCLQYkCOrYUgxoAbNBgabB0WHoGtAlSIEAVkG9PMQGKQQoAWAhjCLMyLBljWGaloNAM1OcBNQO6AAuoq6kIdJqAQgR0g6izukIzSAQQNygJqGMTFANN5gSwMMYwZhVYCsZoVokVmkErBprDCcSxLFFkDSdHBbXIdA4BIHHlrNANNIoJYEmwJFiIALBkjNGsTgBlLYnMCmygzk8AS4OluaUbdLOUEADFIEZANUgJoGNIYNTuAAZ0g0yAZqCZnwDTh/MDqkGFpWJM01lFoRj0OEENZqm6yrkqsAHDwhnQDHS5JygGFYMrBo+lVGiwaGXmriCusqx708UdEAnQDDRRHBWqAUUAA7qBJmoCDGZMZ1gKphdML5heMb1icMPghsGaMU4KfYIeJC6W9PbhalaoBgSLNhHLcvccAQzoBkyAalAwuGCwpncCWDSrCjHoxsFlkH6b7n9Bl2wiXSqjCtIKMVK5ptR1rixOjFrGRtmpgXRzmyj5uOSfat+VMKiD1KuJODpVkPpn5Db1r8RBHaTxTtSTUzVKITqxE+YmLaqSlHS/M6ogrSsjduqg7DOyq7Db2FWKqxRX0QIrpKR5nkh70aiCtDEGjT3biC2nY/ueaHTJRG7Teirj3qe9WLQixt5rlJ06qJHVC7UG6smpGuWQnNwW3RbdltyWoJfJbaMDBukOY5SdfAb7jJFTjSiPnA7b8H6Qej/iyOr9RN1toyKUeGSyDiqg6LaoWdO6Z61io+wEZSbkj7WBjZBnVp+N/HuL23w92NeDfT24+neMOuDX17sdTjbfny6Hgx5sro46cgB63F8O56fdl/Pz6XS3+2d/eh6D/jzuz+P9aX+RT6WDDuef8i6Cv46ng9Lr3Tw7LE+V85MmfkyXeurdJeTqjUhcEQkpQUP2pisJeiORliVy69Ukcg/FJcShawVaVpA7AvLQcl5UWA2jd4QhO81iGHxzGOVzw9Dt3VajLa9GW5GQUxAkCsUlJ/qyQucAJzpzvDEM2bsXw1gp7soFdVm5k0twfutEWuuPuT1yzC6RwrvuWKnM2AokenMFabaPKzAUUkjLCiuFWaUakQo5fswasrpvNFZKkxjZzHEuzMTp49mU/kAq+Kq4/5fNldosNWBFqvw6uqqLd9lYqc6qh4RJos4rkiJvqawSFisrrdV3zN5j8oN00Yu0ks/aorvRiJa6LNFqKjwXhcOiRF6PZN44c09LIh9NaAxLCV1TKDQrlOUlqbc3e2q3NvuqwoeancLtzU7x1mZfzeYHm53o9man/JnNfl1ZdbGyqNze7FRvbnZqNzc79c9t9hQJ2ZAEhMXqWpfILlHyNomOZMjTur4okVfqkxNywRS2KfiBsUgtbAkj0RzG1eH7byRKw5lTfsDSJokafdeqa6lon6shz3iDn1yv2/1vNGolaNSetmn04F3S07ZVSR6KPLrY1iUUEIlUSdzmhe/iorYpkDc/D8umIpeHS2HedNo2CT9hyKOlbV6QN6vgNi84hfmmWLdJlPm+2vq2QObqpLQtEMrzcwPeFEjNfj/LZYtA95tq501B9ID17GmbB15T8pj2xhDeC3yTy/398fLm369Xlboc9z9OB7v89Xy+v/r06d9HfIJ/zx4vD/eHn8+XgyrNf6HJy1eSIwURfdPHwXJZ813tehH1M7nDyl9C317Vlf8A",
      "brillig_names": [
        "checkFeeAmount"
      ]
    },
    {
      "name": "collectProtocol",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "tokenA",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tokenB",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount0Requested",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount1Requested",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 2,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            }
          },
          "visibility": "public"
        },
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "collectProtocol"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "admin",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "lpToken",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "lp_contract_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBPJwAABAMnAgQEAycCBQQAHwoABAAFgEwuCIBMAAEuCIBNAAIuCIBOAAMlAAAAUSUAAACRKAIAAQSATycCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgAAACgAgEcBAAEoAIBIBAABKACASQAAASgAgEoEAAIoAIBLBAAEJiUAAAcIHgIABQAtCAEGJwIHBAMACAEHAScDBgQBACIGAgc2DgAFAAcAASIABoBIAAgtCwgHASIABoBKAAktCwkIHAoHBgAEKgYICSQCAAcAAADtJwIGBAA8BgYBLQgBBicCBwQDAAgBBwEnAwYEAQAiBgIHNg4ABQAHAgEiAAaASAAHLQsHBQEiAAaASgAILQsIBxwKBQYABCoGBwgkAgAFAAABPycCBgQAPAYGAS0IAQUnAgYEAgAIAQYBJwMFBAEAIgUCBh8wgEiARQAGASIABYBIAActCwcGHAoGBwQcCgcFAC0IAQYAAAECAScCBwACLQ4HBi0IAQcnAgoEBAAIAQoBJwMHBAEAIgcCCh8wgEOASAAKLQsHCgAiCgIKLQ4KBycCCgAsLQgBCycCDAQFAAgBDAEnAwsEAQAiCwIMLQoMDS0OCg0AIg0CDS0OCg0AIg0CDS0OCg0AIg0CDS0OCg0tCAEKAAABAgEtDgsKLgiARQAEIwAAAgwNIgAEgEMACyQCAAsAAAamIwAAAiEtCwoHKwIACgAAAAAAAAAABAAAAAAAAAAAJwIPBBAtCAAQLQoKEQAIAA8AJQAABzEtAgAALQoRCy0KEgwtChMNLQoUDi0IAQoAAAECAS0OCwotCAELAAABAgEtDgwLLQgBDAAAAQIBLQ4NDC0IAQ0AAAECAS0ODg0tCwcOACIOAg4tDg4HLgiARQAEIwAAArENIgAEgEsADiQCAA4AAAZcIwAAAsYnAgcEDi0IAA4tCgoPLQoLEC0KDBEtCg0SAAgABwAlAAAHxC0CAAAtCg8ELQsGBy0OBwYrAgAGAAAAAAAAAAADAAAAAAAAAAAnAg0EDi0IAA4tCgYPAAgADQAlAAAHMS0CAAAtCg8HLQoQCi0KEQstChIMLQgBBgAAAQIBLQ4HBi0IAQcAAAECAS0OCgctCAEKAAABAgEtDgsKLQgBCwAAAQIBLQ4MCycCDAANJwINBA4tCAAOLQoGDy0KBxAtCgoRLQoLEi0KDBMACAANACUAAAg4LQIAACcCDAQNLQgADS0KBg4tCgcPLQoKEC0KCxEtCgUSAAgADAAlAAAIOC0CAAAnAgUEDC0IAAwtCgYNLQoHDi0KCg8tCgsQLQoEEQAIAAUAJQAACDgtAgAAJwIFBAwtCAAMLQoGDS0KBw4tCgoPLQoLEAAIAAUAJQAAB8QtAgAALQoNBAoqCAQFJAIABQAABDAlAAAJXAsiAAmARgAEHgIABQEKKgkFBhIqBAYFJAIABQAABFQlAAAJbjACAAGASScCAQAFLQgBBCcCBQQDAAgBBQEnAwQEAQAiBAIFLQoFBi0OAQYAIgYCBi0OAgYnAgIEBS0IAAUtCgQGLgiASgAHLgiARAAIAAgAAgAlAAAJgC0CAAAtCgYBCyIAAYBGAAILIgACgEQABCQCAAQAAATQJQAACvwtCAECJwIEBAMACAEEAScDAgQBACICAgQtCgQFLQ4BBQAiBQIFLQ4DBScCAwQELQgABC0KAgUuCIBKAAYuCIBEAAcACAADACUAAAmALQIAAC0KBQELIgABgEYAAgsiAAKARAADJAIAAwAABUElAAAK/DAIgEkAAScCAQADKAIAAgACWC0IAQMnAgQEAwAIAQQBJwMDBAEAIgMCBC0KBAUtDgEFACIFAgUtDgIFJwIEBAUtCAAFLQoDBi4IgEoABy4IgEQACAAIAAQAJQAACYAtAgAALQoGAgsiAAKARgADCyIAA4BEAAQkAgAEAAAFxCUAAAr8JwIDAAowCgADAAIoAgACACcQLQgBAycCBAQDAAgBBAEnAwMEAQAiAwIELQoEBS0OAQUAIgUCBS0OAgUnAgIEBC0IAAQtCgMFLgiASgAGLgiARAAHAAgAAgAlAAAJgC0CAAAtCgUBCyIAAYBGAAILIgACgEQAAyQCAAMAAAZHJQAACvwnAgIAyDAKAAIAAR4CAAEANAIAASYAIgcCDwAqDwQQLQsQDicCDwQQLQgAEC0KChEtCgsSLQoMEy0KDRQtCg4VAAgADwAlAAAIOC0CAAABIgAEgEgADi0KDgQjAAACsQEiAASASAALACIHAg0AKg0EDi0LDgwtCwoNDSIAC4BLAA4kAgAOAAAG1SUAAAsOLgIADYADKACABAQABSUAAAsgLgiABQAOACIOAg8AKg8LEC0ODBAtDg4KLQoLBCMAAAIMKACABAR4AA0AAACABIADJACAAwAABzAqAQABBfeh86+lrdTKPAQCASYlAAAHCC0IAQInAgMEBAAIAQMBJwMCBAEAIgICAy0KAwQuDIBGAAQAIgQCBC4MgEYABAAiBAIELgyARgAELQgBAycCBAQFAAgBBAEnAwMEAQAiAwIELQoEBS4MgEYABQAiBQIFLgyARgAFACIFAgUuDIBGAAUAIgUCBS0OAQUtCgIBLQoDAi4IgEUAAy4IgEQABCYlAAAHCC0LBAULIgAFgEQABiQCAAYAAAfmJwIHBAA8BgcBJwIFBAYtCAAGLQoBBy0KAggtCgMJLQoECgAIAAUAJQAAC64tAgAALQsBBS0LAgYtCwMHLQ4FAS0OBgItDgcDLgyARwAEASIABoBIAAItCwIBJiUAAAcILQsEBgsiAAaARAAHJAIABwAACFonAggEADwGCAEtCwMGCyIABoBDAAckAgAHAAAI7SMAAAhzLQsDBi0LAQctCwIILQsECQ0iAAaAQwAKJAIACgAACJglAAALDi4CAAeAAygAgAQEAAQlAAALIC4IgAUACgAiCgILACoLBgwtDgUMASIABoBIAAUOKgYFByQCAAcAAAjYJQAADLwtDgoBLQ4IAi0OBQMtDgkEIwAACVsnAgYEBy0IAActCgEILQoCCS0KAwotCgQLAAgABgAlAAALri0CAAAtCwEGLQsCBy0LBAguAgAGgAMoAIAEBAAEJQAACyAuCIAFAAkBIgAJgEgACi0OBQotDgkBLQ4HAi4MgEgAAy0OCAQjAAAJWyYqAQABBfSAAaZZ0ydCPAQCASYqAQABBR8AUBJAJCLuPAQCASYlAAAHCBwKAgUAKwIABgAAAAAAAAAAAQAAAAAAAAAABCoFBgcnAgoECy0IAAstCgcMAAgACgAlAAAHMS0CAAAtCgwFLQoNBi0KDggtCg8JLQgBBwAAAQIBLQ4FBy0IAQUAAAECAS0OBgUtCAEGAAABAgEtDggGLQgBCAAAAQIBLQ4JCC0LAQkAIgkCCS0OCQEuCIBFAAQjAAAKGw0iAASASgAJJAIACQAACpsjAAAKMCQCAAMAAAo9IwAACm8nAgEECS0IAAktCgcKLQoFCy0KBgwtCggNLgiASQAOAAgAAQAlAAAIOC0CAAAjAAAKbycCAgQJLQgACS0KBwotCgULLQoGDC0KCA0ACAACACUAAAfELQIAAC0KCgEmDCoEAgkkAgAJAAAKrSMAAArrACIBAgoAKgoECy0LCwknAgoECy0IAAstCgcMLQoFDS0KBg4tCggPLQoJEAAIAAoAJQAACDgtAgAAIwAACusBIgAEgEgACS0KCQQjAAAKGyoBAAEFAtxuJ4B2Ep08BAIBJioBAAEFxWvEWg4QAAI8BAIBJi4BgAOABgsAgAYAAoAHJACABwAACzsjAAALRi4AgAOABSMAAAutLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAAC5kuAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAAC2goAYAFBAABAwCABgACgAYjAAALrSYlAAAHCC4IgEUABSMAAAu+DSIABYBDAAYkAgAGAAAMKSMAAAvTLQsCBS0LBQYAIgYCBi0OBgUtCAEGJwIHBAUACAEHAScDBgQBACIFAgcnAggEBAAiBgIJPw8ABwAJLQsBBS0LAwctCwQILQ4FAS0OBgItDgcDLQ4IBCYtCwMGDCoFBgckAgAHAAAMPyMAAAyrLQsCBgAiBgIIACoIBQktCwkHLQsBCAAiCAIKACoKBQstCwsJACoHCQotCwMHLQsECS4CAAaAAygAgAQEAAUlAAALIC4IgAUACwAiCwIMACoMBQ0tDgoNLQ4IAS0OCwItDgcDLQ4JBCMAAAyrASIABYBIAAYtCgYFIwAAC74qAQABBUWnynEZQeQVPAQCASY=",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "createPool_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tokenA",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tokenB",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "enableFeeAmount",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "tickSpacing",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "enableFeeAmount"
      ]
    },
    {
      "name": "getKey",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tickLower",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "tickUpper",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          },
          {
            "name": "isTickLowerNeg",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "isTickUpperNeg",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "1778400301998778977": {
            "error_kind": "string",
            "string": "Function getKey can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZjfTis5DIffpde9yD87Ca9yhFCBclSpKqgHVloh3n3tjH9uWWlG7FR7A1/dzJd44knS+dw87x8/fj8cTi+vfzZ3vz43j+fD8Xj4/XB8fdq9H15PEv3cBP0Ta93cle0mtrS5q/pfPscg0EkgbjcpBEAziFmgKGhErkpJI02hGWQ2KFGgK0gkiTmRRJJ6SCNJgCOADGoAINIQaR7pBj0D2gQ5JEA1iBFgneYUAARQIQnkAmgGJQMQIUQIEU4ANqgRQAYjiwHooqHTDmE3YQkJUA1iBFgXJQUAAUxYkEVBFgVZlAIhoQuCkNEFQ8gQVgirCllAq2aCatAR6RahkABsEAOAAN0gFYB1QTkDICwQFghHRQ2AkNEFQ8jookKILAhZELKgDmG3LjgEAAFMyLEATMgpA0zIOQEgLBEAIaELgpDQBUPIEFYIqwrlQav6VA4YngFkMCZFoI3aUGC7qge7qhe7quuKoBDDSGzQuMETEYiDk8eqx+ol1kEtOzUQhiaEfqVjJwbF4EROMMdUnGCOOTu5uSQnN3tu0XOLnltkN7P3Vt1cvbfm5ua9dTd39DZWUyP0Nq1xXUnXgBwGiSXLIhnHWmbkMZ3rifT5NyJQjk4MKt6ueDvydrqGTcRu1nwn0ufeyNtpvjkN0j6yUNGyN2ogXYQm0oI38it0+TGqIPZ2HRYK2amDIiyUohMslJOTt/MRUPF2VJzcrPU8kdazkbcb90C3zLFuGFVQ91hHjENy8lj0WPRY8tiYGRrEoDEqVhqjmugSk9EXrRzWncVIYzpb3DWWBmlM86g6lqK9VR1LoUEVpNU0UQ5Oeg/qILkHRfutuqUYdZCOeSKdS6MK0pXLyGPN2zW/tnu7DnMLBaTrgRGBkseSt9NKLONgo3UwkdaBkcd00TQiEHuML7EO0oow8ljzWPN+Rx5tUDPq+uxPNPKYiEFaz0Yey94ue2zc+4ncrPVs1EHsMfZ21a+t3q65ufsItIqVZOFKTh6L0Wlk9PW13eCQ+fB+3u/1jHl16pSz6NvuvD+9b+5OH8fjdvPX7vgxGv15253G//fdWb6V+t2fnuW/CF8Ox73S1/ZydZi/VFYzLna5rmLdFfLpmyQuSIKeCCdHKOlKkb8p0ryitF5NUXpgV8iArg153tBKxn1osmjOGRbT6B1pyC40mwbdnAb/v2lQ89lo87PRFhRUCQrOcW4Qfd7QKWAQXU6cN6YR03waS8WdcvTCTDmH+eJeKE2Sg5pJBNtsKou16WXRKKY5xXIqunUhFeL5VG4vz3h7ff58VqjNprIgkYMUhpFby66g8nOD34vcU1hj6Lm4gdIqA7MbWlmVRUhu6DxnSAvFKa8h8KClnK4K6/uMprKgkLMkFPJjdJWCQ4aCr/eQ/6Co0RW1hVlFXbidlLHwZepl3Sh8F5HXMGGVovueLD9t1o2iBx9Fv97Lfq6Qt0BenHJMWKcI/pTKL8t1Cj2Um6LH2xXrbmcrySeV1k1qS+WimE0kL1RniT6pJdLsM5IXdvbLctGuH/X6XbCwsXNBFkx5laBhMri1dQLUVA3zI1i6jSljCCVxXzUTKdHNilh/oFguqRi9pFJcp6i+csuGuE7Bl1H8a7W6l0+7p8P528v0L3WdD7vH494+vnycnq6+ff/7Dd/gZfzb+fVp//xx3qvp8kZe/vySPWubS72XH2Djo7xsl8dcP8bxbdjmlO6/dDD/AA==",
      "brillig_names": [
        "getKey"
      ]
    },
    {
      "name": "getPool",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "tokenA",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tokenB",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "pairV3::Pair",
            "fields": [
              {
                "name": "token0",
                "type": {
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "token1",
                "type": {
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "fee",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "tickSpacing",
                "type": {
                  "kind": "integer",
                  "sign": "signed",
                  "width": 32
                }
              },
              {
                "name": "maxLiquidityPerTick",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "feeGrowthGlobal0X128",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "feeGrowthGlobal1X128",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "slot0",
                "type": {
                  "kind": "struct",
                  "path": "pairV3::Slot0",
                  "fields": [
                    {
                      "name": "sqrtPriceX96",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "tick",
                      "type": {
                        "kind": "integer",
                        "sign": "signed",
                        "width": 32
                      }
                    },
                    {
                      "name": "observationIndex",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 16
                      }
                    },
                    {
                      "name": "observationCardinality",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 16
                      }
                    },
                    {
                      "name": "observationCardinalityNext",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 16
                      }
                    },
                    {
                      "name": "feeProtocol",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    },
                    {
                      "name": "unlocked",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "liquidity",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "protocolFees",
                "type": {
                  "kind": "struct",
                  "path": "pairV3::ProtocolFees",
                  "fields": [
                    {
                      "name": "token0",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 128
                      }
                    },
                    {
                      "name": "token1",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 128
                      }
                    }
                  ]
                }
              },
              {
                "name": "initiated",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "rate",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "rate_mul",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "rate_time",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "getPool"
      ]
    },
    {
      "name": "getTickSpacing",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBKJwAABAMnAgIEAScCAwQAHwoAAgADgEguCIBIAAElAAAASyUAAABvLgIAAYBJKAIAAgSASScCAwQBOw4AAwACKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgEAASgAgEcEAAEmJQAAAiIeAgACAB4CAAMAMyoAAgADAAQkAgAEAAAAkyUAAAJLJwICAAAtCAEDJwIEBAQACAEEAScDAwQBACIDAgQtCgQFLQ4CBQAiBQIFLQ4CBQAiBQIFLQ4CBSsCAAQAAAAAAAAAAAIAAAAAAAAAAC0IAQUnAgYEBQAIAQYBJwMFBAEAIgUCBi0KBgctDgIHACIHAgctDgIHACIHAgctDgIHACIHAgctDgQHLQgBBAAAAQIBLQ4DBC0IAQMAAAECAS0OBQMtCAEFAAABAgEuDIBFAAUtCAEGAAABAgEuDIBEAAYnAgcAAycCCAQJLQgACS0KBAotCgMLLQoFDC0KBg0tCgcOAAgACAAlAAACXS0CAAAnAgcECC0IAAgtCgQJLQoDCi0KBQstCgYMLQoBDQAIAAcAJQAAAl0tAgAALQsGAQsiAAGARAAHJAIABwAAAconAggEADwGCAEnAgEEBy0IAActCgQILQoDCS0KBQotCgYLAAgAAQAlAAADgS0CAAAtCwMBASIAAYBHAAQtCwQDCioDAgELIgABgEQAAiQCAAIAAAIbJQAABJQvCgADAAEmKACABAR4AA0AAACABIADJACAAwAAAkoqAQABBfeh86+lrdTKPAQCASYqAQABBb4eP/8+pPb6PAQCASYlAAACIi0LBAYLIgAGgEQAByQCAAcAAAJ/JwIIBAA8BggBLQsDBgsiAAaAQwAHJAIABwAAAxIjAAACmC0LAwYtCwEHLQsCCC0LBAkNIgAGgEMACiQCAAoAAAK9JQAABKYuAgAHgAMoAIAEBAAEJQAABLguCIAFAAoAIgoCCwAqCwYMLQ4FDAEiAAaARwAFDioGBQckAgAHAAAC/SUAAAVGLQ4KAS0OCAItDgUDLQ4JBCMAAAOAJwIGBActCAAHLQoBCC0KAgktCgMKLQoECwAIAAYAJQAAA4EtAgAALQsBBi0LAgctCwQILgIABoADKACABAQABCUAAAS4LgiABQAJASIACYBHAAotDgUKLQ4JAS0OBwIuDIBHAAMtDggEIwAAA4AmJQAAAiIuCIBFAAUjAAADkQ0iAAWAQwAGJAIABgAABAEjAAADpi0LAgUtCwUGACIGAgYtDgYFJwIGBAQtCAEHJwIIBAUACAEIAScDBwQBACIFAggnAgkEBAAiBwIKPw8ACAAKLQsBBS0LAwYtCwQILQ4FAS0OBwItDgYDLQ4IBCYtCwMGDCoFBgckAgAHAAAEFyMAAASDLQsCBgAiBgIIACoIBQktCwkHLQsBCAAiCAIKACoKBQstCwsJACoHCQotCwMHLQsECS4CAAaAAygAgAQEAAUlAAAEuC4IgAUACwAiCwIMACoMBQ0tDgoNLQ4IAS0OCwItDgcDLQ4JBCMAAASDASIABYBHAAYtCgYFIwAAA5EqAQABBQLcbieAdhKdPAQCASYqAQABBcVrxFoOEAACPAQCASYuAYADgAYLAIAGAAKAByQAgAcAAATTIwAABN4uAIADgAUjAAAFRS4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAUxLgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAUAKAGABQQAAQMAgAYAAoAGIwAABUUmKgEAAQVFp8pxGUHkFTwEAgEm",
      "debug_symbols": "tZjbbuM4DIbfJde9EHWi2FcZDAaZNh0ECNIi0y6wKPruS8r85aSAjR0Xc5N8psXfpETKh/fd4+Hn268fx/PT8+/d/bf33c/L8XQ6/vpxen7Yvx6fz2p93wX7Iaq7+3y3o0i7e7Z/PaagkLICKeQIYIWmUCKgOlQCwMKwMCwtADJAHCQB2gQx2CVEISYAOyScSrBkWDIshQDFoQZABogD4xLcHJoJskF1EAIUgEyQQgY0B4oAduhZdIAlYUxSr6gTnnICwGLzPEF1sCwmyAAMZgxmdmiwNLhbFhMUgEyQQwK4eyYC+OAcA2BYzD0qJHNPCpkA4lAywELVWss1AdjBqmWCAhCHhsEN7gKLuHsJ5l4MxIFsTDNoDlbYHaywJ9DBSQOrpHmlbKCnkrrXGB1SABSAONh6papga5HYoDnYWkxQHaz4J8AY8VNswadmwA49jA7iYBPeocfTYVhsjBYtW/F3sLLpYNUyQQFgsNX8BPCyIsm6pmxFMkEByATNimQCdiACuHuLsMQCgHuCu3Vu1i2l2Rx2KAFQHGxLmUAcesxswA6NAG4RW/esBSm2yjkZNAfbJSZgB9slbN3F+qtDDYDiwLAwLA2WBovAIq5DIYRBeVAD2QbhNDzi8OgTFztZ6t3WY+5kQVv0ShVUh83idjLfYsR50LBZV+XaqYEkDoIyhThIQJRBFrMTrktp2NIYhzUgykMvj2v0JU8fH3c73J9+vF4OB7s9Xd2w9Db2sr8czq+7+/Pb6XS3+2d/euuDfr/sz/3/dX/Rs1pgh/Oj/qvg0/F0MPq4m73DsivpTpvdnVIVGRJ6dCNCKyLBdsRJI+R4JZFuJOKyRG7CLpEl1CGhAV0rpGUF7SzMQ8t5UWE1DRGkQSSLaZQvp1H/bhqljdVoy6vRViQKF0jUREtByLKClIAgpBT6YhoUl9NYKW7mgrlkbnMQJd8GEdf6Y26PTHlIxPCpO9LabFaX0Ie8oaDNdquQVxLRWkIiUtKsoWtzo7FSmvpshcqkuaxiibcKK6UZSQiJxCDLGrysUSJarKSwTWF0WKWyLY/YEERMVyvyRxpMY1F5JZNIf1dDXz/C6FRu2zT02QgaLHGbhoSxd0pcmdO1XstjXahcbX2fey2urEvlgH7lWOvVrnHbbXGlwrjSvGvMUWi1bdh3WghL+05c2T/1aWHswMRhMYq0FkajOMJIafGeSqtTMeailrAoEdczmW+r+aq+PomE//mAUZe7fk2Cxn1Vo2jbJOqIgtq2KNLYvRS3RVFimLuEt0nUudGabEtk7vcUtyWS8vzkWTYlwnkUeK5bBGR0mZRNSUjAekrcFsGoKX3f+mIKnwW+6+H+4Xi5+Qr2YVKX4/7n6eCHT2/nh6uzr/++4Ay+or1cnh8Oj2+XgynNn9L051vUDwKx8Hd7idJDfeO608c1OyQ7q89w+iHq+4cF8x8=",
      "brillig_names": [
        "getTickSpacing"
      ]
    },
    {
      "name": "get_admin",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
            "fields": [
              {
                "name": "inner",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAARSUAAABGLgIAAYBEKAIAAgSARCcCAwQBOw4AAwACJiUAAACmHgIAAQAeAgACADMqAAEAAgADJwIBAQEkAgADAAAAbyUAAADPHgIAAQEnAgIAAS8KAAIAAwoqAQMEJwIBAQAKKgQBAyQCAAMAAACfJwIFBAA8BgUBLwoAAgABJigAgAQEeAANAAAAgASAAyQAgAMAAADOKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQW+Hj//PqT2+jwEAgEm",
      "debug_symbols": "tZbLboMwEEX/xWsWHtvjR36liiKSOBUSIhGFSlXEv3fcYgMLW1VQN/gOxoe5nuHxZFd/Ht9PTXe7f7DD25Od+6Ztm/dTe7/UQ3Pv6OyT8XAwyA6qYpYCQwNFwCvmJI1Ao/0dgetZAJBQQYQzjoSAKAw7iHCNFCR4EGYWKp5BHgVG4UjoaapYTO409N6H3FbZkodH3ftuYIdubNuKfdbt+HPRx6Pufsah7mmWkL670kjAW9P6oKZqWc3zS0GiVvNykNq5hKBoA4EChAsRGVyJFUJuECKPUNaZGaEc1wlBCa0JMk+wSsZ9sEplCUUbzkUbAC5rA3fb0P9rA22qhs1XwxYQaDAitIRcEi5PcMhjEg4RdtoAkbdRaG6tU0G1AZMQqLZJFPoSuYnlIGmzPoqNmXrCIogcouTDCJl8KMj6KDQmgEoVBbO8KATgllFoTWMhPubGUhVye2EKCB1eqL8IjTyLsGUny2Oq3Esbum4MJXMbKnipwXXsb7dURMLfm9OgSjkYkc1B7C+qkLuLKtTuogp8tahHiupL028+5VOg9U19bv0c3sbuspodvh5xJv4KPPr7xV/H3gfS8j8AdHyTUEl9DB/5EJhKuuMUbv0N",
      "brillig_names": [
        "get_admin"
      ]
    },
    {
      "name": "initialize_pool",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "tokenA",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tokenB",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "fee",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "sqrtPriceX96",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "tick",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "isNegTick",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "11313697656972294845": {
            "error_kind": "string",
            "string": "AI"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "initialize_pool"
      ]
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vb3fruS6kWf9Lue6L5JkRDDoVxkMGu4ez8CAYTfc7g/40Oh3n1RQ5Ira1VulnbnP3Pgslau49I8/KakQ9Z+//a8//ct//J9//vNf//ff/v23P/yP//ztX/7+57/85c//55//8rd//eM//vy3vz7/9D9/exz/U3r/7Q/tn57/9d/+oMd/x29/6M//+vP/Hsd/y29/KOWA+oTjv+38r5z/1ed/jxbcFvQFvmCcMB4LyoK6oC2QBavlsVoeq+WxWh5ny/XxWFAW1AVtgSzQBbagL/AFq+WyWi6r5bJaLqvlslouq+WyWi6r5bJaLqvlulquq+W6Wq6r5bparqvlulquq+W6Wq6r5bZabqvltlpuq+W2Wm6r5bZabqvltlpuq2VZLctqWVbLslqW1bKsluVouR/QF/iCcYI+FpQFdUFbIAt0wWpZV8t6tOwHjBPssaAsqAvagmfLtRzwbLnqAbagL/AF44T+WPBsuY4D6oK2QBY8W26PA2xBX3C0fOyoo/sFHP1vwrPldiiODjihLZAFusAW9AW+YJxw9MEJq+WxWh6r5bFaHqvlsVoeq+WxWh5ny+3xWFAW1AVtgSzQBbagL/AFR8vPY9qOPjihLKgL2gJZoAtsQV/gC1bLdbVcV8t1tVxXy3W1XFfLdbVcV8t1tVxXy2213FbLbbXcVstttdxWy2213FbLbbXcVsuyWpbVsqyWZbUsq2VZLctqWVbLslqW1bKulnW1rKtlXS3rallXy7pa1tWyrpZ1tWyrZVst22rZVsu2WrbVsq2WbbV89EF5HDBOOPrghLKgLmgLZIEusAV9wWq5r5Z9texny3Ls3qNXyrF7pRxw/PP4E18wTjh25oSyoC5oC2SBLrAFq2VdLetq2VbLtlq21bKtlm21bKtlWy3batlWy7Za7qvlvlruq+W+Wu6r5b5a7qvlvlruq+W+WvbVsq+WfbXsq2VfLftq2VfLvlr21bKvlsdqeayWx2p5rJbHanmslsdqeayWx2p5nC3rEWhiB5QFdUFbIAt0wbNlfRzQF/iCccIRaFoOKAueLasc0BbIAl1gC/oCXzBOOAJtQlmwWq6r5bparqvlI9BUD+gLfME44Qi0CWXB0XI/oC2QBc+W7djSI9Am9AW+YJxwBNqEZ8t2rM8RaBPaAllwtHzYj0Cb0E84Opr6Acc/P47F0a0s/uT5l/uxn49uNcEXjBOObjWhLHi204+Wj241QRbogqPlw3V0qwlHy+OAccLRrSaUBXVBW/Bs2Y+z7uhWE2xBX/Bs2Y+dcHSrgKNb+bEaR7eaUBe0BUfLh+LoVhNsQV/gC8YJR7cah/ToVhPqgrbg2fI4VuPoVhNswdHycSYc3WrCmGBH35lw/HM94PmXhx9w3LzVA55/eTxXw46eMqEsqAvaAlmgC2xBX+ALVst1tVxXy3W1XNeKxV3343GQbeqbfNNYFLfeDzmobKqb2ibZpJvCceyHuAOf5JvGorgJfxwrGnfhk+qmw1GOdYkb8Um66XDELo578eP23OJmvBzbG3fjQXE7PqlsqpvapsNRj5bjnnySbeqbfNNYFDfmk8qmuqlt2g7bDtsO244e7R3b1sumuqltkk26KH7HHtd2ix+yk6Ll48iMvaZjr+lYa9rjN+fxO6DHj85JbZNs0k22qW/yTWNR/PictB1lO8p2lO0o21G2o2xH/OSsdlD8235Q/NtxkG6yTX2TbxqL4myfVDbVTW3TdrTtaNvRtqNtR9sO2Q7ZDtkO2Q7ZDtkO2Q7ZDtkO2Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dDtsO2w7bDtsO2w7bDtsO2w7bDtuOvh19O/p29O3o29G3o29H346+HX07fDt8O3w7fDt8O3w7fDt8O3w7fDvGdoztGNsxtmNsx9iOsR1jO8Z2jOXwx2NT2VQ3tU2ySTfZpr7JN21H2Y6yHWU7ynaU7SjbUbajbEfZjrIddTvqdtTtqNux+7nvfu67n/vu5777ue9+7ruf++7nvvu5737uu5/77ue++7nvfu67n/vu5777ue9+7ruf++7nvvu5737uu5/77ue++7nvfu67n/vu5777ue9+7ruf++7nvvu5737uu5/77ue++7nvfu67n/vu5777ue9+7ruf++7nvvu5737uu5/77ue++7nvfu67n/vu5777ue9+7ruf++7nvvu5737uu5/77ue++7nvfu67n/vu5777ue9+7ruf++7nvvu5737uu5/77ue++7nvfu67n/vu52P387H7+dj9fOx+PnY/H7ufj93Px+7nY/fzsfv52P187H4+dj8fu5+P3c/H7udj9/Ox+/nY/Xzsfj52Px+7n4/dz8fu52P387H7+dj9fOx+PnY/H7ufj93Px+7nY/fzsfv52P187H4+dj8fu5+P3c/H7udj9/Ox+/nY/Xzsfj52Px+7n4/dz8fu52P387H7+dj9fOx+PnY/H7ufj93Px+7nY/fzsfv52P187H4+dj8fu5+P3c/H7udj9/Ox+/nY/Xzsfj52Px+7n4/dz8fu52P387H7+dj9fOx+PnY/H7ufj93Px+7nY/fzsfv52P187H4+dj8fu5+P3c/H7udj9/Ox+/nY/Xzsfj52Px+7n4/dz8fu52P387H7+dj9fOx+/vz59QALWMEGCqiggR10EFvBVrAVbAVbwVawFWwFW8FWsFVsFVvFVrFVbBVbxVaxVWwVW8PWsDVsDVvD1rA1bA1bw9awCTbBJtgEm2ATbIJNsAk2wabYFJtiU2yKTbEpNsWm2BSbYTNshs2wGTbDZtgMm2EzbB1bxzYfvx4Pax/zAezEAsYjvBbYQAEVNLCDDo6FZT6UnVjACjYwbD1QQQM76ODYGB3yGJR/YgEr2MDDJjVQQQMPm8SaRYc8cWyMDikSWMAKNjBsGhjtWqCDY2N0vROjXQ+Mdkfg0e4xiPxEARU08LBpbHF0vRPHxuh6Jx42jW2L/qaxvtHfNFYn+pvG6kR/s/nPOujg2Bj97cQCVvCwWez16G8nHjYLcfS3Ezvo4NgY/e3EeI4c+yH624kNFDCeJ8fqRH87sYPxvDrWLPrbxOhvJ4YtDndcoHusQ1yhTxRQQQM7GLY4q+M6PTEu1CcWsIINFFBBAzuIzbENbAPbwBZR0eOcjKg4UcE4bnFGRVSc6OBYOOs3TixgPKevgQ0UUEEDO+jg2BhRcWIBsRVsBVvBFqHgsZIRChMjFE4sYAUbKKCCBnYQW8XWsDVsDVvD1rA1bA1bw9awNWyCTbAJNsEm2ASbYBNsgk2wKTbFptgUm2JTbIpNsSk2xWbYDJthM2yGzbAZNsNm2Axbx9axdWwdW8fWsXVsHVvH1rE5Nsfm2BybY3Nsjs2xOTbHNrANbAPbwDawDWwD28A2sI1ti4qThQWsYAMFVNDADjqIrWAr2Aq2gq1gK9gKtoKNLGlkSSNLGlnSyJJGljSypJEljSxpZEkjS9rMkuOa1WaWTCxgBRsoYCgegR10cGycATKxgBVsoIAKYhNsgk2wKTbFptgUm2JTbIpNsSk2xWbYDJthM2yGzbAZNsNm2Axbx9axdWwdW8fWsXVsHVvH1rE5Nsfm2BybY3Nsjs2xOTbHNrANbAPbwDawDWwD28A2sI1tk8cDLGAFGyigggZ20EFsBVvBVrAVbAVbwVawFWwFW8FWsVVsFVvFVrFVbBVbxVaxVWwNW8PWsDVsDVvDRpYIWSJkicwsOe49ZWbJxAKGzQMbKKCCBnbwsI2wRZZMjCw5MWwjsIINPGxHcUSJmq6FBnbQwbExsuTEAlawgdgMm2EzbJElowaOjZElJxawgg0MmwYqaGDfGKkxLDBaiCMU+XCigtFC7L7IhxMdPMpiH3EAjnxYWMAKHjV6jxIooIIGRrvHtkVl1/NHRmADBYz1LYEGdtDBsTH6/IkFrGDYJFBABQ3soINjY32ABawgtoqtYqvYKraKrYbtOMZR/7WwgQIqaGAHHaRdeYAFxCbYBJtgE2yCTbAJNsWm2BSbYlNsik2xKTbFptgMm2EzbIbNsBk2w2bYDJth69g6to6tY+vYOraOrWPr2Do2x+bYHJtjc2yOzbE5Nsfm2Aa2gW1gG9gGtoFtYBvYBraxbfZ4gAWsYAMFVNDADjqIrWAr2Aq2gq1gK9gKtoKtYCvYKraKrWKr2Cq2iq1iq9gqNlIjKuQWYiNLjCwxssTIEiNLjCwxssTIEiNLjCwxssTIEiNLjCwxssTIEiNLjCwxssTIEiNLjCwxssTIEiNLjCwxssTIEiNLjCwxssTIEiNLjCwxssTIEiNLjCwxssTIEiNLjCwxssTIEiNLjCwxssTIEiNLjCwxssTIEiNLjCwxssTIEiNLjCwxssTIEiNLjCwxssTIEiNLjCwxssTIkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlvSZJT1QQAUN7KCDY+PMkokFrCA2wSbYBJtgE2yCTbEpNsU2A8QCFTSwgw6OjTNAJhawgg3EZtgMm2EzbIatY+vYOraOrWPr2Dq2jq1j69gcm2NzbI7NsTk2x+bYHJtjG9gGtoFtYBvYBraBbWAb2Ma2+eMBFrCCDRRQQQM76CC2gq1gK9gKtoKtYCvYCraCrWCr2Cq2iq1iq9gqtoqtYqvYKraGrWFr2Bq2hq1ha9gatoatYRNsgk2wCTbBJtgEm2ATbIJNsSk2xabYyBInS5wscbLEyRKfWXIMnUTZY52vikeWnFjBBgqooIEddHBs7Ng6to6tY+vYOrbIkuNFiBJ1kAsdHBsjS04sYOzJERi2iQIqaGAHHRwbI0tOLGAFsQ1sA9vANrANbGPbojxyYQEr2EABFTRw26Iksh6vR5Sof6zne/8CHi0cb1eUKIFc2EEHx8bIhxOP9a0eWMEGChi2WLPIhxM7eNharG/kw8TIhxMPWxTMREnkwgYKeNhaDYx2Y4sjCSZGEpxYwGhXA6NdC4x2e2C0G+sbSSCxZpEEUdgSxZALx8ZIghMPW9S4REHkwgYKeNiihCVKIWuUpUQt5PMBbmAoYv9G94+qkyiHrFFJEvWQCxsooIIGdvCwaazDfO0+MPr8PLmiz5/YQAEVNLCDDo6N0eej8iXqIhdWMDYo9kP0+RMVNLCDDo6N0edPLGAFsQ1s0ect1jf6/IkddHCcWKNScuFhO16srFEpubCBAoZNAw3sYNh64EqYGpWSCwtYwQYKqKCBHXQQW8VWsVVsFVvFVrFVbBVbxVaxNWwNW8PWsDVsDVvD1rA1bA2bYBNsgk2wCTbBJtgEm2ATbIpNsSk2xRapcbxpW6NScmGcJfMvdNDBsTEC5KilqlEpubCCDRRQQQM7eNh6Cxwb5/1DnNXzV0f83fmrY2K0O/+CgR10cGyM1DixgLEVFthAAcMWHSdS48QOhi06WaTGxEiNE+MOL7ZtVLCBAipoYAcdHAvL/NUxsZ1Pd+os3DwxtsIDDeygg0e7x3O9GoWbCwt4bIWXwAYKGLYRaGAH/XzCVGfh5sR4LHpiASvYQAEVNLBvjCQ4isNqFG4urGADYytiT0YSnGhgB6PSdyrGxlkzPbGAFWyggAoaOObr8jWKNavHH0aXP7GCDRRQwWMjRhyg6PInOjg2RpcfsUeiy59YwcM2YjdElz9RwbBpYNhiK6LLjzjNostPjC5/YgEr2MCwxVkUQXCigR10cGyMIDixgBVsIDbH5tgcm2OLKX0esSdjUp8TC1gPjL0TU/ucKKCCBnbQDwxbTPMTGMWaCwt42I53zGsUay4U8LAdP51qFGu24/3xGsWaCx0cG2PynxMLWMEGChg2CzQwbD3QwbExJgQ68bDVWPWYFOjEBgqooIEddPCwxWRTUcK5MGyxd2KioBMbKKCCfc5EU6Nss8WcUVG2eWJMFnRiASsYhtg5MWnQiQoa2EEHD1vMYxVlmwsLWMHD1mJ9YyKhExU8bC02LaYTOtHBsB2X1SjbbDEHVZRttharExMLndhAARU08Gg32jqC4qSyqW5qm2RRzMTVohfEXFwnGthBB8fG6MAnFrCCDcQ2sA1sA9vANrZtztR1YgEr2EABFTSwgw5iK9gKtoKtYCvYCraCrWAr2Aq2iq1iq9gqtoqtYqvYKraKrWJr2Bq2hq1ha9gatoatYWvYGjbBJtgEm2ATbIJNsAk2wSbYFJtiU2yKTbEpNsWm2BSbYjNshs2wGTbDZtgMm2EzbIatY+vYOraOrWPr2Dq2jq1j69gcm2NzbI6NLGlkSSNLGlnSyJJGljSypJEljSxpZEkjSxpZ0siSRpY0sqSRJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUaWGFliZImRJUaWGFliZImRJUaWGFliZImRJUaWGFliZImRJUaWGFliZImRJUaWGFliZImRJUaWGFliZImRJUaWGFliZImRJUaWGFliZImRJUaWGFkS1ZQtxi6imnLh2LimI6625iOutiYkrrZmJK62piSutuYkrrYmJa62ZiWutqYlrrbmJa5m22HbYdth22HbET37mASgRvnkwg7Gxmjg2Bg9W2Ku8ejZJ1awgQIqaGAHHRwbHZtjc2yOLXq2xCGJnn2igR10cGyMKXgfQWVT3dQ2ySbddLR4PDiufc4bXgJjvKUGNlBABY81PZ4L1z7nEJ/o4NgY/fTEw+ZBdVO4NFBABQ3soINjY/TSEwtYQWwVW8VWsVVsFVv0Uj2OQZRCLixgBRso4GE73ravUQq5sIMOHrZ4FBylkAsLeNjiUXCUQi4UMGwWaGAHHQzb0eWi6LHFI8WYi3GhgApGx4/zafb8OJ9m14/TZfb9WN/Z+WPNZu8P8ez+ExsoYKRMrNmcoXxiBx0MW+zq6Pbx7CqKHls8C4qixxaPeqLosXmsTnR7jw2Kbn9iBx0cG6Pbn1jAsMU6RLc/8VCM2FHR10/soIOHIh7aRKXjwgJWsO1ePL8jMFFBAzvo4Fjo85sCgdF147FPlCEurOAhjodBUYa4UMHYzB7YwdjMETg2Ruc9MTIt1qFWsIECKmhgBx0cG9sDxNawNWwNW8PWsDVsEu3WwGghdlTMXn+8zVWjtHChgR2M9bXAsTHmtj+xgBUMW+y+mOP+RAUN7KCDY2PMd39iASuIzbAZNsMWs98fJYvV58cEJo6N84MCEwtYwcMWj7SitHChgmNjTHJf4ljENPcnxkrG2RdT3Z9oYDzViYMVE96fODbGFTcedEWN4MKwxQGIi+6JsZKx6nHZjYqNqBGUeCAVNYILD1uNIx/T4AdGjeDCAlawgQIqGDYNDJsFhu3Y4pg3UY5SvRoTJ8pRlFejcnChgAoa2EHfGD02nj1FYeBCARU0sIO+MTpZPIaKOQ4XOjg2Rtc7yvpqVPhJPLKKCj85v7HSQAEVNLCDDo6N82MTEwuITbEpNsWm2BSbYlNshs2wGTbDZtgMm2EzbIbNsHVsHVvH1rF1bB1bx9axdWwdm2NzbI7NsTk2x+bYHJtjc2wD28A2sA1sA9vANrANbAPbWLYWdX8LC1jBBgqooIEddBBbwVawFWwFW8FWsBVsBVvBVrBVbBVbxVaxVWwVW8VWsVVsFVvD1rA1bA1bw9awNWwNW8PWsAk2wSbYBJtgE2yCTbAJNsGm2BSbYlNsik2xKTbFptgUm2EzbIbNsBk2w2bYDJthM2wdW8fWsXVsHVvH1rF1bB1bx+bYHJtjc2yOzbE5Nsfm2BzbwDawDWwzKnpgNOaBDo6FZUbFxAJWsIECKmhgBx3EVrAVbAVbwVawFWwFW8FWsBVsFVvFVrFVbBVbxVaxVWwVW8XWsDVsDVvD1rA1bA1bw9awNWyCTbAJNsEm2ASbYBNsgk2wKTbFptgUm2JTbIpNsSk2xWbYDJthM2yGzbAZNsNm2Axbx9axdWwdW8fWsXVsHVvH1rE5Nsfm2BybY3Nsjs2xOTbHNrANbAPbwDawDWwDG1lSyJJCllSypJIllSypZEklSypZUsmSSpZUsqSSJZUsqWRJJUsqWVLJkkqWVLKkkiWVLKlkSSVLKlkS5YAS346LcsCFHTwaOwaGW5QDyjHg3aIcUI63bFoU/snxlk2Lwj45BlpbFPbJMXzZorBvYQGPzdT4Z9HRTxRQQQM76ODYGB1dY32jo59YwcN2DBO2KOETi9WJLn3i0a7Nvzs2Rpc+sYAVbLuF6NInKojNsEWXPnFsjH58YihiV0c/PlFABQ3soINjY/TjEwuIzbE5Nsfm2BybY4t+bHFYoh+fWEABo4U4J6NvWpxG0TcD2/zG3cQCVrCBAh7re4yntigFXNjBw3aMsrYoBTwx+uaJh+0YT21RCriwgQIqaGAHHRwbo2+eiK1iq9gqtoqtYqvYovMew7stSgFPjM57YrTrgdFY7LPovBOjmx7vObQo2ZNjVLhFyd5CBY918Nip0U1PPNbBY3Wim06Ma6yHOHqLhy16y4kGdvBobMTqRG+ZGBfAEwtYwQYe7Y5Y3+giJzoY7caqRxc5sYAVbKCACtrGuFAd478tatkWKmhgBx2MNTvCJmrZFhawgg0UMGwWaGAHHQzbcZZE1Zoc7xu0qFqTY7S5RdXaQgUN7KCDY2N8AvKYDK1F1drCCrYDS6CACtqBEthBB8fG+CzkiQWsYAPDFvushS32Q7ONEi3ELpEKNlDAWLPYYnFwbNQHWMAKNlDAY81K7KjjSrawgw6OjcflS0vsvuPytTAaq4Hxz2LjbWw8OtnCAlawgQIqaGAHsXVsjs2xOTbH5tgcm2NzbI5tRLtxro9oIQ7siBZi/w4DjxZq7L6jQy4cC6MgbGEBK9hAARU0sIMOYivYCraCrWAr2Aq2gi2+0Xq82tHmV1pPHBujm55YwAo2UEAFo93j5JrfZD1e6Gjzq6zHqHub32U9UUAFDeygg2OjPMACYhNsgk2wCTbBJtii8x5PCVoUeS0sYAUbKKCCBnbQQWyGzbAZNsNm2Axb9O7jqUaLwi09nmq0KNxaGLfjcWrEXeaJChrYQQdjfY+OE4VbCwtYwQYKqKCBHXQQ28A2sA1sA9vANrBF7z6eobQoxtLjXZ8WxVh6PBdpUYy1UEAFDeygg2Nj9OMTC4itYCvYCrbox8fDmxbFWAsdHBujH59YwLBZYAMF7BvjEnp+C72AFYwWaqCAChrYQQdjfY/rZsyIt7CAFWyggAoa2EEHsSm26Mfz4+3Rj09s4GGTWN/oxyceNomdGv1Y4ghFP46fylHMdWL04xPDFuLoxyeGbQQetuhZUdKlGrbjBnlhBx0cG+PafWIBK9hAAbF1bB1bx9axOTbHFl1aY+9E541hgKjNUo39EJ33xALGSsbJFZ33RAEVNDDaPfZkVGjpUUPUokJLj+kkWlRoLVTQwA46ODZG5z2xgIft+DJMixqthQKGrQUa2EEHw3bsqKjRWljAsFlgAwVU0MAOOjg2Rkc/sYDYGraGrWGLjh4jI1GjtdDBsTE6+okFDFsPbKCAChrYQQfHxujoJxYQm2JTbIpNsSk2xabYDJthM2yGzbAZNsNm2AybYevYOraOrWPr2Dq2jq1j69g6Nsfm2BybY3Nsjs2xOTbH5tgGtoFtYBvYBraBbWAb2Aa2sW1Rz7WwgBVsoIAKGthBB7EVbAVbwVawFWwFW8FWsBVsBVvFVrFVbBVbxVaxVWwVW8VWsTVsDVvD1rA1bDNLPNDADvrGGRUT45+NQAOPf3YUWLaoE1s4NkYoxIBg1IktrGADBVTQwA46ODYaNsNm2AybYTNshs2wGTbD1rF1bB1bx9axdWwdW8fWsXVsjs2xOTbH5tgcm2NzbI7NsQ1sA9vANrANbAPbwDawDWxj26K8bGEBK9hAARU0sIMOYivYCraCrWAr2Aq2gq1gK9gKtoqtYqvYKraKrWKr2Cq2iq1ia9gatoatYWvYGraGrWFr2Bo2wSbYBJtgE2yCTbAJNsEm2MiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSsbNEHjtL5LGzRB47S+Sxs0QeO0vksbNEHjtL5LGzRB47S+TxwFawFWwFW8FWsBVsBVvBVrAVbBVbxVaxVWwVW8VWsVVsFVvF1rA1bA1bw9awNWwNW8M2s6QFjo0zSyaGTQMr2MCw9UAFD9vxTE2ixG2hg2NjZMmJh+140iZR4rbwsHmsb2SJx5pFlpwYNgnsoINhswMjS04sYNg8sIECKmhgBx0cGyNLTiwgto6tY+vYOraOrWOL1DgeHUqUremIPRn5MGL3RT6c2EEHj/UdsScjH04sYAUbGLbYv5EPI1Yn8uHEDjo4FkZd28ICVrCBAipo4NNmx+sVEnVtdjzlkqhrO/HIBzveiJCoa7PjUZFEXdvCBh7/7HhqJFGKZiXaPTqvHTX/EkVnCzvo4Nh4dN6FBaxgAwXE1rA1bA1bwybYBJtgE2yCTbAJNsEm2ASbYlNsik2xKTbFptgUm2JTbIbNsBk2w2bYDJthM2yGzbB1bB1bx9axdWwdW8fWwxZnX3dwbPQHWMAKNlBABQ3E5tgc28A2wtYDK9hAARU00HcXGWNhVJotLGAFGyigggZ20EFsBVvBVrAVbAVbwVawFWwFW8FWsVVsREXMTLcQW8VWsVVsFVvF1rA1bA1bw9awNWwNW8PWsDVsgk2wCTbBJtgEm2ATbIJNsCk2xabYFJtiU2yKTbEpthkgx0WizgCZWMAKNlDAw3Y8SpYocVsYthHo4NgYAXI8HpaodltYwQYKqKCBHXRwbHRsjs2xOTbH5tgcm2NzbI5tYBvYBraBbWAb2Aa2gW1gG9sWlXELC1jBBgqooIEddBBbwVawFWwFW8FWsBVsBVvBVrBVbBVbxVaxVWwVW8VWsVVsFVvD1rA1bA1bw9awNWwNW8PWsAk2wSbYBJtgE2yCTbAJNsGm2BSbYlNsik2xKTbFptgUm2EzbIbNsBk2w2bYDJthM2xkSSNLGlnSyJJGljSypJEljSxpZEkjSxpZ0siSRpY0sqSRJY0saWRJI0saWdLIkkaWNLKkkSWNLGlkSSNLGlnSyJJGljSyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMgSIUuELBGyRMkSJUuULFGyRMkSJUuULFGyRMkSJUuULFGyRMkSJUuULFGyRMkSJUuULFGyRMkSJUuULFGyRMkSJUuULFGyRMkSJUuULFGyRMkSJUuULFGyRMkSJUuULFGyRMkSJUuULFGyRMkSJUuULFGyRMkSJUuULFGyRMkSJUuULFGyRMkSJUuULFGyRGeWtMACVjBsEiigggaGTQPDZoFhO34a6cySiQWsYAMFVNDADjqIbWbJCCxgBRsooIIGdtDBsXFgG9gGtpklPVBABQ3soINjoc0smVjACjZQwMN2lHNK1GUu7KCDY2NkyYkFrGADBcQWWXIUj0rUZS70jZEaJ0YLLTBakEADO+hgrO9x9kVd5sICVrCBAipoYAcdxCbYBJtgE2yCLfLhqCOVqMtcGDYPdHBsjHw45uGTqMtcWMEGCqiggR08bBIHK/JhYuTDiQU8bEeRp0Rd5kIBFTTwsEmciJEPJ46NkQ8nFrCCh03jLIl8OFFBAw+bhjjy4cSxMfJB49yJfDjxsGnYIh9OFFBBAzvo4NgY+XBiAbENbAPbwDawDWwD29i2+FLxwgJWsIECKmhgBx3EVrAVbAVbwVawFWwFW8FWsBVsFVvFVrFVbBVbxVaxVWwVW8XWsDVsDVvD1rA1bA1bw9awNWyCTbAJNsEm2ASbYBNskSVH/a9E6eeJkSVHKbBE6efCCjbwsB0luxKlnwsN7KCDY2NkyYkFPGxHea9E6efCiKsSaGAHQ6GBY2MEiMUWR4CcWMFQxMZHgJyoYGxQbHEEyIkOjo0RICcWsIINFFBBbL6fIvb5vGViASvYQAEVNLCDDm6bPx5gASvYQAEVNLCDDmIr2Aq2gq1gK9gKtoKtYCvYeB7rFVvFVrFVbBVbxVaxVWwVW8XWsDVsDVvD1rA1bA1bw9awNWyCTbAJNsEm2ASbYBNsgk2wKTbFptgUm2JTbIpNsSk2xWbYDJthM2xx23HMGypRELrQwA46ODZGavRoLFLjxAoetiiCiYLQhQoa2EEHx8ZIjRMLWEFsjs2xOTbH5tgc28A2sA1sA9vANrANbAPbwDa2LQpCFxawgg0UUEEDO+ggtoKtYCvYCraCrWAr2Aq2gq1gq9gqtoqtYqvYKraKrWKr2Cq2hq1ha9gatoatYWvYGraGrWETbIJNsAk2wSbYBJtgE2yCTbEpNsWm2BSbYlNsik2xKTbDZtgMm2EzbIbNsBk2w2bYOraOrWMjSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMnaW6GNniT52luhjZ4k+dpboY2eJPnaW6GNniT52luhjZ4k+HtgKtoKtYCvYCraCrWAr2Aq2gq1iq9gqtoqtYqvYKraKrWKr2Bq2hq1ha9gatoatYWvYGraGTbAJNsEm2ASbYBNsgk2wCTbFptgUm2JTbIpNsSk2xabYDJthM2yGzbAZNsNm2AybYevYOraOrWPr2Dq2jq1j69g6Nsfm2BybY3Nsjs2xOTbH5tgGtoFtYBvYBraBbWAb2AY2sqSQJYUsKWRJIUsKWVLIkkKWFLKkkCWFLClkSSFLCllSyJJClhSypJAlhSwpZEkhSwpZUsiSQpYUsqSQJYUsKWRJIUsKWVLIkkKWFLKkkCWFLClkSSFLCllSyJJClhSypJAlhSwpZEkhSwpZUsiSQpYUsqSQJYUsKWRJIUsKWVLIkkKWFLKkkCWFLClkSSFLCllSyJJClhSypJAlhSwpZEkhSwpZUsiSQpYUsqSQJYUsKWRJIUsKWVLIkkKWFLKkkCWFLClkSSFLCllSyJJClhSyZNanHi8b6KxPnTizZOJhe8TfjSw58bAdMyTprE89UcHDdpR7a0yKuDBsGjgWzlLV480FnaWqJ1Ywtm0ECqiggR10cGycWTKxgBXEVrAVbAVbwVawFWyRGsfrFTrLT493KnSWnx7vVOgsPz3RwbEx8uF4kUJn+emJFWyggGHzQAM76ODYGPlw4mEbsQ6RDyc2UMDDdryYoLP89MQOHrYRhzvyYYQi8uHEAlawgQIqaGAHHcRm2AybYTNshs2wGTbDZtgMW8fWsXVsHVvH1rF1bB1bx9axOTbH5tgcm2NzbI7NsTk2xzawDWwD28A2sA1sA9vANrCNbZvlpycWsIINFFBBAzvoYNiOHjvLT0982voxUZxG+enCBgqoB7ZAAzvo4Nh43GssLGAFwyaBAoZCAzvo4NjYQmGBBaxgA2Vl1Kw5PdHADjo4Ns4AmVjACur54pJGdenCDjo4NsZ7aicWsIINFBCbYlNsik2xGTbDZtgMm2EzbIbNsBk2w9axdWwdW8fWsXVsHVvH1rF1bI7NsTk2x+bYHJtjc2yOzbENbAPbwDawDWwD28A2sA1sY9vk8QALWMEGHt3peOFMo7p0oYFHzzqGxDWqSxeOjUdULCxgBaNn9UABFQxbrE5ExYkOhu3ox1FdurCAFWyggAoa2EEHsTVsDVvD1rA1bA1bw9awNWwNm2ATbIJNsAk2wSbYBJtgE2yKTbEpNsWm2BSbYlNsik2xGTbDZtgMm2EzbIbNsBk2w9axdWwdW8fWsXVsHVvH1rF1bI7NsTk2x+bYHJtjc2yOzbENbAPbwDawDWwD28A2sA1sY9uiunRhASvYQAEVNLCDDmIr2Aq2gq1gK9gKtoKtYCvYyBIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyJJOlvSZJRZYwQaGzQMVPGzHW9QalagLHTxsx/sMGpWoCwtYwQYKqKCBYauBDo6NkSUnhk0CK9hAARUMW2x8ZMmJDobt+PUVlagLC1jBBgqooIEddBCbYBNsgk2wCTbBJtgEm2ATbIpNsSk2xabYFJtiU2yKTbEZNsNm2AybYTNshs2wGTbD1rF1bB1bx9axdWwdW8fWsXVsjs2xOTbH5tgcm2NzbI7NsQ1sA9vANrANbAPbwDawDWxj26JUdWEBK9hAARU0sIMOYivYCraCrWAr2Aq2gq1gK9gKtoqtYqvYKraKrWKr2Cq2io0scbLEyRInS5wscbLEyRKfWeKBh+0oy9YoVV04NkaWnFjACjZQQAUNxCbYBJtiiyw5JlLXKFVd2EABFTQwbCPQwbExsuTEAlawgQIqaCA2w2bYOraOrWPr2Dq2jq1j69g6to7NsTm2SI3jRSCNQtMusaMiCU4s4LFmxxzwGoWmCwVU0MAOOjgWRqHpwgJWsIFhs0AFDeygg2NjJMEx47xGoenCCjbwsB1vIGkUmi408LBprFnZez0KTU+sD7CAFWyggAoa2EFsFVvD1rA1bA1bw9awNWwNW8PWsAk2wSbYBJtgE2yCTbAJNsGm2BSbYlNsik2xKTaSYJAEgyQYJMEgCQZJEIWm/XjLTKPQdGGcJRpoYAcdPGzHuzsahaYLC1jBBgqooIFhi5WMJDgxti1WMu4fLE7wuH84UUAFj3YtzvW4fzjRwbFxPm+Jfzaft0ysYAMFVNDAfqJF8Wg/XjCyKB5dWMEGCqhgrG87MPr88YEBi4LQfrxrZFEQulDAaMECDYz90AMdHBujzx9vIFkUhC6sYAMFVNDAsI1AB8fG6PMnFrCCx14/0fZ+iN59InsnenePvR69+8QCVrCBx1Ycr1dYlH4uNLCDh62HLXr3xOjdJ4YtDkD07hMbGLY4FtG7TzQwbHHko3f3OCzRu3vs1OjdPXZJ9O4TK3i067Ft0Y9P7KCDR7se2xY9dp5c0WNPFFDBvnF+VCTWbH5UZGIFj0OosWbxWPREBQ3soINj4/wWycQCHivpsc/iMn6igR2MjY+DFZfxwKjLXFjA2AoJbKCAChrYQQfHxpj098Sj3eONayvzQ0ITYyvmXzCwgw7GVhwnV1RgLixgBRso4LEVx3eCLCowF3bQwbFxf3TIyv7okJX90SEr86NDEwWMrYjNjM574tgYnffE2Ir4Z9F5T2yggLEVJdDADjo4Ns7PC00sYAXjWHiggR10MLbiOCejqnJhASvYQAEVNPCwxQUlqioXjo1xET7xsI1Y9ejSJzZQwGOf1dh9UQpxYgcdHBvnx8MmFrCCDYx2a2BsxUQHx8a4dR/R9eLWfcRJELfuJzZQQAUN7KCDYTvWLCol+1HHZHV+7q8Fxt8dgWNj3HifWMBnC37UMVlUPy4UUEEDO+jg2OswP+w3sYAVbKCAbEX04xP7xqPH+lFoalET6UdRqkVN5MIGChhbMVswsIOxFRI4NsoDLGAFGyhg2DTQwA6GzQLHRn2ABaxgAwUMW5wPamAHwxZniY6N9gALWMEGChi2OHfMwA4ethJH6OjdXmL/Hr3bS+ydo3d7if1w9O6FDRTwsJXYiqN3e4l1OHq3l7B1B8dGf4CHrcbqHL3box9HTaTPM+q4oi9U0MCwxQnuDo6N4wEe5/pc37jxPrGBAipoYAcdHAuj+tGPEW+L6seFAioYW6GBHXRwbDzyYWEBK9hAAaNdC3RwbKzRbqx6LWAFGyhgtHsc7ihj9GPiH4syxoUVbKCAen5f2qKMcWEHHRwb45vyJxawgg089m+b2EEHx8bo3XE9jtJEP8bELEoTF3YwWmiBY2P02BOPLW5xjKNvxj1XFCF63KJEEeK5H6Jvnujg2NjZv539G72wxQGIXniigR308wvrNr9xPXF+Bn5iASvYQAEVNPBoNzpZFBYuLOBxPsjEBh5bIbFTj/620MBjKyR26tHfFo6FUVj4HD4NLGAFGyhg2DzQwA46ODZGLzyxgBWMdkfgsdcjaaMs0I9BM4uywIUNPNZM599V8FizYwYfi7LAhQ4ea6axH6IXnljACjZQQAXDJoEddHBsjCvviQWse4vjGquxq6MXnthBB6Pdo4tEAeDCAlbwOCfjniAKABcqaGAHHRwbjx574tFFnj9eYq8efWTx0Uk2l8Q1cUssiTWxJe6Jk9eTdyTvwBu1b0/W4JK4Jm6JJbEmtsQ9sScecEnekrwleUvyluQtyVuStyRvSd6SvDV5a/LW5K3JW5O3Jm9N3pq8NXlr8rbkbcnbkrclb0velrwteVvytuRtySvJK8krySvJK8krySvJK8krySvJq8mryavJq8mryavJq8mryavJq8lryWvJGzeDMdoU1WULBVTQwA46ODbGzeCJBcQ2sA1sA9vANrANbGPborpsYQHD5oENFFBBAzvo4NgYF6cTC4itYCvYCraCrWAr2Aq2iq1iq9gqtoqtYqvYKraKrWJr2Bq2hq1ha9gatoatYWvYGjbBJtgEm2ATbIJNsAk2wSbYFJtiU2yKTbEpNsWm2BSbYjNshs2wGTbDZtgMm2EzbIatY+vYOraOrWPr2Dq2jq1j69gcm2NzbI7NsTk2x+bYHJtjG9gGtoFtYBvYBraBbWAb2Ma29ccDLGAFGyigggZ20EFsZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLIkqssWYiNLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0sieoyj6GKqC7zeCYU1WULK9hAARU0sIMOjoVRXbawgBVsoIAKGtjBsEng2BhZcmIBK9jAsFmgggYetngOEdVlC8fGyJITC1jBBh62eDIQ1WUeTwaiumxhBx0cGyNLTixgBRsoILaGrWFr2Bo2wSbYBJtgE2yCTbAJNsEm2BSbYlNsik2xKTbFptgUm2IzbIbNsBk2w2bYDJthM2yGrWPr2Dq2jq1j69g6to6tY+vYHJtjc2yOzbE5Nsfm2BybYxvYBraBbWAb2Aa2gW1gG9jGtkV92sICVrCBAipoYAcdxFawFWwFW8FWsBVsBVvBVrAVbBVbxVaxVWwVG1kyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJKxs6Q/dpb0x86S/thZ0h87S/pjZ0l/7Czpj50l/bGzpD92lvTHA1vBVrAVbAVbwVawFWwFW8FWsFVsFVvFVrFVbBXbzBIN7KCDY+PMkokFrGDYeqCAChrYQQfHxiNLxvHYv0c13MIKtgNjK44sWahg2GpgP/7UAh0cG/UBFrCCDRQwbCPQwA46ODbaAyxgBQ9bia04smShgoetxDocWbLQwcNWY+OPLFlYwAo2UEAFDTxsx6PmHhMhLhwb/QEWsIINFDBssepuYAcdHBvHAyxgBRsoILaBbYTNAx0cC6PgbmEBK9hAAaMHlEADO+jg2DizZGIBK9hAAbEVbAVbwVawVWwVW8VWsVVsFVvFVrFVbBVbw9awNWwNW8PWsDVsDVvD1rAJNsEm2ASbYBNsgk2wCTbBptgUm2JTbIpNsSk2xabYFJthM2yGzbAZNsNm2AybYTNsHVvH1rF1bB1bx9axdWwdW8fm2BybY3Nsjs2xOTbH5tgc28A2sA1sA9vANrANbAPbwDa2rT4eYAEr2EABFTSwgw5iI0sqWVLJkkqWVLKkkiWVLKlkSSVLKllSyZJKllSypJIllSypZEmUAo42sYMOHql8lMP0KBBcWMAjlY8imR4FggsFPK4Bx6slPQoEF3bwsEnYjiw5Me5LTjxsEra4LzmxgWssqNd5XxJiMbCD+06hyr5TqPoAy7r6R4HgwgbKuvpHgeBCAw+bzMYcHBvjvkRj2+K+5MQKHjYNW9yXnKjgYTtKMHoUCC50cN9PzgLBEwtY1y3gLBA8UUBdt4BRILiwg75uAaNA8MS4Lzlx3+FFgeDCBsre666ggX3v9bgvOXFsjPuSudfjvuTECu57rjoEVNDWvVEdHXRw3wW1xwMs4L4vadyXNO5LZlWgx9+dg6gaWMEGCqiggR10cGyMUDgRW8VWsVVsFVvFVrFVbBVbw9awNWwNW8PWsDVsDVvD1rAJNsEm2ASbYBNsgk2wCTbBptgUm2JTbIpNsSk2xabYFJthM2yGzbAZNsNm2AybYTNsHVvH1rF1bB1bx9axdWwdW8fm2BybY3Nsjs2xOTbH5tgc28A2sA1sA9vANrANbAPbwDa2bVYxnljACjZQQAUNjDC3wAjzETg2lgdYwAo2UEAFDewgtoKtYqvYjiwZx1uUPeogFwqooIEdDFsPHBvjBuPE9SypzzLHEw3soINjY9w/HC9J9ihzXFjBWPUWKKCCseoS2EEHx8a4fzixgBVsoIAKxn1f7B3toINhi7Mk7h9OLGAFGyigggbGtnmgg2NjjGucWMAKNlBA3RhXdItzJ67oJzq4x9pkj1p22aOWXfaoZZc9atllj1p22aOWXfaoZZc9atllj1p2YdRSGbVURi2VUUtl1FIZtVRGLZVRS2XUUhm1VEYtlVFLZdRSGbVURi2VUcsowhzH+6g9ajAXdtDBsTE674kFrOBx3I63SXvUXi5U0MAOOhi2WMnovCcWsIINFFBBAzvoIDbZ97QqBaxg2CRQQAUN7KCDY2P07hPD1gMr2MCwxTpE7z7RwA46ODZG7z6xgLEnPbCBAipoYAcdHBujd5942I73fXvMR7iwgQIqaGAHHRwb49eBx7kTvw5OrGD8Oph/V0AFwxYnQWTJiQ7u3yJRMbqwgGGLoxm/Dk4UMLYtjmb8Ojixgw6OhVExurCAFWxg2Ebg0UJEfFSBLixgBRsooIIGdnCPxUcV6In1AYatBFawgQIqaGAHHYxtO3ZqVIEuLGAFGyigggZ2MGyxFZEPE+Pqf2IBwxYHIPLhRAEVNLCDDo6NkQ8n7ucMphVsYNg8UEEDO+jg2Bj5cGIBj2rvR/SRKAPdLIk1sSXuiT3xgI+c2Dzbb8Hz78ex6AP2R+KSuCZuiSWxJrbEezjAGA4whgOirPP5lzW4JK6JW2JJrIktcU88NzZ2+Bibo8Bzc0lcE7fEklgTW+LwHm9g9Sj03DzgeLVjcXiPV3h6FHtuboklsSa2xD2xJx5w3cMuUfS5sIJTWoMlsSa2xD2xJx5weySeG6vBNXFLLIk1sSXuiT3xgGW2H9slLbEk1sSWuCf2xAPWR+KSOHk1eTV5NXk1eTV5NXk1eS15bXrjxJtJcrzj2/tMkhon2EySGifATJKTLXFP7IkHPJPk5JK4Jm6Jk7cnb0/enrw9eXvyevJ68nryevJ68nryevJ68nryevKO5B3JO5J3JC/jlJ1xyj4MnNLJnnhs9plIJ5fENXFLLInnxmqwJe6JPfGAZyKdXBLXxC3x9FqwJrbEPbEnHnB9JC6Ja+L9RDyqRxcqOKU9uCf2xAOeiXRySVwTt8SxscdLy91nIp1siXtiTzzgeNNscUlcE4c3ntH4TKqTpzd2/kyqeEwTJaVzQDtKShfuwe8oKV1YwAo2UEAFDcSm2GY6HS8+d5/pdHJJXBO3xJJYE1vintgTT++ReD7T6eSSuCZuiSVxtHO83Nx9ps3JJXFN3BJL4lj/eLblM20mz1sUiWM3b1FO7olju+I5k89ACB4zEE4uiWvillgSa2JL3BN74vAe7zn3MQPh5JK4Jm6JJbEmtsQ9cXjjodeYgRBPyMYMhJNL4pq4JZbEmtgS98S7ciXqQE9sD3BKLbgmboklsSa2xD2xJ54bGzt8BsLJJXFN3BJLYk1siTusewAvCjgXOrgHuSjg7BRwdgo4OwWcnQLOTgFnp4CzU8DZKeDsFHB2Cjg7BZydAs5OAWengLNTwNkp4OwUcHYKODsFnJ0Czk4BZ6eAs1PA2Sng7FHAOcfcooBzYQcd3AN4UcC5sIAV3AN4UcC5UEEDO+hgnETHLIf+mAlxcpxEx0C5P2ZCnNwSS2JNbIl7Yk884Bj1OC5CHrWcCys4pS1YEmtiS9wTe+IBz3g4eW6sBtfELfH0xvrMeDjZEvfEnnjA85bh5JJ4ekdwSyyJNbEl7ok98YBnQpwc3uMU8sdMiJNbYkmsiS1xT+yJBxx3DS20cddwYgWnNM66+cvmZE1siXtiTzzgee9w8txYCa6JW2JJrIktcU/siQccY6ke2j2W6o89luqPPZbqjz2W6o89luqPPZbqjz2W6o89luqPeYvR45yctxgnl8RRJBN/PYZTTxRwbmOcePP+4uSeeG6jBw94/po5eUrjOM5fMye3xLFvPXr6vH852RL3xJ54bC4znU4uiWvi8B7DwF5mOp2siS1xT+yJBzzvX04uiVclkkd96EIBp3SyJe6JPfGAZzqdXBLXxHNje7Ak1sSWuCf2xAOe6XRySRyn8Ahcw8pe5tDrxLFRHmABK9hAARVchVteduGWl11Q7mUOvR6ncplDrxMLWMEGCqiggWtY2cscep04NtoDLGAFGyiggmGLrYhHMyc6ODb2NazsUQS6sIINFFBBAzvo4CqB8+IPsID1HGH2KAJdKKCCBnbQwbFx7OFkL+dI7eSauCWWxJrYEvfEexjb6zki24L3cLLX2f1P9sQDLo/EJXFN3BJL4vUegUdV58IOTqkGD7g+EpfENXFLLIk18R5O9jq7/8meeMDtkbgkrolbYkk8RyIfwZa4J/bEezjZ67w5ObkkrolbYkmsiS1xT7ze1/BZ8zlRH+CU1uCauCWWxJrYEvfEnngPJ3s9h10nl8Q1cUssiTWxJe7wHMDwOChzAOPkmrgllsSa2BL3xJ54wJ68nryevJ68nryevJ68nryevPOGJK4WdSZJBHidSTJin88kGdHRZpKcLIk1sSXuiT3x2NzmDcnJJXFN3BJLYk1siXtiT5y8JXlL8pbkLclbkrckb0nekrwleUvy1uStyRtPfY5xH4/K0oUCTqkEW+Ke2BMPeCbSySVxTTw3tgdLYk1siXtiTzzgmUgnl8TT68EtsSTWxJa4J/bEA57Pgk5epeEeNacLGzilsZNnIp1siXtiTzzgmUgnl8THxpZjml+P4tPNklgTW+Ke2BMPOJJqcQm24Jp4emPn9+mNndNXLbxHIerCDjo4NsZNzokFrGADBcTm2CKdSlzOohJ184AjnRaXxDVxSyyJNbElnt44B4YnHpujKnVzSVwTz3Y02BMPuDwSl8Q18Vx/Cxa4zj/vwZJYE8d21VifCITFnnjAEQiLS+KauCWWxJo4edv0SrAnHrA8EpfENXFLLIk18fTGtsv0xj4UTzxgfSQuiWvillgSa+L1wohHeelCB6f06FxRX7q5JK6JW2JJrIktcWxsix0+A+HkAc9AOLkkrolbYkmscPTcGOuKiTwXGrgGel32u/NOFapThepUoTpVqE4VqlOF6lShOlWoThWqU4XqVKE6VahOFapThepUoTpVqE4VqlOF6lShOlWoThWqU4XqVKE6VageVagxwuxRhbpQQQM76ODYuKtQ/axCrYEVbKCAChq46kL9rEKdODbuKlSnCtWpQnWqUJ0qVKcK1alCdapQXef7rho4Nu4qVI8q1CgR9ahCXdhAARU0sIMOjrOy1HW+7zqxgGGLdYhbgxMFVNDADjo4NtqqC/WzCnViBRsooIIGdtDBVRfqysgpVahOFapThepUoTpVqE4VqlOF6mcVapw7swo1cFeh+qxCjWGCWYV6YgPDFidBZMmJBsYQ1UQHx8Z4jBNjdrMK9cQKrrpQP6tQJypoYAcdXFWoThWqU4XqZxXqCNwDeDEX6cI9gEcVqlOF6lShOlWoThWqU4Xqswo17t9mFeqJDu4BvFmFemIBK9hAARU0cA/gnVWoE/cAHlWoThWqU4XqVKE6VahOFaqfVaixFa2DDu4BvLMKNQ6AFLCCDRRQQQM76OAewLP9DqtTheqzCjV+UMwq1BMFVNDADjq4B/DMGMAzK4lr4pZYEmtiS9wTM4BnnQE86wzgWe+JPTEDeKkO1VMdqqc6VE91qJ7qUD3qUOdQXZShLuwgA3jmDOClOlRPdaie6lA91aF6qkP1VIfqqw41dvjoiT0xA3ipDtVTHaqnOlRPdaie6lD9rEONXxhnHerJPbEnZgBv1aFOLolr4pZYEmtiS9wT7wG8KEM9cVeheq8M4PVaE7fEklgTW+Ke2BMzgLfqUCeXxDVxSyyJNbElZgCvy67L9C4lcU3cEktiTWyJe2JPPGBNXk1eTV5NXk1eTV5NXk1eTd5zQDROvHNAdATPKro4wWzXR/qqQ50siTWxJe6JPfGAqUP1VIfqqQ7VUx2qpzpUT3WonupQPdWheqpD9VSH6qkO1VMdqqc6VE91qJ7qUD3VoXqqQ/VUh+qpDtVTHaqnOlRPdaje5yw+cZrvt+WdKlTvM5FOtsQ9sSfedaie6lA91aF6qkP1VYeqwZJYE1vintgTD5g6VE91qL7qUC24JZbEmtgS98SeeMDUoXrUoUZlqUcZ6sIGTmkP1sSWuCf2xAOmDtVTHaqfdahHPaifdagnS2JNbIl7Yk88YOpQfdWhxnaddaiTpzd2/lmHGjtHVl2oRxnqwg46ODbuKlSnCtWpQnWqUJ0qVKcK1alCddddD+qunnjA1KF6qkP1VIfqqQ7VUx2qpzpUT3WovupQR7AnHjB1qJ7qUD3VobrPtDlqRt1n2pw8YOpQPdWheqpD9VWHGsfrrEMNnrcoEsdu3qKcrIl3PaivOtTJnnjXoXqqQ/VUh+qpDtVTHaqnOlRPdaie6lD9rEM96kH9rEM9ecDUoXqqQ/VUh+qpDtVTHaqnOlRfdagavOtBfdWhTh4wdaie6lA91aF6qkP1VIfqqQ7Vow41Kks9ylAXOjilx4k9ZiCcXBLXxC2xJNbElnjXg/qqQ508YOpQPdWheqpD9VSH6qkO1VMdqo856tliw+eo58k1cUssiTWxJe6JPfGALXkteS15LXkteS15LXkteS15LXl78p4DnxJcE7fEklgTW+Ke2BMPOAZCYsw06lkXVnBK42x3SayJLXFP7IkHPB+JnDw3Nk7g+Ujk5JZYEmtiS9wTe+KxeMz61nIk55j1rYtr4pZYEmtiS9wTe+LjinXs43GWt04sYEiPL6mNWd+6WBJrYkvcE3viAUfslCPex6xvXVwTt8SSWBNb4p7YE09vbNd8DiMW3BLP9nuwJrbEs/04WPM5zMkDns9hTi6Ja+KWWBJrYkucvJK8kryavJq8mryavJq8mryavJq8mryavJa8M5EkTrCZSCe3xJJYE1viYzD7GBccs6qyHCNbY1ZVLq6Jo/ljRGvMqsrFmtgS98SeeMDzseLJJXFNnLwleUvyztN8xLbM0/kYnRqzCHL9+Vy3EXysWz2+qTtmEeTiAc/vh51cEtfELbEEl2BNbImntwZPbwue3tjP8/thx8DPKPPUntsyT+2T0zbO09ZjHeZpe/KA52l7cklcE7fEklgTW+Lpje2ap63Hds3TdvI8bU8uiac3tn2etidLYk1siXtiTzzgecH02J/zwuixP+fF0OOcmRfDef7Pi+FkfyQuiSXxbCf2/7y+nTzbiXNsXsdG7Kt5XRqxr+Z16eSxuZ59sAaXxDVxSzz7QgvWxJb+Tk/siQc8+2Dsn1nauLgmbolt74da2A+zinHxgGNilmNyozG/62zRSszQdqKAChp4PMo83o8Y8wvOFu54+HViBRsooIIGRruxkjHB0oljY7zDdGIBK9jAsI1ABQ3soINjY7zDdGIBD8Xx4HTMWRlPVNDADjo4Ns4v4kwsYAWxObb5RZw4S+cXcSZ20MGxcX5dayIHa3CwBgdr7IPV5meyamCsTgsUUEEDY3Uk0MGxcX4Qa2IBK9hAARU0EFvBVrBVbBXb/ApWbNv8CpYGdtD3Bs3vXQXO711NLGCsugU2UMBY9dip83tXEzuIrWETbIJtfu9qIodFOCzCYREOy/ze1URsiiK6qcbqRDc90cAOHi2oB46N0U1PLOCxvsfvyDGnTDxRQAUN7KCDY2N00xMLiK1j69g6to6tY+vYom8eU+SNOQ3i8TLemHMfWpw70fVOdHBsjK53YgErGF0vDsDsehMVNLDvdYjClRPHwjn34YkFrGADBdSN82bu+JLykHmBOTkuMDr/jice8Lz5OzkuYMcQzZD5G+fkllgSa2JL3BN74gHPGrSTk3f+rjmGa8ZZX3Z8W3mc9WXHkNE468tOHvD8XXNySVwTt8SSWBNb4uSV5JXk1eTV5NXk1eTV5NXk1eTV5NXknTeIx2jSOEvMTi6JJfH8+0cAnKVhJ5fENXFLLIk1sSXuiR2eN4IRJvPD0Ytr4pZYEmtiS9wTe+IBz8GQSAKZgx4RBTIHPU62xNHm7Efz5vLksXl+dHpxSVwTt8SSWBNbYlyzbCx225y88EQBFbSV0VE2ttDBHe1RNjZDUWsBK9hAARU0sIMO7mjXhq1ha9gatrigxgGYpWBzP8gO2zkL4YkNFFBBAzvoK4Jn/dfEeQs8sYA7bOcshCcKqKCBHXSQDbIHKDuX1TRx/MA9HqWMqPDa7IkH3MlrPfvwZPJae0ssiTWxJe6JPTF5rf5IXBInryevJ+/ZV2N7z74aPAcxTy6Ja+KWOO3DkfbhsMQ9cfIOvPZ4JC6Ja+KWWBJrYkuM1+bH4o/Hk8MK+8Tmh+CPZ6jDzut0Ce6JPTHXaUvXaaslcU2cXOk6bek6bek6bek6bek6bek6bek6bXP8Ma7Ndl6nYxsb1y1L12lL12lL12lL12lL12lL12lL12lL12lL12lL12lL12lL12lL12lL12lL12lL12lL12lL12lL12lL12lL12k7r9MWzHXa0nV6lnMt5npp6Tpt6Tpt6Tpt6Tpt6Tpt6Tpt6Tpt6Tpt6Tptneulpeu0peu0peu0peu0peu0peu0peu0peu0peu0nf19BM/rZfSXdJ22dJ22wfXS0nXa0nXa0nW6p+t0T9fpnq7TPV2ne7pO93SdntVaJ8egTj1KAcacve/k+kic/k70x8UtsSTWxJa4J/bEyduStyVvS96WvC15W/K25G3J25K3Ja8krySvJK8krySvJK8krySvJK8kryavJq8mryavJq8mryavJq8mryavJa8lryWvJa8lryWvJa8lryWvJW9P3p68PXl78vbk7cnbk7cnb0/enryevJ68nryevJ68nryevJ68nryevCN5R/KO5B3JO5J3JO9I3pG8I3kH3llTtbgkrolbYkmsiS1xT+yJk7ckb8qWWVO1OHlL8pbkLclbkrckb8orT3nlKa885ZWnvPKUV57yylNeecorT3nlKa885ZWnvPKUV57yylNeecorT3nlKa885ZWnvPKUV57yylNeecorT3nlKa885ZWnvPKUV57yylNeecorT3nlKa885ZWnvPKUV57yylNeecorT3nlKa885ZWnvPKUV57yylNeecorT3nlKa885ZWnvPKUV57yylNe+ZlXI9gS98SeeMBnXk0uiWvillgSJ68nryevJ68n70jekbwjeUfyDryzVKsepX5jlknV402OMcukFmtiS9wTe+L58PPYn7NMavF86OrBNfH0xvrMPn5yeEus2+zjJ4f3qCAfY/bxk8N7FHaPWSm1OLxHZf+YlVKLw1skWBJPrwZb4umNbZx9/OTpjW2cffzk6Y1tnH385OmNbZx9/OR5DsQ2nn188jwHYhvPPj55ngOxjWcfnzzPgdjGs48HG78Hz4qlk/kdelYsnVwS18QtsSTWxJY4eXvy9uT15PXk9eT15PXk9eQ9+0gcx8GYwDjP/ziO52/22Ifnb/bJlrgn9sT79295nJVHa2HbjoWaF1pekLygecHyQs8LnhbmY9zjF++xMJuWubB/Gx4LmhcsL/S84HlhpIX6yAslL9S80PJCXoOa16DmNah5DWpeg5rXoOU1aHkNWl6Dlteg5TVoeQ3O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",
      "brillig_names": [
        "process_message"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1778400301998778977": {
            "error_kind": "string",
            "string": "Function getKey can only be called internally"
          },
          "2125632064870291657": {
            "error_kind": "string",
            "string": "TMS2"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2852997348194806652": {
            "error_kind": "string",
            "string": "LA"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4236375919801895216": {
            "error_kind": "string",
            "string": "Input must be non-zero"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6302762939807105431": {
            "error_kind": "string",
            "string": "TMS1"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6687445788383290001": {
            "error_kind": "string",
            "string": "ALREADY CREATED"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7746884635884052893": {
            "error_kind": "string",
            "string": "M0"
          },
          "7790603980827850929": {
            "error_kind": "string",
            "string": "NP"
          },
          "7975540805721646923": {
            "error_kind": "string",
            "string": "M1"
          },
          "8706431785795792289": {
            "error_kind": "string",
            "string": "LS"
          },
          "8786903978971566366": {
            "error_kind": "string",
            "string": "only admin"
          },
          "8990147487291335284": {
            "error_kind": "string",
            "string": "TUM"
          },
          "9889304366186256219": {
            "error_kind": "string",
            "string": "ZERO_ADDRESS"
          },
          "10810264164364750393": {
            "error_kind": "string",
            "string": "TLU"
          },
          "11313697656972294845": {
            "error_kind": "string",
            "string": "AI"
          },
          "11988312628175324067": {
            "error_kind": "string",
            "string": "LO"
          },
          "13265554733035650515": {
            "error_kind": "string",
            "string": "BigNum::validate_gt check fails"
          },
          "13462284035020069151": {
            "error_kind": "string",
            "string": "Denom must be > 0"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14531954490500154755": {
            "error_kind": "string",
            "string": "NOT_SET"
          },
          "14875087550202939583": {
            "error_kind": "string",
            "string": "TLM"
          },
          "15690125140784469321": {
            "error_kind": "string",
            "string": "bad denominator"
          },
          "15847354018858285526": {
            "error_kind": "string",
            "string": "SAME_TOKEN_PAIR"
          },
          "16540924638517508128": {
            "error_kind": "string",
            "string": "ZERO_SPACING"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIDqJwAABAMnAgIEAScCAwQAHwoAAgADgOkuCIDpAAElAAAARSUAAA2SKAIAAQSA6icCAgQAOw4AAgABKACAQwQALCkAgEQE//J2GCkAgEUEAA2J6CgAgEYEAA0pAIBHBP////8rAIBIBv////////////////////8oAIBJBgAAKQCASgYAAQAALgAAAYBLKACATAQABAEAAAGATAABKAGASwQAAQEAgEsAAoBMLgCATIBNLgSASYBNAQCATQACgE0uBIBJgE0BAIBNAAKATS4EgEqATSgAgEwBAAApAIBNBgBAAAAuAAABgE4oAIBPBAAEAQAAAYBPAAEoAYBOBAABAQCATgACgE8uAIBPgFAuBIBJgFABAIBQAAKAUC4EgEmAUAEAgFAAAoBQLgSATYBQKwCATwYBAAAAAAAAAAAAAAAAAAAAKwCAUAYA////////////////////KQCAUQYAAf//LgAAAYBSKACAUwQABAEAAAGAUwABKAGAUgQAAQEAgFIAAoBTLgCAU4BULgSAT4BUAQCAVAACgFQuBIBQgFQBAIBUAAKAVC4EgFGAVCwAgFMAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAoAIBUAgBgKwCAVQAAAAABAAAAAAAAAAAAAAAALACAVgAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAACgAgFcEAAMrAIBYBgCAAAAAAAAAAAAAAAAAAAAoAIBZBAAEKACAWgQAASgAgFsEAA4oAIBcBAACKACAXQQADygAgF4EABooAIBfBAAUKACAYAQAECgAgGEEAEQoAIBiBABQKACAYwQAGygAgGQEABUoAIBlBAA4KACAZgQAMigAgGcEABEoAIBoBABBKACAaQQAYCgAgGoEAEUoAIBrBABRKACAbAQAaSgAgG0EAGMoAIBuBAAcKACAbwQAFigAgHAEAFYoAIBxBABaKACAcgQAOSgAgHMEADMoAIB0BABIKACAdQQAKigAgHYEAAUoAIB3BAB+KACAeAQAEigAgHkEAEIoAIB6BAAwKACAewQAXigAgHwEAGEoAIB9BABUKACAfgQARigAgH8EAHwoAICABABSKACAgQQAeigAgIIEAGooAICDBABkKACAhAQAcigAgIUEAGwoAICGBAAdKACAhwQAFygAgIgEAE0oAICJBABmKACAigQAVygAgIsEAFsoAICMBAB3KACAjQQAdCgAgI4EADooAICPBAA0KACAkAQAPSgAgJEEAG4oAICSBABJKACAkwQAJSgAgJQEACsoAICVBAAfKACAlgQABigAgJcEAH8oAICYBAAZKACAmQQAEygAgJoEAEMoAICbBABPKACAnAQANygAgJ0EADEoAICeBABAKACAnwQAXygAgKAEAGgoAIChBABiKACAogQAVSgAgKMEAFkoAICkBABHKACApQQAKSgAgKYEAH0oAICnBAAvKACAqAQAXSgAgKkEAFMoAICqBAB7KACAqwQAeSgAgKwEAHEoAICtBABrKACArgQATCgAgK8EAGUoAICwBAB2KACAsQQAcygAgLIEADwoAICzBABtKACAtAQAJCgAgLUEAB4oAIC2BAAMKACAtwQAGCgAgLgEAE4oAIC5BAA2KACAugQAPygAgLsEAGcoAIC8BABYKACAvQQAKCgAgL4EAC4oAIC/BABcKACAwAQAeCgAgMEEAHAoAIDCBABLKACAwwQAdSgAgMQEADsoAIDFBAAjKACAxgQACygAgMcEADUoAIDIBAA+KACAyQQAJygAgMoEAC0oAIDLBABvKACAzAQASigAgM0EACIoAIDOBAAKKACAzwQAJigAgNAEACEoAIDRBAAJKACA0gQAICgAgNMEAAgoAIDUBAAHKACA1QQAgC4AAAGA1igAgNcEAIEBAAABgNcAASgBgNYEAAEBAIDWAAKA1y4AgNeA2C4EgFqA2AEAgNgAAoDYLgSAW4DYAQCA2AACgNguBIBcgNgBAIDYAAKA2C4EgF2A2AEAgNgAAoDYLgSAXoDYAQCA2AACgNguBIBfgNgBAIDYAAKA2C4EgFeA2AEAgNgAAoDYLgSAYIDYAQCA2AACgNguBIBhgNgBAIDYAAKA2C4EgGKA2AEAgNgAAoDYLgSAY4DYAQCA2AACgNguBIBkgNgBAIDYAAKA2C4EgGWA2AEAgNgAAoDYLgSAZoDYAQCA2AACgNguBIBZgNgBAIDYAAKA2C4EgGeA2AEAgNgAAoDYLgSAaIDYAQCA2AACgNguBIBpgNgBAIDYAAKA2C4EgGqA2AEAgNgAAoDYLgSAa4DYAQCA2AACgNguBIBsgNgBAIDYAAKA2C4EgG2A2AEAgNgAAoDYLgSAboDYAQCA2AACgNguBIBvgNgBAIDYAAKA2C4EgHCA2AEAgNgAAoDYLgSAcYDYAQCA2AACgNguBIBygNgBAIDYAAKA2C4EgHOA2AEAgNgAAoDYLgSAdIDYAQCA2AACgNguBIB1gNgBAIDYAAKA2C4EgHaA2AEAgNgAAoDYLgSAd4DYAQCA2AACgNguBIB4gNgBAIDYAAKA2C4EgHmA2AEAgNgAAoDYLgSAeoDYAQCA2AACgNguBIB7gNgBAIDYAAKA2C4EgHyA2AEAgNgAAoDYLgSAfYDYAQCA2AACgNguBIB+gNgBAIDYAAKA2C4EgH+A2AEAgNgAAoDYLgSAgIDYAQCA2AACgNguBICBgNgBAIDYAAKA2C4EgIKA2AEAgNgAAoDYLgSAg4DYAQCA2AACgNguBICEgNgBAIDYAAKA2C4EgIWA2AEAgNgAAoDYLgSAhoDYAQCA2AACgNguBICHgNgBAIDYAAKA2C4EgIiA2AEAgNgAAoDYLgSAiYDYAQCA2AACgNguBICKgNgBAIDYAAKA2C4EgIuA2AEAgNgAAoDYLgSAjIDYAQCA2AACgNguBICNgNgBAIDYAAKA2C4EgI6A2AEAgNgAAoDYLgSAj4DYAQCA2AACgNguBICQgNgBAIDYAAKA2C4EgJGA2AEAgNgAAoDYLgSAkoDYAQCA2AACgNguBICTgNgBAIDYAAKA2C4EgJSA2AEAgNgAAoDYLgSAlYDYAQCA2AACgNguBICWgNgBAIDYAAKA2C4EgJeA2AEAgNgAAoDYLgSARoDYAQCA2AACgNguBICYgNgBAIDYAAKA2C4EgJmA2AEAgNgAAoDYLgSAmoDYAQCA2AACgNguBICbgNgBAIDYAAKA2C4EgJyA2AEAgNgAAoDYLgSAnYDYAQCA2AACgNguBICegNgBAIDYAAKA2C4EgJ+A2AEAgNgAAoDYLgSAoIDYAQCA2AACgNguBIChgNgBAIDYAAKA2C4EgKKA2AEAgNgAAoDYLgSAo4DYAQCA2AACgNguBICkgNgBAIDYAAKA2C4EgKWA2AEAgNgAAoDYLgSApoDYAQCA2AACgNguBICngNgBAIDYAAKA2C4EgKiA2AEAgNgAAoDYLgSAqYDYAQCA2AACgNguBICqgNgBAIDYAAKA2C4EgKuA2AEAgNgAAoDYLgSArIDYAQCA2AACgNguBICtgNgB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LykjAAAjOi4IgEUAKSMAACM6KQIALQR/////DCotCionAi4EAAIqLgovJAIAKgAAI18jAAAjaC0KLysjAAAjcS0KCisjAAAjcQYqKSslFConKiwkAgAsAAAjiCMAACOSJwItBAACKi0lJQQqJQonHAonKQUcCikqBBwKKicFHAolKQQNIgApgOUAKgoqKiMpFgoqIxwKJSsAHAoqJQAEKiUrKgIqKCslHAojKAAEKiglIwAqKiMlBColJiMcCiMlACkCACYA/////w4qJSYoJAIAKAAAJAQlAADO1BwKIyUEFgopIxwKIyYEASiA5QAmACMMKiUjJiQCACYAACQsJQAAzuYcCicjBAIqIyIlLQolIhwKIiMEHAonJQQcCiQmBA0iACWA5QAkDSIAJoDlACUWCiUmCiokJiUNIgAjgOUAJgoqJiQjBCojJSQKKiQlIyQCACMAACSGJQAAzvgpAgApBH////8MKikiJCcCKgQAAioqIiskAgAkAAAkqyMAACS0LQorJSMAACS9LQoiJSMAACS9KQIAKQR/////DCopCiYnAioEAAIqKgorJAIAJgAAJOIjAAAk6y0KKycjAAAk9C0KCicjAAAk9AYqJScjFCokJigkAgAoAAAlCyMAACUVJwIpBAACKikjIycCCgQBACojCiItCiIKHAoKIgQcCiMkBA0iACSA5QAjDSIAIoDlACQKKiQjIgQqIiMkCiokIyIkAgAiAAAlWSUAAM7mHAoKIgAcCiIjBhwKIwoAHAoKIgYHKIBIACIACi0LBCIAIiICIi0OIgQnAiMEJC0IACQtCgQlLgiAXAAmLgiATAAnAAgAIwAlAADGzi0CAAAtCiUiCyIAIoDZAAQLIgAEgEwAIyQCACMAACXKJQAAyDgtCAEEJwIjBAMACAEjAScDBAQBACIEAiMtCiMkLQ4iJAAiJAIkLQ4IJCcCIwQkLQgAJC0KBCUuCIBcACYuCIBMACcACAAjACUAAMbOLQIAAC0KJSILIgAigNkABAsiAASATAAjJAIAIwAAJjslAADIOC0IAQQnAiMEAwAIASMBJwMEBAEAIgQCIy0KIyQtDiIkACIkAiQtDgskJwIjBCQtCAAkLQoEJS4IgFwAJi4IgEwAJwAIACMAJQAAxs4tAgAALQolIgsiACKA2QAECyIABIBMACMkAgAjAAAmrCUAAMg4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CYBLAAEAIgECAS4GAAGASy4JgFIAAQAiAQIBLgYAAYBSLgmATgABACIBAgEuBgABgE4tCwMBACIBAgEtDgEDLQsGAQAiAQIBLQ4BBi4JgEsAAQAiAQIBLgYAAYBLJwIHBAwtCAAMLgiASwANLQoGDgAIAAcAJQABDiEtAgAALQoNAScCBwQMLQgADC4IgEsADS0KAw4tCgEPAAgABwAlAAEPcC0CAAAtCg0GLgmASwABACIBAgEuBgABgEsuCYBSAAEAIgECAS4GAAGAUi4JgE4AAQAiAQIBLgYAAYBOLgmASwABACIBAgEuBgABgEsuCYBSAAEAIgECAS4GAAGAUi4JgE4AAQAiAQIBLgYAAYBOLQsKAQAiAQIBLQ4BCi0LBgEAIgECAS0OAQYnAgwEDS0IAA0uCIBMAA4uCIBLAA8uCIBSABAuCIBOABEtCgoSLQoGEwAIAAwAJQABETEtAgAALQoOAS0KDwctCwEGACIGAgYtDgYBLQsHAQAiAQIBLQ4BBy4JgEsAAQAiAQIBLgYAAYBLLgmAUgABACIBAgEuBgABgFIuCYBOAAEAIgECAS4GAAGATi0LAwEAIgECAS0OAQMtCwgBACIBAgEtDgEILQsHAQAiAQIBLQ4BBy4JgEsAAQAiAQIBLgYAAYBLLgmAUgABACIBAgEuBgABgFIuCYBOAAEAIgECAS4GAAGATi4JgEsAAQAiAQIBLgYAAYBLLgmAUgABACIBAgEuBgABgFIuCYBOAAEAIgECAS4GAAGATi0LCAEAIgECAS0OAQgtCwcBACIBAgEtDgEHJwIKBAwtCAAMLgiATAANLgiASwAOLgiAUgAPLgiATgAQLQoIES0KBxIACAAKACUAARExLQIAAC0KDQEtCg4GLQsBCgAiCgIKLQ4KAS4JgEsAAQAiAQIBLgYAAYBLLgmAUgABACIBAgEuBgABgFIuCYBOAAEAIgECAS4GAAGATi0LAwEAIgECAS0OAQMtCwYBACIBAgEtDgEGLgmASwABACIBAgEuBgABgEsnAgoEDC0IAAwuCIBLAA0tCgYOAAgACgAlAAEOIS0CAAAtCg0BJwIKBAwtCAAMLgiASwANLQoDDi0KAQ8ACAAKACUAAQ9wLQIAAC0KDQYuCYBLAAEAIgECAS4GAAGASy4JgFIAAQAiAQIBLgYAAYBSLgmATgABACIBAgEuBgABgE4uCYBLAAEAIgECAS4GAAGASy4JgFIAAQAiAQIBLgYAAYBSLgmATgABACIBAgEuBgABgE4tCwcBACIBAgEtDgEHLQsGAQAiAQIBLQ4BBicCDAQNLQgADS4IgEwADi4IgEsADy4IgFIAEC4IgE4AES0KBxItCgYTAAgADAAlAAERMS0CAAAtCg4BLQoPCi0LAQYAIgYCBi0OBgEtCwoBACIBAgEtDgEKLgmASwABACIBAgEuBgABgEsuCYBSAAEAIgECAS4GAAGAUi4JgE4AAQAiAQIBLgYAAYBOLQsDAQAiAQIBLQ4BAy0LCgEAIgECAS0OAQouCYBLAAEAIgECAS4GAAGASy4JgFIAAQAiAQIBLgYAAYBSLgmATgABACIBAgEuBgABgE4uCYBLAAEAIgECAS4GAAGASy4JgFIAAQAiAQIBLgYAAYBSLgmATgABACIBAgEuBgABgE4tCwgBACIBAgEtDgEILQsKAQAiAQIBLQ4BCicCBwQMLQgADC4IgEwADS4IgEsADi4IgFIADy4IgE4AEC0KCBEtCgoSAAgABwAlAAERMS0CAAAtCg0BLQoOBi0LAQcAIgcCBy0OBwEuCYBLAAEAIgECAS4GAAGASy4JgFIAAQAiAQIBLgYAAYBSLgmATgABACIBAgEuBgABgE4tCwMBACIBAgEtDgEDLQsGAQAiAQIBLQ4BBi4JgEsAAQAiAQIBLgYAAYBLJwIHBAwtCAAMLgiASwANLQoGDgAIAAcAJQABDiEtAgAALQoNAScCBwQMLQgADC4IgEsADS0KAw4tCgEPAAgABwAlAAEPcC0CAAAtCg0GLgmASwABACIBAgEuBgABgEsuCYBSAAEAIgECAS4GAAGAUi4JgE4AAQAiAQIBLgYAAYBOLgmASwABACIBAgEuBgABgEsuCYBSAAEAIgECAS4GAAGAUi4JgE4AAQAiAQIBLgYAAYBOLQsKAQAiAQIBLQ4BCi0LBgEAIgECAS0OAQYnAgcEDC0IAAwuCIBMAA0uCIBLAA4uCIBSAA8uCIBOABAtCgoRLQoGEgAIAAcAJQABETEtAgAALQoNAS0KDgMtCwEGACIGAgYtDgYBLgmASwABACIBAgEuBgABgEsuCYBSAAEAIgECAS4GAAGAUi4JgE4AAQAiAQIBLgYAAYBOJwIGBAwtCAAMLgiATAANLgiASwAO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ACIEAgstCgsMLgyATAAMACIMAgwuDIBMAAwAIgwCDC4MgEwADC0IAQsAAAECAS0OBAstCAEEJwIMBAQACAEMAScDBAQBACIEAgwtCgwNLgyATAANACINAg0uDIBMAA0AIg0CDS4MgEwADS0IAQwAAAECAS0OBAwuCIDYAAMjAAErVg0iAAOAVwAEJAIABAABK4gjAAEray0LBwEtCwwCLQsLAy0KAwQtCgIDLQoBAi0KBQEmACIGAggAKggDCi0LCgQtCwEIACoECAoOKgQKDSQCAA0AASuxJQAAzuYNIgAKgE8ABBYKBAgcCggEBgUiAASATwAIAioKCA0OKggKDiQCAA4AASvhJQAAzvgtDgQBACIJAgoAKgoDDi0LDggtCwIKACoICg4OKggODyQCAA8AASwOJQAAzuYMKg0OCBwKCAoGBSIACoBPAAgAKggNDw4qCA8QJAIAEAABLDclAADO5gIqDw4IDioODw0kAgANAAEsTiUAAM74LQsHDS4CAA2AAygAgAQEAAQlAADI+C4IgAUADgAiDgIPACoPAxAtDggQLQ4OBy0OCgIKKgQKCCQCAAgAAS0LIwABLJILIgAEgEkACBYKCAQtCwwILgIACIADKACABAQABCUAAMj4LgiABQANACINAg4AKg4DDy0OBA8tDg0MCyIACoBJAAQWCgQILQsLBC4CAASAAygAgAQEAAQlAADI+C4IgAUACgAiCgINACoNAw4tDggOLQ4KCyMAAS0LASIAA4BaAAQtCgQDIwABK1YlAADFAwEiAAGAWgADLQsDAhwKAgMAHAoDAgArAgAEAAD///////////////////8OKgIEBSQCAAUAAS1eJQABQNYBIgABgFwAAy0LAwIcCgIDABwKAwIAKwIABAAA////////////////////DioCBAUkAgAFAAEtmyUAAUDWASIAAYBXAAMtCwMCHAoCAQAcCgECACkCAAMAAAH//w4qAgMEJAIABAABLcwlAAFA1iYqAQABBbgYt77rF33TPAQCASYlAADFAwEiAAGAWgAHLQsHBhwKBgcAASIAAoBaAAgtCwgGHAoGCAACKgcIBgEiAAOAWgAILQsIBxwKBwgAAioGCAcBIgAEgFoACC0LCAYcCgYIAAEiAAWAWgAJLQsJBhwKBgkAAioICQYFIgAGgOcACAAqBwgJCyIA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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "set_admin",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "newAdmin",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBFJwAABAMnAgIEAScCAwQAHwoAAgADgEQuCIBEAAElAAAARSUAAABGKAIAAQSARScCAgQAOw4AAgABJiUAAAChHgIAAgAeAgADADMqAAIAAwAEJwICAQEkAgAEAAAAbyUAAADKJwICAAEvCgACAAMKKgEDBCcCAwEACioEAwUkAgAFAAAAmicCBgQAPAYGATAKAAEAAiYoAIAEBHgADQAAAIAEgAMkAIADAAAAySoBAAEF96Hzr6Wt1Mo8BAIBJioBAAEFvh4//z6k9vo8BAIBJg==",
      "debug_symbols": "tZXRbqswDIbfJddcxEnsOH2VqapoSyckRCsGRzqqePc5G4FykUjTtBtsQ/P1t2MnT3VtztP7qe1v9w91eHuq89B2Xft+6u6Xemzvvbx9Kh0fHtXBVYol8GIkAl2pYMWCWP62oGlxAMSh6NDiGCMOR8eLIxCwJjnpjcPFQZ0cpw7GznOlkqbTODRNlPQiUqQ/6qHpR3Xop66r1L+6m75+9PGo+y871oN8Fc1NfxUrwFvbNdGbq221zi8Fi+SW5WAphBUh0Q4CBYg2JjG0My8Iu0OYPMJx8AvCBU0rQgS9EmyewM6mOrBzWUIxjRBSGgAhmwb+Og362zSQ193g/G5wAYEeE4Is5ESEPCGgTiICIvwyDRmzbBqF5iakVEtCzysC3V5EoS9BpndV4bcBM4B7RqEzPUMaD8+iPlcLV0BQPH++EYQ6i8ByJlt7u2BykGJBHa8FZZ0tqC81BqW+CFtbWPjBpoZUCiLIayg0JzidEOCMz26qKchgs56bbDg7p6bQ4awpHRYMwFlEsT2RtikhHXaQo0T1pR12N98caUNbn7tmCW9Tf3n5Ov5/pC/p5nwM90tznYYmkrbrE+T5JseVxWO8E2NAleXjHP/6Ew==",
      "brillig_names": [
        "set_admin"
      ]
    },
    {
      "name": "set_rate",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "rate",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "tokenA",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tokenB",
            "type": {
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        },
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8786903978971566366": {
            "error_kind": "string",
            "string": "only admin"
          },
          "13265554733035650515": {
            "error_kind": "string",
            "string": "BigNum::validate_gt check fails"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIDdJwAABAMnAgUEBCcCBgQAHwoABQAGgNgdAIDbgNsELgiA2AABLgiA2QACLgiA2gADLgiA2wAEJQAAAGQlAAAMwC4CAAGA3CgCAAIEgNwnAgMEATsOAAMAAigAgEMEACwpAIBEBP////8oAIBFBgAAKQCARgYAAQAALgAAAYBHKACASAQABAEAAAGASAABKAGARwQAAQEAgEcAAoBILgCASIBJLgSARYBJAQCASQACgEkuBIBFgEkBAIBJAAKASS4EgEaASSgAgEgBAAApAIBJBgBAAAAuAAABgEooAIBLBAAEAQAAAYBLAAEoAYBKBAABAQCASgACgEsuAIBLgEwuBIBFgEwBAIBMAAKATC4EgEWATAEAgEwAAoBMLgSASYBMKwCASwYBAAAAAAAAAAAAAAAAAAAAKwCATAYA////////////////////KQCATQYAAf//LgAAAYBOKACATwQABAEAAAGATwABKAGATgQAAQEAgE4AAoBPLgCAT4BQLgSAS4BQAQCAUAACgFAuBIBMgFABAIBQAAKAUC4EgE2AUCgAgE8EAAMrAIBQBgCAAAAAAAAAAAAAAAAAAAAoAIBRBAAEKACAUgQAASgAgFMEAA4oAIBUBAACKACAVQQADygAgFYEABooAIBXBAAUKACAWAQAECgAgFkEAEQoAIBaBABQKACAWwQAGygAgFwEABUoAIBdBAA4KACAXgQAMigAgF8EABEoAIBgBABBKACAYQQAYCgAgGIEAEUoAIBjBABRKACAZAQAaSgAgGUEAGMoAIBmBAAcKACAZwQAFigAgGgEAFYoAIBpBABaKACAagQAOSgAgGsEADMoAIBsBABIKACAbQQAKigAgG4EAAUoAIBvBAB+KACAcAQAEigAgHEEAEIoAIByBAAwKACAcwQAXigAgHQEAGEoAIB1BABUKACAdgQARigAgHcEAHwoAIB4BABSKACAeQQAeigAgHoEAGooAIB7BABkKACAfAQAcigAgH0EAGwoAIB+BAAdKACAfwQAFygAgIAEAE0oAICBBABmKACAggQAVygAgIMEAFsoAICEBAB3KACAhQQAdCgAgIYEADooAICHBAA0KACAiAQAPSgAgIkEAG4oAICKBABJKACAiwQAJSgAgIwEACsoAICNBAAfKACAjgQABigAgI8EAH8oAICQBAANKACAkQQAGSgAgJIEABMoAICTBABDKACAlAQATygAgJUEADcoAICWBAAxKACAlwQAQCgAgJgEAF8oAICZBABoKACAmgQAYigAgJsEAFUoAICcBABZKACAnQQARygAgJ4EACkoAICfBAB9KACAoAQALygAgKEEAF0oAICiBABTKACAowQAeygAgKQEAHkoAIClBABxKACApgQAaygAgKcEAEwoAICoBABlKACAqQQAdigAgKoEAHMoAICrBAA8KACArAQAbSgAgK0EACQoAICuBAAeKACArwQADCgAgLAEABgoAICxBABOKACAsgQANigAgLMEAD8oAIC0BABnKACAtQQAWCgAgLYEACgoAIC3BAAuKACAuAQAXCgAgLkEAHgoAIC6BABwKACAuwQASygAgLwEAHUoAIC9BAA7KACAvgQAIygAgL8EAAsoAIDABAA1KACAwQQAPigAgMIEACcoAIDDBAAtKACAxAQAbygAgMUEAEooAIDGBAAiKACAxwQACigAgMgEACYoAIDJBAAhKACAygQACSgAgMsEACAoAIDMBAAIKACAzQQABygAgM4EAIAuAAABgM8oAIDQBACBAQAAAYDQAAEoAYDPBAABAQCAzwACgNAuAIDQgNEuBIBSgNEBAIDRAAKA0S4EgFOA0QEAgNEAAoDRLgSAVIDRAQCA0QACgNEuBIBVgNEBAIDRAAKA0S4EgFaA0QEAgNEAAoDRLgSAV4DRAQCA0QACgNEuBIBPgNEBAIDRAAKA0S4EgFiA0QEAgNEAAoDRLgSAWYDRAQCA0QACgNEuBIBagNEBAIDRAAKA0S4EgFuA0QEAgNEAAoDRLgSAXIDRAQCA0QACgNEuBIBdgNEBAIDRAAKA0S4EgF6A0QEAgNEAAoDRLgSAUYDRAQCA0QACgNEuBIBfgNEBAIDRAAKA0S4EgGCA0QEAgNEAAoDRLgSAYYDRAQCA0QACgNEuBIBigNEBAIDRAAKA0S4EgGOA0QEAgNEAAoDRLgSAZIDRAQCA0QACgNEuBIBlgNEBAIDRAAKA0S4EgGaA0QEAgNEAAoDRLgSAZ4DRAQCA0QACgNEuBIBogNEBAIDRAAKA0S4EgGmA0QEAgNEAAoDRLgSAaoDRAQCA0QACgNEuBIBrgNEBAIDRAAKA0S4EgGyA0QEAgNEAAoDRLgSAbYDRAQCA0QACgNEuBIBugNEBAIDRAAKA0S4EgG+A0QEAgNEAAoDRLgSAcIDRAQCA0QACgNEuBIBxgNEBAIDRAAKA0S4EgHKA0QEAgNEAAoDRLgSAc4DRAQCA0QACgNEuBIB0gNEBAIDRAAKA0S4EgHWA0QEAgNEAAoDRLgSAdoDRAQCA0QACgNEuBIB3gNEBAIDRAAKA0S4EgHiA0QEAgNEAAoDRLgSAeYDRAQCA0QACgNEuBIB6gNEBAIDRAAKA0S4EgHuA0QEAgNEAAoDRLgSAfIDRAQCA0QACgNEuBIB9gNEBAIDRAAKA0S4EgH6A0QEAgNEAAoDRLgSAf4DRAQCA0QACgNEuBICAgNEBAIDRAAKA0S4EgIGA0QEAgNEAAoDRLgSAgoDRAQCA0QACgNEuBICDgNEBAIDRAAKA0S4EgISA0QEAgNEAAoDRLgSAhYDRAQCA0QACgNEuBICGgNEBAIDRAAKA0S4EgIeA0QEAgNEAAoDRLgSAiIDRAQCA0QACgNEuBICJgNEBAIDRAAKA0S4EgIqA0QEAgNEAAoDRLgSAi4DRAQCA0QACgNEuBICMgNEBAIDRAAKA0S4EgI2A0QEAgNEAAoDRLgSAjoDRAQCA0QACgNEuBICPgNEBAIDRAAKA0S4EgJCA0QEAgNEAAoDRLgSAkYDRAQCA0QACgNEuBICSgNEBAIDRAAKA0S4EgJOA0QEAgNEAAoDRLgSAlIDRAQCA0QACgNEuBICVgNEBAIDRAAKA0S4EgJaA0QEAgNEAAoDRLgSAl4DRAQCA0QACgNEuBICYgNEBAIDRAAKA0S4EgJmA0QEAgNEAAoDRLgSAmoDRAQCA0QACgNEuBICbgNEBAIDRAAKA0S4EgJyA0QEAgNEAAoDRLgSAnYDRAQCA0QACgNEuBICegNEBAIDRAAKA0S4EgJ+A0QEAgNEAAoDRLgSAoIDRAQCA0QACgNEuBIChgNEBAIDRAAKA0S4EgKKA0QEAgNEAAoDRLgSAo4DRAQCA0QACgNEuBICkgNEBAIDRAAKA0S4EgKWA0QEAgNEAAoDRLgSApoDRAQCA0QACgNEuBICngNEBAIDRAAKA0S4EgKiA0QEAgNEAAoDRLgSAqYDRAQCA0QACgNEuBICqgNEBAIDRAAKA0S4EgKuA0QEAgNEAAoDRLgSArIDRAQCA0QACgNEuBICtgNEBAIDRAAKA0S4EgK6A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BgQtCAEGAAABAgEtDgQGAyIAAoBSAAQPKIBSAAIAByQCAAcAAD90JQAAMnguCIDRAAMjAAA/fwwqAwQCJAIAAgAAQBkjAAA/kS0LBgEnAgYEBy0IAActCgEIAAgABgAlAABA3y0CAAAtCggCLQoJAy0LBQENIgAEgI4ABiQCAAYAAD/RJQAAQUUuAgABgAMoAIAEBAAHJQAAOEcuCIAFAAYAIgYCBwAqBwQILQ4CCC0OBgULIgADgEUAASQCAAEAAEAUJwICBAA8BgIBLQoGASYtCwYCJwIJBAotCAAKLQoCCwAIAAkAJQAAQN8tAgAALQoLBy0KDAgtCwUCDSIAA4COAAkkAgAJAABAWSUAAEFFLgIAAoADKACABAQAByUAADhHLgiABQAJACIJAgoAKgoDCy0OBwstDgkFASIAA4BSAAIOKgMCByQCAAcAAECdJQAAODUNIgACgI4AByQCAAcAAECyJQAAQUUAIgECCQAqCQIKLQsKBxwKCAIAACoHAggtDggGASIAA4BSAAItCgIDIwAAP38lAAAdjRwKAQMGHAoDAgAcCgIDBisCAAQGAQAAAAAAAAAAAAAAAAAAAAYqAwQFBCoFBAYCKgMGAhwKAgMAAioBAwQFIgAEgNcAARwKAQQGHAoEAwAcCgMBBi0KAQMtCgIBLQoDAiYqAQABBcVrxFoOEAACPAQCASYqAQABBWRhiKjGz5TLPAQCASYqAQABBVoC5Bu1HqmfPAQCASYqAQABBclvkzsTnekWPAQCASYlAAAdjQEiAAGAUgADLQsDAhwKAgMAHAoDAgArAgAEAAD///////////////////8OKgIEBSQCAAUAAEHPJQAAQWkBIgABgFQAAy0LAwIcCgIDABwKAwIAKwIABAAA////////////////////DioCBAUkAgAFAABCDCUAAEFpASIAAYBPAAMtCwMCHAoCAQAcCgECACkCAAMAAAH//w4qAgMEJAIABAAAQj0lAABBaSYqAQABBbgYt77rF33TPAQCASY=",
      "debug_symbols": "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",
      "brillig_names": [
        "set_rate"
      ]
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_private_state"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "AddressNote"
            },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000002"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "FactoryV3"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "pools",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "feeAmountTickSpacing",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "ticks",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "approved_lps",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "protocolFees",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "positions",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "tickBitmap",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "observations",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000009"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "observationByIndex",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "tokenA",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "tokenB",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "fee",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FactoryV3::_createPool_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FactoryV3::_createPool_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "tokenA",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "tokenB",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "tickLower",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "tickUpper",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "isTickLowerNeg",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "isTickUpperNeg",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "lte",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "getSqrtRatioAtTickUpper",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "getSqrtRatioAtTickLower",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FactoryV3::_mint_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "array",
                "length": 2,
                "type": {
                  "kind": "field"
                }
              }
            }
          ],
          "kind": "struct",
          "path": "FactoryV3::_mint_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "fee",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FactoryV3::checkFeeAmount_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "FactoryV3::checkFeeAmount_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "tokenA",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "tokenB",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount0Requested",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount1Requested",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FactoryV3::collectProtocol_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "array",
                "length": 2,
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              }
            }
          ],
          "kind": "struct",
          "path": "FactoryV3::collectProtocol_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "lpToken",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "lp_contract_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FactoryV3::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FactoryV3::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "tokenA",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "tokenB",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "fee",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FactoryV3::createPool_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FactoryV3::createPool_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "tickSpacing",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FactoryV3::enableFeeAmount_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FactoryV3::enableFeeAmount_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "tickLower",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "tickUpper",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "isTickLowerNeg",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "isTickUpperNeg",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FactoryV3::getKey_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "FactoryV3::getKey_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "tokenA",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "tokenB",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "FactoryV3::getPool_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "token0",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token1",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  },
                  {
                    "name": "tickSpacing",
                    "type": {
                      "kind": "integer",
                      "sign": "signed",
                      "width": 32
                    }
                  },
                  {
                    "name": "maxLiquidityPerTick",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "feeGrowthGlobal0X128",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "feeGrowthGlobal1X128",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "slot0",
                    "type": {
                      "fields": [
                        {
                          "name": "sqrtPriceX96",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "tick",
                          "type": {
                            "kind": "integer",
                            "sign": "signed",
                            "width": 32
                          }
                        },
                        {
                          "name": "observationIndex",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 16
                          }
                        },
                        {
                          "name": "observationCardinality",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 16
                          }
                        },
                        {
                          "name": "observationCardinalityNext",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 16
                          }
                        },
                        {
                          "name": "feeProtocol",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 8
                          }
                        },
                        {
                          "name": "unlocked",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "pairV3::Slot0"
                    }
                  },
                  {
                    "name": "liquidity",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "protocolFees",
                    "type": {
                      "fields": [
                        {
                          "name": "token0",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "token1",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "pairV3::ProtocolFees"
                    }
                  },
                  {
                    "name": "initiated",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "rate",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "rate_mul",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "rate_time",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "pairV3::Pair"
              }
            }
          ],
          "kind": "struct",
          "path": "FactoryV3::getPool_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "fee",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FactoryV3::getTickSpacing_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "FactoryV3::getTickSpacing_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "FactoryV3::get_admin_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "FactoryV3::get_admin_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "tokenA",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "tokenB",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "fee",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "sqrtPriceX96",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "tick",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "isNegTick",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FactoryV3::initialize_pool_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FactoryV3::initialize_pool_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FactoryV3::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FactoryV3::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "newAdmin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FactoryV3::set_admin_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FactoryV3::set_admin_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "rate",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "tokenA",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "tokenB",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "FactoryV3::set_rate_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "FactoryV3::set_rate_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "FactoryV3::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FactoryV3::sync_private_state_abi"
        }
      ]
    }
  },
  "file_map": {
    "101": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "104": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    // TODO(#2707): Consider making this a u64 as we already cast this to that when encoding the message. This would decrease\n    // the likelihood of collisions without any extra cost.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "106": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "123": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "128": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        authwits::AUTHWIT_TYPES,\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n    let process_message = generate_process_message();\n    generate_authwit_exports();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_authwit_exports() {\n    let authwits = AUTHWIT_TYPES.values();\n    authwits.for_each(|(s): TypeDefinition| { s.add_attribute(\"abi(authwits)\"); });\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "129": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "132": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_array, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n    size_in_fields,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    } else {\n        if is_void {\n            create_utility_void_stub(f)\n        } else {\n            create_utility_stub(f)\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n    let params_num_fields =\n        fn_parameters.fold(0, |acc, (_, typ)| acc + crate::macros::utils::size_in_fields(typ));\n\n    let serialized_args_index_name = quote { serialized_args_index };\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args = [0;2];\n    // let mut serialized_args_index = 0;\n    // let target_address_serialized = aztec::protocol_types::traits::Serialize::serialize(target_address)\n    // for i in 0..target_address_serialized.len() {\n    //    serialized_args[serialized_args_index] = target_address_serialized[i];\n    //    serialized_args_index += 1;\n    // }\n    // serialized_args[serialized_args_index] = fee_juice_limit_per_tx as Field\n    // serialized_args_index += 1;\n    // ```\n    let serialized_args_array_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_NAME = [0; $params_num_fields];\n            let mut $serialized_args_index_name: u32 = 0;\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append =\n                add_to_field_array(SERIALIZED_ARGS_NAME, serialized_args_index_name, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n"
    },
    "133": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "136": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "138": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ, _) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "139": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "141": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "142": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "143": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "144": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    prelude::AztecAddress,\n    utils::array,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__EVENT_COMMITMENT, hash::poseidon2_hash_with_separator_bounded_vec,\n    traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private_log` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "145": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "146": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "147": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "148": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "164": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "177": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "180": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "185": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "186": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "187": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "188": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "189": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "194": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "195": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "197": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(validateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(bulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "202": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "206": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "215": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "229": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "232": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "233": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "235": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "236": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "238": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "240": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "252": {
      "path": "/home/g/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "270": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "313": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "330": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "331": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "345": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] != 0 };\n        consumed_counter = 1;\n    } else if typ.is_field() | typ.as_integer().is_some() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type, _) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type, _)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    let serialize_trait: TraitConstraint =\n        quote { Serialize<$serialized_len> }.as_trait_constraint();\n    quote {\n        impl $serialize_trait for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "347": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "348": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "358": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] != 0,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] != 0,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] != 0,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] != 0,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "369": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "383": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    #[inline_always]\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// T = type of item in BoundedVec\n// M = max length of BoundedVec\n// O = field length of T\n// O * M + 1 = total serialized length of BoundedVec<T, M> (the +1 is for length of the BoundedVec)\nimpl<T, let M: u32, let O: u32> Deserialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Deserialize<O>,\n{\n    #[inline_always]\n    fn deserialize(fields: [Field; O * M + 1]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[O * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; O];\n            for j in 0..O {\n                nested_fields[j] = fields[i * O + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl<let N: u32> Deserialize<0> for () {\n    fn deserialize(_fields: [Field; 0]) -> Self {\n        ()\n    }\n}\n\nimpl<T, let M: u32, let O: u32> Serialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Serialize<O>,\n{\n    #[inline_always]\n    fn serialize(self) -> [Field; O * M + 1] {\n        let mut fields = [0; O * M + 1];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..O {\n                fields[i * O + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[O * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    #[inline_always]\n    fn deserialize(fields: [Field; N]) -> Self {\n        str::<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "388": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as u8 as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as u16 as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as u32 as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as u64 as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "389": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T, let N: u32> Serialize<N + 1> for Option<T>\nwhere\n    T: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T, let N: u32> Deserialize<N + 1> for Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    fn deserialize(fields: [Field; N + 1]) -> Self {\n        if fields[0] == 1 {\n            let mut value_serialized: [Field; N] = std::mem::zeroed();\n            for i in 0..N {\n                value_serialized[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_serialized))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "39": {
      "path": "std/ops/arith.nr",
      "source": "use crate::convert::AsPrimitive;\n\n// docs:start:add-trait\npub trait Add {\n    fn add(self, other: Self) -> Self;\n}\n// docs:end:add-trait\n\nimpl Add for Field {\n    fn add(self, other: Field) -> Field {\n        self + other\n    }\n}\n\nimpl Add for u128 {\n    fn add(self, other: u128) -> u128 {\n        self + other\n    }\n}\nimpl Add for u64 {\n    fn add(self, other: u64) -> u64 {\n        self + other\n    }\n}\nimpl Add for u32 {\n    fn add(self, other: u32) -> u32 {\n        self + other\n    }\n}\nimpl Add for u16 {\n    fn add(self, other: u16) -> u16 {\n        self + other\n    }\n}\nimpl Add for u8 {\n    fn add(self, other: u8) -> u8 {\n        self + other\n    }\n}\nimpl Add for u1 {\n    fn add(self, other: u1) -> u1 {\n        self + other\n    }\n}\n\nimpl Add for i8 {\n    fn add(self, other: i8) -> i8 {\n        self + other\n    }\n}\nimpl Add for i16 {\n    fn add(self, other: i16) -> i16 {\n        self + other\n    }\n}\nimpl Add for i32 {\n    fn add(self, other: i32) -> i32 {\n        self + other\n    }\n}\nimpl Add for i64 {\n    fn add(self, other: i64) -> i64 {\n        self + other\n    }\n}\n\n// docs:start:sub-trait\npub trait Sub {\n    fn sub(self, other: Self) -> Self;\n}\n// docs:end:sub-trait\n\nimpl Sub for Field {\n    fn sub(self, other: Field) -> Field {\n        self - other\n    }\n}\n\nimpl Sub for u128 {\n    fn sub(self, other: u128) -> u128 {\n        self - other\n    }\n}\nimpl Sub for u64 {\n    fn sub(self, other: u64) -> u64 {\n        self - other\n    }\n}\nimpl Sub for u32 {\n    fn sub(self, other: u32) -> u32 {\n        self - other\n    }\n}\nimpl Sub for u16 {\n    fn sub(self, other: u16) -> u16 {\n        self - other\n    }\n}\nimpl Sub for u8 {\n    fn sub(self, other: u8) -> u8 {\n        self - other\n    }\n}\nimpl Sub for u1 {\n    fn sub(self, other: u1) -> u1 {\n        self - other\n    }\n}\n\nimpl Sub for i8 {\n    fn sub(self, other: i8) -> i8 {\n        self - other\n    }\n}\nimpl Sub for i16 {\n    fn sub(self, other: i16) -> i16 {\n        self - other\n    }\n}\nimpl Sub for i32 {\n    fn sub(self, other: i32) -> i32 {\n        self - other\n    }\n}\nimpl Sub for i64 {\n    fn sub(self, other: i64) -> i64 {\n        self - other\n    }\n}\n\n// docs:start:mul-trait\npub trait Mul {\n    fn mul(self, other: Self) -> Self;\n}\n// docs:end:mul-trait\n\nimpl Mul for Field {\n    fn mul(self, other: Field) -> Field {\n        self * other\n    }\n}\n\nimpl Mul for u128 {\n    fn mul(self, other: u128) -> u128 {\n        self * other\n    }\n}\nimpl Mul for u64 {\n    fn mul(self, other: u64) -> u64 {\n        self * other\n    }\n}\nimpl Mul for u32 {\n    fn mul(self, other: u32) -> u32 {\n        self * other\n    }\n}\nimpl Mul for u16 {\n    fn mul(self, other: u16) -> u16 {\n        self * other\n    }\n}\nimpl Mul for u8 {\n    fn mul(self, other: u8) -> u8 {\n        self * other\n    }\n}\nimpl Mul for u1 {\n    fn mul(self, other: u1) -> u1 {\n        self * other\n    }\n}\n\nimpl Mul for i8 {\n    fn mul(self, other: i8) -> i8 {\n        self * other\n    }\n}\nimpl Mul for i16 {\n    fn mul(self, other: i16) -> i16 {\n        self * other\n    }\n}\nimpl Mul for i32 {\n    fn mul(self, other: i32) -> i32 {\n        self * other\n    }\n}\nimpl Mul for i64 {\n    fn mul(self, other: i64) -> i64 {\n        self * other\n    }\n}\n\n// docs:start:div-trait\npub trait Div {\n    fn div(self, other: Self) -> Self;\n}\n// docs:end:div-trait\n\nimpl Div for Field {\n    fn div(self, other: Field) -> Field {\n        self / other\n    }\n}\n\nimpl Div for u128 {\n    fn div(self, other: u128) -> u128 {\n        self / other\n    }\n}\nimpl Div for u64 {\n    fn div(self, other: u64) -> u64 {\n        self / other\n    }\n}\nimpl Div for u32 {\n    fn div(self, other: u32) -> u32 {\n        self / other\n    }\n}\nimpl Div for u16 {\n    fn div(self, other: u16) -> u16 {\n        self / other\n    }\n}\nimpl Div for u8 {\n    fn div(self, other: u8) -> u8 {\n        self / other\n    }\n}\nimpl Div for u1 {\n    fn div(self, other: u1) -> u1 {\n        self / other\n    }\n}\n\nimpl Div for i8 {\n    fn div(self, other: i8) -> i8 {\n        self / other\n    }\n}\nimpl Div for i16 {\n    fn div(self, other: i16) -> i16 {\n        self / other\n    }\n}\nimpl Div for i32 {\n    fn div(self, other: i32) -> i32 {\n        self / other\n    }\n}\nimpl Div for i64 {\n    fn div(self, other: i64) -> i64 {\n        self / other\n    }\n}\n\n// docs:start:rem-trait\npub trait Rem {\n    fn rem(self, other: Self) -> Self;\n}\n// docs:end:rem-trait\n\nimpl Rem for u128 {\n    fn rem(self, other: u128) -> u128 {\n        self % other\n    }\n}\nimpl Rem for u64 {\n    fn rem(self, other: u64) -> u64 {\n        self % other\n    }\n}\nimpl Rem for u32 {\n    fn rem(self, other: u32) -> u32 {\n        self % other\n    }\n}\nimpl Rem for u16 {\n    fn rem(self, other: u16) -> u16 {\n        self % other\n    }\n}\nimpl Rem for u8 {\n    fn rem(self, other: u8) -> u8 {\n        self % other\n    }\n}\nimpl Rem for u1 {\n    fn rem(self, other: u1) -> u1 {\n        self % other\n    }\n}\n\nimpl Rem for i8 {\n    fn rem(self, other: i8) -> i8 {\n        self % other\n    }\n}\nimpl Rem for i16 {\n    fn rem(self, other: i16) -> i16 {\n        self % other\n    }\n}\nimpl Rem for i32 {\n    fn rem(self, other: i32) -> i32 {\n        self % other\n    }\n}\nimpl Rem for i64 {\n    fn rem(self, other: i64) -> i64 {\n        self % other\n    }\n}\n\n// docs:start:neg-trait\npub trait Neg {\n    fn neg(self) -> Self;\n}\n// docs:end:neg-trait\n\n// docs:start:neg-trait-impls\nimpl Neg for Field {\n    fn neg(self) -> Field {\n        -self\n    }\n}\n\nimpl Neg for i8 {\n    fn neg(self) -> i8 {\n        -self\n    }\n}\nimpl Neg for i16 {\n    fn neg(self) -> i16 {\n        -self\n    }\n}\nimpl Neg for i32 {\n    fn neg(self) -> i32 {\n        -self\n    }\n}\nimpl Neg for i64 {\n    fn neg(self) -> i64 {\n        -self\n    }\n}\n// docs:end:neg-trait-impls\n\n// docs:start:wrapping-add-trait\npub trait WrappingAdd {\n    fn wrapping_add(self, y: Self) -> Self;\n}\n// docs:end:wrapping-add-trait\n\nimpl WrappingAdd for u1 {\n    fn wrapping_add(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingAdd for u8 {\n    fn wrapping_add(self: u8, y: u8) -> u8 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u16 {\n    fn wrapping_add(self: u16, y: u16) -> u16 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u32 {\n    fn wrapping_add(self: u32, y: u32) -> u32 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u64 {\n    fn wrapping_add(self: u64, y: u64) -> u64 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u128 {\n    fn wrapping_add(self: u128, y: u128) -> u128 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i8 {\n    fn wrapping_add(self: i8, y: i8) -> i8 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i16 {\n    fn wrapping_add(self: i16, y: i16) -> i16 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i32 {\n    fn wrapping_add(self: i32, y: i32) -> i32 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i64 {\n    fn wrapping_add(self: i64, y: i64) -> i64 {\n        wrapping_add_hlp(self, y)\n    }\n}\nimpl WrappingAdd for Field {\n    fn wrapping_add(self: Field, y: Field) -> Field {\n        self + y\n    }\n}\n\n// docs:start:wrapping-sub-trait\npub trait WrappingSub {\n    fn wrapping_sub(self, y: Self) -> Self;\n}\n// docs:start:wrapping-sub-trait\n\nimpl WrappingSub for u1 {\n    fn wrapping_sub(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingSub for u8 {\n    fn wrapping_sub(self: u8, y: u8) -> u8 {\n        wrapping_sub_hlp(self, y) as u8\n    }\n}\n\nimpl WrappingSub for u16 {\n    fn wrapping_sub(self: u16, y: u16) -> u16 {\n        wrapping_sub_hlp(self, y) as u16\n    }\n}\n\nimpl WrappingSub for u32 {\n    fn wrapping_sub(self: u32, y: u32) -> u32 {\n        wrapping_sub_hlp(self, y) as u32\n    }\n}\nimpl WrappingSub for u64 {\n    fn wrapping_sub(self: u64, y: u64) -> u64 {\n        wrapping_sub_hlp(self, y) as u64\n    }\n}\nimpl WrappingSub for u128 {\n    fn wrapping_sub(self: u128, y: u128) -> u128 {\n        wrapping_sub_hlp(self, y) as u128\n    }\n}\n\nimpl WrappingSub for i8 {\n    fn wrapping_sub(self: i8, y: i8) -> i8 {\n        wrapping_sub_hlp(self, y) as i8\n    }\n}\n\nimpl WrappingSub for i16 {\n    fn wrapping_sub(self: i16, y: i16) -> i16 {\n        wrapping_sub_hlp(self, y) as i16\n    }\n}\n\nimpl WrappingSub for i32 {\n    fn wrapping_sub(self: i32, y: i32) -> i32 {\n        wrapping_sub_hlp(self, y) as i32\n    }\n}\nimpl WrappingSub for i64 {\n    fn wrapping_sub(self: i64, y: i64) -> i64 {\n        wrapping_sub_hlp(self, y) as i64\n    }\n}\nimpl WrappingSub for Field {\n    fn wrapping_sub(self: Field, y: Field) -> Field {\n        self - y\n    }\n}\n\n// docs:start:wrapping-mul-trait\npub trait WrappingMul {\n    fn wrapping_mul(self, y: Self) -> Self;\n}\n// docs:start:wrapping-mul-trait\n\nimpl WrappingMul for u1 {\n    fn wrapping_mul(self: u1, y: u1) -> u1 {\n        self & y\n    }\n}\n\nimpl WrappingMul for u8 {\n    fn wrapping_mul(self: u8, y: u8) -> u8 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u16 {\n    fn wrapping_mul(self: u16, y: u16) -> u16 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u32 {\n    fn wrapping_mul(self: u32, y: u32) -> u32 {\n        wrapping_mul_hlp(self, y)\n    }\n}\nimpl WrappingMul for u64 {\n    fn wrapping_mul(self: u64, y: u64) -> u64 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i8 {\n    fn wrapping_mul(self: i8, y: i8) -> i8 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i16 {\n    fn wrapping_mul(self: i16, y: i16) -> i16 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i32 {\n    fn wrapping_mul(self: i32, y: i32) -> i32 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i64 {\n    fn wrapping_mul(self: i64, y: i64) -> i64 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u128 {\n    fn wrapping_mul(self: u128, y: u128) -> u128 {\n        wrapping_mul128_hlp(self, y)\n    }\n}\nimpl WrappingMul for Field {\n    fn wrapping_mul(self: Field, y: Field) -> Field {\n        self * y\n    }\n}\n\nfn wrapping_add_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\nfn wrapping_sub_hlp<T>(x: T, y: T) -> Field\nwhere\n    T: AsPrimitive<Field>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    x.as_() + 340282366920938463463374607431768211456 - y.as_()\n}\n\nfn wrapping_mul_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\nglobal two_pow_64: u128 = 0x10000000000000000;\n/// Splits a 128 bits number into two 64 bits limbs\nunconstrained fn split64(x: u128) -> (u64, u64) {\n    let lo = x as u64;\n    let hi = (x / two_pow_64) as u64;\n    (lo, hi)\n}\n\n/// Split a 128 bits number into two 64 bits limbs\n/// It will fail if the number is more than 128 bits\nfn split_into_64_bit_limbs(x: u128) -> (u64, u64) {\n    // Safety: the limbs are constrained below\n    let (x_lo, x_hi) = unsafe { split64(x) };\n    assert(x as Field == x_lo as Field + x_hi as Field * two_pow_64 as Field);\n    (x_lo, x_hi)\n}\n\n#[field(bn254)]\nfn wrapping_mul128_hlp(x: u128, y: u128) -> u128 {\n    let (x_lo, x_hi) = split_into_64_bit_limbs(x);\n    let (y_lo, y_hi) = split_into_64_bit_limbs(y);\n    // Multiplication using the limbs:(x_lo + 2**64*x_hi)*(y_lo + 2**64*y_hi)=x_lo*y_lo+...\n    // and skipping the terms over 2**128\n    // Working with u64 limbs ensures that we cannot overflow the field modulus.\n    let low = x_lo as Field * y_lo as Field;\n    let lo = low as u64 as Field;\n    let carry = (low - lo) / two_pow_64 as Field;\n    let high = x_lo as Field * y_hi as Field + x_hi as Field * y_lo as Field + carry;\n    let hi = high as u64 as Field;\n    (lo + two_pow_64 as Field * hi) as u128\n}\n"
    },
    "407": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_padded_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_padded_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_padded_array::{\n    assert_sorted_transformed_i_padded_array_capped_size,\n    assert_sorted_transformed_padded_array_capped_size, validate_padded_items,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_padded_arrays::assert_split_transformed_padded_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "410": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "420": {
      "path": "/home/g/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "423": {
      "path": "/home/g/nargo/github.com/noir-lang/noir-bignum/v0.7.5/src/bignum.nr",
      "source": "use crate::fns::constrained_ops::limbs_to_field;\nuse crate::params::BigNumParams;\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub trait BigNum: Neg + Add + Sub + Mul + Div + Eq {\n    let N: u32;\n    let MOD_BITS: u32;\n\n    fn params() -> BigNumParams<N, MOD_BITS>;\n    fn modulus_bits(_: Self) -> u32;\n    fn num_limbs(_: Self) -> u32;\n    fn modulus() -> Self;\n\n    fn new() -> Self;\n    fn zero() -> Self;\n    fn one() -> Self;\n    fn from_limbs(limbs: [u128; N]) -> Self;\n    fn get_limbs(self) -> [u128; N];\n    fn set_limb(self: &mut Self, idx: u32, value: u128);\n    fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    fn from_be_bytes(x: [u8; (MOD_BITS + 7) / 8]) -> Self;\n    fn to_be_bytes(self) -> [u8; (MOD_BITS + 7) / 8];\n    fn from_le_bytes(x: [u8; (MOD_BITS + 7) / 8]) -> Self;\n    fn to_le_bytes(self) -> [u8; (MOD_BITS + 7) / 8];\n\n    fn get_limb(self: Self, idx: u32) -> u128 {\n        self.get_limbs()[idx]\n    }\n\n    unconstrained fn __eq(self: Self, other: Self) -> bool;\n\n    unconstrained fn __is_zero(self: Self) -> bool;\n\n    unconstrained fn __neg(self) -> Self;\n    unconstrained fn __add(self, other: Self) -> Self;\n    unconstrained fn __sub(self, other: Self) -> Self;\n    unconstrained fn __mul(self, other: Self) -> Self;\n    unconstrained fn __div(self, other: Self) -> Self;\n    unconstrained fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    unconstrained fn __invmod(self) -> Self;\n    unconstrained fn __pow(self, exponent: Self) -> Self;\n\n    unconstrained fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    fn assert_is_not_equal(self: Self, other: Self);\n\n    fn validate_in_range(self);\n    fn validate_in_field(self);\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self);\n    fn udiv(self, divisor: Self) -> Self;\n    fn umod(self, divisor: Self) -> Self;\n\n    fn is_zero(self) -> bool;\n}\n\n// we need macros that implement the BigNum, Default, From, Neg, Add, Sub, Mul, Div, Eq, Ord traits for each bignum type\npub comptime fn derive_bignum(\n    strukt: TypeDefinition,\n    N: u32,\n    MOD_BITS: u32,\n    params: Quoted,\n) -> Quoted {\n    let constrained_ops = quote { $crate::fns::constrained_ops };\n    let unconstrained_ops = quote { $crate::fns::unconstrained_ops };\n    let typ = strukt.as_type();\n    let serialization = quote { $crate::fns::serialization };\n    quote {\n\n        // implement BigNum for BigNum \n        impl $crate::BigNum for $typ {\n            let N: u32 = $N; \n            let MOD_BITS: u32 = $MOD_BITS;\n            \n            fn modulus_bits(_: Self) -> u32 {\n                $MOD_BITS\n            }\n            \n            fn num_limbs(_: Self) -> u32 {\n                $N\n            }\n\n            fn modulus() -> Self {\n                Self { limbs: Self::params().modulus }\n            }\n\n            fn new() -> Self {\n                Self {limbs: [0; $N]}\n            }\n\n            fn params() -> $crate::params::BigNumParams<$N, $MOD_BITS> {\n                $params\n            }\n\n            fn from_limbs(limbs: [u128; $N]) -> Self {\n                Self { limbs }\n            }\n\n            fn get_limbs(self: Self) -> [u128; $N] {\n                self.limbs\n            }\n\n            fn set_limb(self: &mut Self, idx: u32, value: u128) {\n                self.limbs[idx] = value;\n            }\n\n            fn zero() -> Self {\n                Self { limbs: [0; $N] }\n            }\n\n            fn one() -> Self {\n                let mut limbs = [0; $N];\n                limbs[0] = 1;\n                Self { limbs }\n            }\n\n            fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n                let params = Self::params();\n                $typ::from_limbs($constrained_ops::derive_from_seed::<_, $MOD_BITS, _>(params, seed))\n            }\n\n            unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n                let params = Self::params();\n                Self { limbs: $unconstrained_ops::__derive_from_seed::<_, $MOD_BITS, _>(params, seed) }\n            }\n\n            fn from_be_bytes(x: [u8; ($MOD_BITS + 7) / 8]) -> Self {\n                Self { limbs: $serialization::from_be_bytes::<_, $MOD_BITS>(x) }\n            }\n            \n            fn to_be_bytes(self) -> [u8; ($MOD_BITS + 7) / 8] {\n                $serialization::to_be_bytes::<_, $MOD_BITS>(self.limbs)\n            }\n\n            fn from_le_bytes(x: [u8; ($MOD_BITS + 7) / 8]) -> Self {\n                Self { limbs: $serialization::from_le_bytes::<_, $MOD_BITS>(x) }\n            }\n\n            fn to_le_bytes(self) -> [u8; ($MOD_BITS + 7) / 8] {\n                $serialization::to_le_bytes::<_, $MOD_BITS>(self.limbs)\n            }\n\n            unconstrained fn __eq(self: Self, other: Self) -> bool {\n                $crate::fns::unconstrained_ops::__eq(self.get_limbs(), other.get_limbs())\n            }\n\n            unconstrained fn __is_zero(self: Self) -> bool {\n                $crate::fns::unconstrained_ops::__is_zero(self.get_limbs())\n            }\n\n            unconstrained fn __neg(self: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__neg(params.modulus, self.get_limbs())}\n            }\n\n            unconstrained fn __add(self: Self, other: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__add(params.modulus, self.get_limbs(), other.get_limbs())}\n            }\n\n            unconstrained fn __sub(self: Self, other: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__sub(params.modulus, self.get_limbs(), other.get_limbs())}\n            }\n\n            unconstrained fn __mul(self: Self, other: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__mul(params, self.get_limbs(), other.get_limbs())}\n            }\n\n            unconstrained fn __div(self: Self, divisor: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__div(params, self.get_limbs(), divisor.get_limbs())}\n            }\n\n            unconstrained fn __udiv_mod(self: Self, divisor: Self) -> (Self, Self) {\n                let (q, r) = $unconstrained_ops::__udiv_mod(self.get_limbs(), divisor.get_limbs());\n                (Self{limbs: q}, Self{limbs: r})\n            }\n\n            unconstrained fn __invmod(self: Self) -> Self {\n                let params = Self::params();\n                assert(params.has_multiplicative_inverse);\n                Self {limbs: $unconstrained_ops::__invmod(params, self.get_limbs())}\n            }\n\n            unconstrained fn __pow(self: Self, exponent: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__pow(params, self.get_limbs(), exponent.get_limbs())}\n            }\n\n            unconstrained fn __tonelli_shanks_sqrt(self: Self) -> std::option::Option<Self> {\n                let params = Self::params();\n                let maybe_limbs = $unconstrained_ops::__tonelli_shanks_sqrt(params, self.get_limbs());\n                maybe_limbs.map(|limbs| Self {limbs: limbs})\n            }\n\n\n            fn assert_is_not_equal(self: Self, other: Self) {\n                let params = Self::params();\n                $crate::fns::constrained_ops::assert_is_not_equal(\n                    params,\n                    self.get_limbs(),\n                    other.get_limbs(),\n                );\n            }\n\n            fn validate_in_field(self: Self) {\n                let params = Self::params();\n                $constrained_ops::validate_in_field::<_, $MOD_BITS>(params, self.get_limbs());\n            }\n\n            fn validate_in_range(self: Self) {\n                $constrained_ops::validate_in_range::<_, _, $MOD_BITS>(self.get_limbs());\n            }\n\n            fn udiv_mod(self: Self, divisor: Self) -> (Self, Self) {\n                let params = Self::params();\n                let (q, r) = $constrained_ops::udiv_mod::<_, $MOD_BITS>(params, self.get_limbs(), divisor.get_limbs());\n                (Self {limbs: q}, Self {limbs: r})\n            }\n\n            fn udiv(self: Self, divisor: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $constrained_ops::udiv::<_, $MOD_BITS>(params, self.get_limbs(), divisor.get_limbs())}\n            }\n\n            fn umod(self: Self, divisor: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $constrained_ops::umod::<_, $MOD_BITS>(params, self.get_limbs(), divisor.get_limbs())}\n            }\n\n            fn is_zero(self: Self) -> bool {\n                $constrained_ops::is_zero::<_, $MOD_BITS>(self.get_limbs())\n            }\n        }\n\n        // implement Default for BigNum\n        impl Default for $typ {\n            fn default() -> Self {\n                $typ::from_limbs([0; $N])\n            }\n        }\n\n        impl std::convert::From<Field> for $typ {\n            fn from(input: Field) -> Self {\n                $typ { limbs: $constrained_ops::from_field::<$N, $MOD_BITS>($params, input) }\n            }\n        }\n\n        impl std::ops::Neg for $typ {\n            fn neg(self) -> Self {\n                $typ { limbs: $constrained_ops::neg::<$N, $MOD_BITS>($params, self.limbs) }\n            }\n        }\n\n        impl std::ops::Add for $typ {\n            fn add(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::add::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::ops::Sub for $typ {\n            fn sub(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::sub::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::ops::Mul for $typ {\n            fn mul(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::mul::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::ops::Div for $typ {\n            fn div(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::div::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::cmp::Eq for $typ {\n            fn eq(self, other: Self) -> bool {\n                $constrained_ops::eq::<$N, $MOD_BITS>($params, self.limbs, other.limbs)\n            }\n        }\n\n        impl std::cmp::Ord for $typ {\n            fn cmp(self, other: Self) -> std::cmp::Ordering {\n                $constrained_ops::cmp::<$N, $MOD_BITS>(self.limbs, other.limbs)\n            }\n        }\n\n    }\n}\n\npub fn conditional_select<T: BigNum>(lhs: T, rhs: T, predicate: bool) -> T {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub unconstrained fn compute_quadratic_expression<T: BigNum, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    lhs_terms: [[T; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[T; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [T; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> (T, T) {\n    let params = T::params();\n    let (q_limbs, r_limbs) = crate::fns::expressions::compute_quadratic_expression(\n        params,\n        crate::utils::map::map(\n            lhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        lhs_flags,\n        crate::utils::map::map(\n            rhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        rhs_flags,\n        crate::utils::map::map(linear_terms, |bn: T| bn.get_limbs()),\n        linear_flags,\n    );\n    (T::from_limbs(q_limbs), T::from_limbs(r_limbs))\n}\n\npub fn evaluate_quadratic_expression<T: BigNum, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    lhs_terms: [[T; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[T; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [T; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    let params = T::params();\n    crate::fns::expressions::evaluate_quadratic_expression(\n        params,\n        crate::utils::map::map(\n            lhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        lhs_flags,\n        crate::utils::map::map(\n            rhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        rhs_flags,\n        crate::utils::map::map(linear_terms, |bn: T| bn.get_limbs()),\n        linear_flags,\n    )\n}\n\npub unconstrained fn batch_invert<T: BigNum, let M: u32>(x: [T; M]) -> [T; M] {\n    let params = T::params();\n    assert(params.has_multiplicative_inverse);\n    crate::fns::unconstrained_ops::batch_invert(params, x.map(|bn: T| bn.get_limbs())).map(|limbs| {\n        T::from_limbs(limbs)\n    })\n}\n\npub unconstrained fn batch_invert_slice<T: BigNum>(x: [T]) -> [T] {\n    let params = T::params();\n    assert(params.has_multiplicative_inverse);\n    crate::fns::unconstrained_ops::batch_invert_slice(params, x.map(|bn: T| bn.get_limbs()))\n        .map(|limbs| T::from_limbs(limbs))\n}\n\npub fn to_field<T: BigNum>(bn: T) -> Field {\n    let params = T::params();\n    limbs_to_field(params, bn.get_limbs())\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "455": {
      "path": "/home/g/nargo/github.com/noir-lang/noir-bignum/v0.7.5/src/fns/constrained_ops.nr",
      "source": "use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\nuse std::cmp::Ordering;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n * gt \n * check_gt_with_flags\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n        let mut grumpkin_modulus = [0; N];\n        if N > 2 {\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n        }\n        if MOD_BITS > 253 {\n            // this means that the field modulus is larger than grumpkin modulus so we have to check if the element fields in the field size are less than the grumpkin modulus.\n            // also for correct params N is always larger than 3 here\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n        } else if MOD_BITS < 253 {\n            // this means that the field modulus is smaller than grumpkin modulus so we have to check if the element fields in the field size\n            validate_in_field(_params, result);\n        } else {\n            // this is the tricky part, when MOD_BITS = 253, so we have to compare the limbs of the modulus to the grumpkin modulus limbs\n            // any bignum with 253 bits will have 3 limbs\n\n            // if modulus is larger than grumpkin modulus, this will be true\n            let mut gt_grumpkin = false;\n            for i in 0..3 {\n                if !gt_grumpkin {\n                    if _params.modulus[2 - i] < grumpkin_modulus[2 - i] {\n                        gt_grumpkin = true;\n                    }\n                }\n            }\n            let result_2 = if gt_grumpkin {\n                _params.modulus\n            } else {\n                grumpkin_modulus\n            };\n            validate_gt::<N, MOD_BITS>(result_2, result);\n        }\n\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        poseidon::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        if num_bytes >= num_filled_bytes {\n            let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n            let mut num_remaining_limbs =\n                (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n            let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n            let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n                + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n            for j in 0..num_limbs_in_bigfield {\n                let mut limb: u128 = 0;\n                for _ in 0..15 {\n                    let need_more_bytes = (byte_ptr < num_bytes);\n                    let mut byte = hash_buffer[byte_ptr];\n                    limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                    limb += byte as u128 * need_more_bytes as u128;\n                    byte_ptr += need_more_bytes as u32;\n                }\n                bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n            }\n            bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n        }\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n    assert(!underflow, \"BigNum::validate_gt check fails\");\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params.modulus, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params.modulus, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params.modulus, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n// a comparison function. returns true if lhs > rhs and false otherwise\npub(crate) fn cmp<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) -> Ordering {\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    // if underflow is true, swap lhs and rhs\n    let (lhs, rhs) = if underflow { (rhs, lhs) } else { (lhs, rhs) };\n\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n    if lhs == rhs {\n        Ordering::equal()\n    } else if underflow {\n        Ordering::less()\n    } else {\n        Ordering::greater()\n    }\n}\n\n// the constraining function for the results returned by __validate_gt_remainder. this is used in both comparisons and validate gt\npub(crate) fn check_gt_with_flags<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    result: [u128; N],\n    borrow_flags: [bool; N],\n    carry_flags: [bool; N],\n) {\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i] as Field\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1] as Field\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n"
    },
    "459": {
      "path": "/home/g/nargo/github.com/noir-lang/noir-bignum/v0.7.5/src/fns/unconstrained_helpers.nr",
      "source": "use crate::constants::{TWO_POW_119, TWO_POW_120};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> (bool, [u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n\n    let mut result: [u128; N] = [0; N];\n    // swap a and b if there's an underflow\n    let (a, b) = if underflow { (b, a) } else { (a, b) };\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (underflow, result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32>(\n    modulus: [u128; N],\n    val: [u128; N],\n) -> ([u128; N], [bool; N - 1]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        if (i < N - 1) {\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params.modulus, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params.modulus, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift = (120 - limb_shift) as u8;\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> limb_shift);\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift: u8 = 120 - limb_shift as u8;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[(N - 1 - i)];\n        if (v > 0) {\n            count = 120 * (N - 1 - i) + get_msb(v);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = bit % 120;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index as u8) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "460": {
      "path": "/home/g/nargo/github.com/noir-lang/noir-bignum/v0.7.5/src/fns/unconstrained_ops.nr",
      "source": "use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32>(modulus: [u128; N], limbs: [u128; N]) -> [u128; N] {\n    __helper_sub(modulus, limbs)\n}\n\npub(crate) unconstrained fn __add<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, modulus) {\n        __helper_sub(result, modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(modulus, lhs, __neg(modulus, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n"
    },
    "469": {
      "path": "/home/g/nargo/github.com/noir-lang/noir-bignum/v0.7.5/src/utils/msb.nr",
      "source": "use std::ops::WrappingMul;\n\nglobal MUL_DE_BRUIJN_BIT: [u32; 128] = [\n    1, 14, 2, 15, 26, 20, 3, 16, 68, 80, 27, 21, 56, 50, 4, 17, 65, 96, 69, 81, 105, 99, 28, 22, 86,\n    90, 57, 51, 72, 42, 5, 126, 18, 66, 48, 94, 97, 84, 70, 124, 82, 122, 106, 100, 114, 108, 29,\n    23, 77, 102, 87, 91, 119, 116, 58, 52, 61, 110, 73, 37, 43, 31, 6, 127, 13, 25, 19, 67, 79, 55,\n    49, 64, 95, 104, 98, 85, 89, 71, 41, 125, 47, 93, 83, 123, 121, 113, 107, 76, 101, 118, 115, 60,\n    109, 36, 30, 12, 24, 78, 54, 63, 103, 88, 40, 46, 92, 120, 112, 75, 117, 59, 35, 11, 53, 62, 39,\n    45, 111, 74, 34, 10, 38, 44, 33, 9, 32, 8, 7, 128,\n];\n\npub(crate) unconstrained fn get_msb(x: u128) -> u32 {\n    let result = if x == 0 {\n        0\n    } else {\n        let mut v = x;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v |= v >> 32;\n        v |= v >> 64;\n        let index = (v.wrapping_mul(0x1FC10C2FBCF471B913B14CD2595D6D5)) >> 121;\n        (index as Field).assert_max_bit_size::<32>();\n        MUL_DE_BRUIJN_BIT[index as u32]\n    };\n    result\n}\n\nmod tests {\n    use crate::constants::{TWO_POW_120, TWO_POW_60};\n    use crate::fns::unconstrained_helpers::__get_msb;\n    use super::get_msb as get_msb128;\n    use std::ops::WrappingMul;\n\n    fn assert_msb_equal(x: u64) {\n        let msb64 = unsafe { get_msb64(x) };\n        let msb128 = unsafe { get_msb128(x as u128) };\n        assert_eq(msb64, msb128);\n    }\n\n    #[test]\n    // To check that the msb functions are equivalent with de bruijn sequence for 64 bits and 128 bits\n    fn test_get_msb() {\n        // Test case 1: MSB at position 7\n        let x = 0x80; // binary: 10000000\n        assert_msb_equal(x);\n\n        // Test case 2: MSB at position 0\n        let x = 0x1; // binary: 00000001\n        assert_msb_equal(x);\n\n        // Test case 3: MSB at position 63\n        let x = 0x8000000000000000; // binary: 1000...0000 (63 zeros)\n        assert_msb_equal(x);\n\n        // Test case 4: Zero input\n        let x = 0x0;\n        assert_msb_equal(x);\n\n        // Test case 5: All bits set\n        let x = 0xFFFFFFFFFFFFFFFF;\n        assert_msb_equal(x);\n    }\n\n    /// Multiple entires in the `MUL_DE_BRUIJN_BIT` list do not map to a valid output of `v * 0x6c04f118e9966f6b`.\n    /// This is a dummy value to fill the gaps in the map.\n    global n1: u32 = 0xffffffff;\n\n    global MUL_DE_BRUIJN_BIT_64: [u32; 128] = [\n        0, // change to 1 if you want bitSize(0) = 1\n        48, n1, n1, 31, n1, 15, 51, n1, 63, 5, n1, n1, n1, 19, n1, 23, 28, n1, n1, n1, 40, 36, 46,\n        n1, 13, n1, n1, n1, 34, n1, 58, n1, 60, 2, 43, 55, n1, n1, n1, 50, 62, 4, n1, 18, 27, n1,\n        39, 45, n1, n1, 33, 57, n1, 1, 54, n1, 49, n1, 17, n1, n1, 32, n1, 53, n1, 16, n1, n1, 52,\n        n1, n1, n1, 64, 6, 7, 8, n1, 9, n1, n1, n1, 20, 10, n1, n1, 24, n1, 29, n1, n1, 21, n1, 11,\n        n1, n1, 41, n1, 25, 37, n1, 47, n1, 30, 14, n1, n1, n1, n1, 22, n1, n1, 35, 12, n1, n1, n1,\n        59, 42, n1, n1, 61, 3, 26, 38, 44, n1, 56,\n    ];\n\n    pub(crate) unconstrained fn get_msb64(x: u64) -> u32 {\n        let mut v = x;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v |= v >> 32;\n        let index = (v.wrapping_mul(0x6c04f118e9966f6b)) >> 57;\n        (index as Field).assert_max_bit_size::<32>();\n        MUL_DE_BRUIJN_BIT_64[index as u32]\n    }\n\n    unconstrained fn __get_msb64<let N: u32>(val: [u128; N]) -> u32 {\n        let mut count = 0;\n        for i in 0..N {\n            let v = val[((N) - 1 - i)];\n            let v_low = v as u64 % TWO_POW_60 as u64;\n            let v_high = ((v - v_low as u128) / TWO_POW_60) as u64;\n            if (v_high > 0) {\n                count = 60 * ((2 * N) - 1 - (i * 2)) + get_msb64(v_high);\n                break;\n            }\n            if (v_low > 0) {\n                count = 60 * ((2 * N) - 1 - (i * 2 + 1)) + get_msb64(v_low);\n                break;\n            }\n        }\n        count\n    }\n\n    #[test]\n    // To check that the msb functions are equivalent with de bruijn sequence for 64 bits and 128 bits\n    unconstrained fn test_get_msb_equivalence() {\n        // Test single limb (64-bit number)\n        let x = 0x8000000000000000;\n        let arr = [0, 0, x as u128, 0];\n        let msb1 = __get_msb64(arr);\n        let msb2 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test multiple limbs (120-bit number)\n        let x = 0x800000000000000000000000000000; // 120 bits number\n        let arr = [0, 0, x as u128, 0];\n        let msb1 = __get_msb64(arr);\n        let msb2 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test zero\n        let arr = [0, 0, 0, 0];\n        let msb1 = __get_msb64(arr);\n        let msb2 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test all bits set (120 bits)\n        let x = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // 120 bits\n        let arr = [0, x as u128, 0, 0];\n        let msb1 = __get_msb64(arr);\n        let msb2 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test systematic bit positions\n        for i in 0..120 {\n            let x: u128 = 1;\n            let shifted = x << i;\n            let arr = [0, shifted, 0, 0];\n            let msb1 = __get_msb64(arr);\n            let msb2 = __get_msb(arr);\n            assert_eq(msb1, msb2);\n        }\n\n        // Test random-like patterns (multiple bits set)\n        let patterns = [\n            0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, // alternating bits\n            0x555555555555555555555555555555, // alternating bits (opposite)\n            0x1234567890ABCDEF1234567890ABCD, // some pattern\n            0xFEDCBA0987654321FEDCBA09876543, // some pattern\n            0x800000000000000000000000000001, // highest and lowest bits\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE, // all bits except lowest\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFF, // all bits except highest\n        ];\n        for i in 0..patterns.len() {\n            let arr = [0, patterns[i] as u128, 0, 0];\n            let msb1 = __get_msb64(arr);\n            let msb2 = __get_msb(arr);\n            assert_eq(msb1, msb2);\n        }\n\n        // Test with MSB in different array positions (120 bits)\n        let x = 0x800000000000000000000000000000; // 120 bits\n        let arr1 = [x as u128, 0, 0, 0];\n        let arr2 = [0, x as u128, 0, 0];\n        let arr3 = [0, 0, x as u128, 0];\n        let arr4 = [0, 0, 0, x as u128];\n        let msb1_1 = __get_msb64(arr1);\n        let msb2_1 = __get_msb(arr1);\n        assert_eq(msb1_1, msb2_1);\n\n        let msb1_2 = __get_msb64(arr2);\n        let msb2_2 = __get_msb(arr2);\n        assert_eq(msb1_2, msb2_2);\n\n        let msb1_3 = __get_msb64(arr3);\n        let msb2_3 = __get_msb(arr3);\n        assert_eq(msb1_3, msb2_3);\n\n        let msb1_4 = __get_msb64(arr4);\n        let msb2_4 = __get_msb(arr4);\n        assert_eq(msb1_4, msb2_4);\n    }\n\n    #[test]\n    unconstrained fn fuzz_get_msb(seed: [u128; 5]) {\n        let mut seed_copy = seed;\n        for i in 0..5 {\n            seed_copy[i] = seed_copy[i] & (TWO_POW_120 - 1);\n        }\n        let msb1 = __get_msb64(seed_copy);\n        let msb2 = __get_msb(seed_copy);\n        assert_eq(msb1, msb2);\n    }\n}\n"
    },
    "470": {
      "path": "/home/g/nargo/github.com/noir-lang/noir-bignum/v0.7.5/src/utils/split_bits.nr",
      "source": "use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n"
    },
    "491": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        array_concat(note_completion_log, padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n}\n"
    },
    "51": {
      "path": "/home/g/Documents/Projects/Cloak/fzuk/packages/factory/src/fullMath.nr",
      "source": "use dep::bignum::{BigNum, bignum::to_field, U256};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\nglobal MAX_U8: u8 = 255 as u8;\nglobal MAX_U16: u16 = 65535 as u16;\nglobal MAX_U32: u32 = 4294967295 as u32;\nglobal MAX_U64: u64 = 18446744073709551615 as u64;\nglobal MAX_U128: u128 = 340282366920938463463374607431768211455 as u128;\nglobal MAX_U160: Field = 1461501637330902918203684832716283019655932542975;\nglobal MAX_FIELD: Field =\n    21888242871839275222246405745257275088548364400416034343698204186575808495616;\nglobal MAX_U256: U256 = U256::from_limbs([\n    1329227995784915872903807060280344575 as u128, // 2^120 - 1\n    1329227995784915872903807060280344575 as u128, // 2^120 - 1\n    65535 as u128, // 2^16 - 1\n]);\n\n// @notice Calculates floor(a*b/denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n// @param a The multiplicand\n// @param b The multiplier\n// @param denominator The divisor\n// @return result The 256-bit result\n// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\nfn mulDiv(a: Field, b: Field, denominator: Field) -> Field {\n    // 512-bit multiply [prod1 prod0] = a * b\n    // Compute the product mod 2**256 and mod 2**256 - 1\n    // then use the Chinese Remainder Theorem to reconstruct\n    // the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2**256 + prod0\n\n\n    let mut result = 0;\n    let mut ltResult = U256::from(0);\n    //  The variables prod0 and prod1 represent the least and most significant 256 bits of a 512-bit product\n    let mut prod0 = U256::from(0); // Least significant 256 bits of the product\n    let mut prod1 = U256::from(0); // Most significant 256 bits of the product\n\n    let mm = U256::from(mulmod(a, b, MAX_FIELD)); // let mm := mulmod(a, b, not(0))\n\n    prod0 = U256::from(a).mul(U256::from(b)); // prod0 := mul(a, b)\n    let mut subResult = mm.sub(prod0); // sub(mm, prod0)\n    if (mm < prod0) {\n        ltResult = U256::from(1);\n    } else {\n        ltResult = U256::from(0);\n    }\n\n    if (subResult <= ltResult) {\n        prod1 = U256::from(0);\n    } else {\n        prod1 = subResult.sub(ltResult);\n    }\n\n    // Handle non-overflow cases, 256 by 256 division\n    if (prod1 == U256::from(0)) {\n        assert((0).lt(denominator), \"bad denominator\");\n        result = to_field(prod0.udiv(U256::from(denominator)));\n        result\n    } else {\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        assert( 0 !=denominator, \"bad denominator\");\n        assert(U256::from(denominator) > prod1);\n\n        ////////////////////////////////\n        // 512 by 256 division.\n        ////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        let mut remainder = U256::from(0);\n        remainder = U256::from(mulmod(a, b, denominator));\n\n        // Subtract 256 bit number from 512 bit number\n        if (to_field(remainder) as u128 > to_field(prod0) as u128) {\n            ltResult = U256::from(1);\n        } else {\n            ltResult = U256::from(0);\n        }\n        prod1 = prod1 - ltResult;\n        prod0 = prod0 - remainder;\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n\n        let mut twos = U256::from(unsafe { largest_power_of_two_divisor(denominator) });\n        let mut newDenominator = U256::from(0);\n        newDenominator = (U256::from(denominator).udiv(twos)); //  denominator := div(denominator, twos)\n\n        // Divide [prod1 prod0] by the factors of two\n        prod0 = prod0.udiv(twos); //  prod0 := div(prod0, twos)\n\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n\n        let neg_twos = 0 - to_field(twos); //  twos := add(div(sub(0, twos), twos), 1)\n        let quotient = neg_twos / to_field(twos);\n        let twos = U256::from(quotient + 1);\n\n        let mut tempProd0 = 0;\n        tempProd0 |= (to_field(prod1) * to_field(twos)) as u128;\n\n        prod0 = U256::from(tempProd0 as Field);\n\n        // Invert newDenominator mod 2**256\n        // Now that newDenominator is an odd number, it has an inverse\n        // modulo 2**256 such that newDenominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, newDenominator * inv = 1 mod 2**4\n        let mut inv = U256::from((3 * denominator).pow_32(2));\n\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n\n        assert(to_field(newDenominator) == 3);\n        inv = inv * (U256::from(2) - (newDenominator) * inv); // inverse mod 2**8\n        inv = inv * (U256::from(2) - (newDenominator) * inv); // inverse mod 2**16\n        inv = inv * (U256::from(2) - (newDenominator) * inv); // inverse mod 2**32\n        inv = inv * (U256::from(2) - (newDenominator) * inv); // inverse mod 2**64\n        inv = inv * (U256::from(2) - (newDenominator) * inv); // inverse mod 2**128\n        inv = inv * (U256::from(2) - (newDenominator) * inv); // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of newDenominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = to_field(prod0) * to_field(inv);\n\n        result\n    }\n}\n\n// @notice Calculates ceil(a*b/denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n// @param a The multiplicand\n// @param b The multiplier\n// @param denominator The divisor\n// @return result The 256-bit result\n//  (x * y) % k\nfn mulDivRoundingUp(\n    a: Field, //uint256\n    b: Field, //uint256\n    denominator: Field, //uint256\n) -> Field {\n    let mut result = mulDiv(a, b, denominator);\n    if ((mulmod(a, b, denominator)) as u128 > 0 as u128) {\n        assert((result) as u128 < (MAX_FIELD) as u128);\n        result = result + 1;\n    }\n\n    result\n}\n\nfn mulmod(\n    a: Field, //uint256\n    b: Field, //uint256\n    denominator: Field, //uint256\n) -> Field {\n    assert(denominator != 0, \"Denom must be > 0\");\n    let product = U256::from(a * b);\n    let quotient = product.udiv(U256::from(denominator));\n    let result: U256 = unsafe { product.__sub((quotient.__mul(U256::from(denominator)))) };\n    to_field(result)\n}\n\n// Function to compute the largest power of two divisor of a number using a for loop\nunconstrained fn largest_power_of_two_divisor(n: Field) -> Field {\n    // Ensure n is not zero to avoid division by zero\n    assert(n != 0, \"Input must be non-zero\");\n\n    // Initialize the result to 1\n    let mut result = 1;\n\n    // Initialize a temporary variable to hold the current value of n\n    let mut temp = n;\n\n    // Loop to divide temp by 2 until it's no longer even\n    for _ in 0..256 {\n        if temp as u128 % 2 as u128 == 0 as u128 {\n            result = result * 2;\n            temp = temp / 2;\n        } else {\n            break;\n        }\n    }\n\n    // Return the largest power of two divisor\n    result\n}\n"
    },
    "53": {
      "path": "/home/g/Documents/Projects/Cloak/fzuk/packages/factory/src/liquidityMath.nr",
      "source": "use bignum::bignum::to_field;\nuse dep::bignum::{U256};\n\n/// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\n/// @param x The liquidity before change\n/// @param y The delta by which liquidity should be changed\n/// @return z The liquidity delta\nfn addDelta(x: u128, y: u128, isNegDelta:bool) -> u128 {\n    let mut z = 0 ;\n    if (isNegDelta ) {\n        z =(x as Field - y as Field) as u128;\n        assert(z < x , \"LS\");\n    } \n    else {\n        z = x  + y;\n        assert(z >= x , \"LA\");\n    }\n\n    z\n}\n"
    },
    "54": {
      "path": "/home/g/Documents/Projects/Cloak/fzuk/packages/factory/src/main.nr",
      "source": "mod pairV3;\nmod tick;\nmod position;\nmod oracle;\nmod liquidityMath;\nmod swapMath;\nmod fullMath;\nmod sqrtPriceMath;\nmod unsafeMath;\nmod tickMath;\nmod tickBitmap;\nmod bitMath;\nmod swapCache;\nmod swapState;\nmod stepComputations;\nmod helpers;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract FactoryV3 {\n    use crate::oracle::Observation;\n    use crate::pairV3::Pair;\n    use crate::position::Position;\n    use crate::tick::Tick;\n    use crate::tickBitmap::TickBitMap;\n    use crate::tickMath::{getSqrtRatioAtTick, getTickAtSqrtRatio};\n    use dep::aztec::{\n        macros::{functions::{initializer, internal, private, public}, storage::storage},\n        prelude::{AztecAddress, Map, PublicMutable},\n        protocol_types::traits::ToField,\n    };\n    use dep::aztec::oracle::debug_log::{debug_log, debug_log_format};\n    use dep::bignum::{BigNum, bignum::to_field, U256};\n    use dep::token::Token;\n    use std::hash::pedersen_hash;\n    use std::ops::{Add, Div, Mul, Neg, Sub};\n\n    #[storage]\n    struct Storage<Context> {\n        admin: PublicMutable<AztecAddress, Context>, // DAO address\n        pools: Map<AztecAddress, Map<AztecAddress, Map<u32, PublicMutable<Pair, Context>, Context>, Context>, Context>, // tokenA => tokenB => fee = pool\n        // if tickSpacing is 10, only multiples of 10 will be valid as tick indexes (10, 20, 5000, 5010, but not 8, 12, 5001, etc.).\n        feeAmountTickSpacing: Map<Field, PublicMutable<Field, Context>, Context>, // uint24, int24\n        ticks: Map<AztecAddress, Map<AztecAddress, Map<u32, Map<Field, PublicMutable<Tick, Context>, Context>, Context>, Context>, Context>, // tokenA => tokenB => tick value = Tick info\n        approved_lps: Map<AztecAddress, Map<Field, PublicMutable<bool, Context>, Context>, Context>,\n        protocolFees: Map<Pair, PublicMutable<u8, Context>, Context>, // Factory contract owner can collect accrued protocol fees by calling collectProtocol\n        positions: Map<AztecAddress, Map<AztecAddress, Map<Field, PublicMutable<Position, Context>, Context>, Context>, Context>, // tokenA => tokenB => getKey() =>Position\n        tickBitmap: Map<AztecAddress, Map<AztecAddress, Map<bool, Map<Field, Map<Field, PublicMutable<TickBitMap, Context>, Context>, Context>, Context>, Context>, Context>, // tokenA => tokenB => lte => tick => tickSpacing => tickBitMap\n        observations: Map<AztecAddress, Map<AztecAddress, Map<u32, PublicMutable<[Observation; 256], Context>, Context>, Context>, Context>, // A pool contract can store up to 65,535 observations => 16 bits\n        observationByIndex: Map<AztecAddress, Map<AztecAddress, Map<u32, Map<Field, PublicMutable<Observation, Context>, Context>, Context>, Context>, Context>, // A pool contract can store up to 65,535 observations => 16 bits\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, lpToken: AztecAddress, lp_contract_id: Field) {\n        storage.admin.write(admin);\n        storage.approved_lps.at(lpToken).at(lp_contract_id).write(true);\n        storage.feeAmountTickSpacing.at(600).write(10);\n        storage.feeAmountTickSpacing.at(10000).write(200);\n    }\n\n    // @notice Returns the Info struct of a position, given an owner and position boundaries\n    // @param self The mapping containing all user positions\n    // @param owner The address of the position owner\n    // @param tickLower The lower tick boundary of the position\n    // @param tickUpper The upper tick boundary of the position\n    // @return position The position info struct of the given owners' position\n    #[internal]\n    #[public]\n    fn getKey(\n        owner: AztecAddress, // address\n        tickLower: u32, // int24\n        tickUpper: u32, // int24\n        isTickLowerNeg: bool,\n        isTickUpperNeg: bool,\n    ) -> pub Field {\n        let hash = pedersen_hash([\n            owner.to_field(),\n            isTickLowerNeg as Field,\n            isTickUpperNeg as Field,\n            tickLower as Field,\n            tickUpper as Field,\n        ]);\n\n        hash\n    }\n\n    #[private]\n    fn createPool_private(\n        tokenA: AztecAddress,\n        tokenB: AztecAddress,\n        fee: Field, // uint256\n    ) {\n        let _ = FactoryV3::at(context.this_address())._createPool(tokenA, tokenB, fee).enqueue(\n            &mut context,\n        );\n    }\n\n    #[public]\n    fn _createPool(\n        tokenA: AztecAddress,\n        tokenB: AztecAddress,\n        fee: Field, // uint256\n    ) {\n        let mut pool: Pair = FactoryV3::at(context.this_address())\n            .getPool(tokenA, tokenB, fee as u32)\n            .call(&mut context);\n        assert(pool.token0.is_zero(), \"ALREADY CREATED\");\n        assert(tokenA != tokenB, \"SAME_TOKEN_PAIR\");\n        let token0 = tokenA;\n        let token1: AztecAddress = tokenB;\n        assert(!token0.is_zero(), \"ZERO_ADDRESS\");\n        assert(!token1.is_zero(), \"ZERO_ADDRESS\");\n\n        let tickSpacing = storage.feeAmountTickSpacing.at(fee).read();\n        assert(tickSpacing != 0, \"ZERO_SPACING\");\n\n        let pool_storage = storage.pools.at(token0).at(token1).at(fee as u32);\n        let mut pair_data = pool_storage.read();\n        let _ = pair_data.__init__(tickSpacing, fee, token0, token1);\n\n        // populate mapping in the reverse direction, deliberate choice to avoid the cost of comparing addresses\n        let pool_storage = storage.pools.at(token0).at(token1).at(fee as u32);\n        pool_storage.write(pair_data);\n    }\n\n    #[public]\n    fn initialize_pool(\n        tokenA: AztecAddress,\n        tokenB: AztecAddress,\n        fee: Field,\n        sqrtPriceX96: Field,\n        tick: Field,\n        isNegTick: bool,\n    ) {\n        let pool_storage = storage.pools.at(tokenA).at(tokenB).at(fee as u32);\n        let mut pair_data = pool_storage.read();\n        if (pair_data.initiated == false) {\n            let mut observations_storage =\n                storage.observations.at(tokenA).at(tokenB).at(fee as u32);\n            let mut observations = observations_storage.read();\n            let mut theTick = 0 as i32;\n            if (isNegTick) {\n                theTick = -(tick as i32)\n            } else {\n                theTick = tick as i32\n            }\n\n            let mut observation = observations[context.block_number()];\n            pair_data.initialize(\n                &mut observation,\n                context.block_number(),\n                sqrtPriceX96,\n                theTick,\n            );\n            pool_storage.write(pair_data);\n        }\n    }\n\n    #[public]\n    fn set_admin(newAdmin: AztecAddress) {\n        assert(newAdmin != storage.admin.read());\n        storage.admin.write(newAdmin);\n    }\n\n    #[public]\n    fn get_admin() -> pub AztecAddress {\n        assert(context.msg_sender() != storage.admin.read());\n        storage.admin.read()\n    }\n\n    #[public]\n    fn enableFeeAmount(fee: Field, tickSpacing: Field) {\n        assert(context.msg_sender() == storage.admin.read());\n        assert((fee) as u128 < (1000000) as u128);\n        assert((tickSpacing) as u128 > 0 as u128);\n        // tick spacing is capped at 16384 to prevent the situation where tickSpacing is so large that\n        // TickBitmap#nextInitializedTickWithinOneWord overflows int24 container from a valid tick\n        // 16384 ticks represents a >5x price change with ticks of 1 bips\n        assert((tickSpacing) as u128 < (16384) as u128);\n        assert(storage.feeAmountTickSpacing.at(fee).read() == 0);\n        storage.feeAmountTickSpacing.at(fee).write(tickSpacing);\n    }\n\n    #[public]\n    fn checkFeeAmount(fee: Field) -> Field {\n        assert(storage.feeAmountTickSpacing.at(fee).read() != 0, \"NOT_SET\");\n        storage.feeAmountTickSpacing.at(fee).read()\n    }\n\n    #[public]\n    fn getTickSpacing(fee: Field) -> Field {\n        storage.feeAmountTickSpacing.at(fee as Field).read()\n    }\n\n    #[public]\n    fn getPool(\n        tokenA: AztecAddress,\n        tokenB: AztecAddress,\n        fee: u32, // uint24\n    ) -> Pair {\n        let pool_storage = storage.pools.at(tokenA).at(tokenB).at(fee);\n        let mut pair_data = pool_storage.read();\n        pair_data\n    }\n\n    #[public]\n    fn _mint(\n        tokenA: AztecAddress,\n        tokenB: AztecAddress,\n        fee: u32, // uint24,\n        recipient: AztecAddress, //address\n        tickLower: u32,\n        tickUpper: u32,\n        isTickLowerNeg: bool,\n        isTickUpperNeg: bool,\n        amount: u128,\n        lte: bool,\n        getSqrtRatioAtTickUpper: Field,\n        getSqrtRatioAtTickLower: Field,\n        nonce: Field,\n    ) -> [Field; 2] {\n        let mut finalLower = tickLower as i32;\n        let mut finalUpper = tickUpper as i32;\n        if (isTickLowerNeg) {\n            finalLower = -finalLower;\n        }\n        if (isTickUpperNeg) {\n            finalUpper = -finalUpper;\n        }\n\n        let positionKey = FactoryV3::at(context.this_address())\n            .getKey(recipient, tickLower, tickUpper, isTickLowerNeg, isTickUpperNeg)\n            .call(&mut context);\n\n        let pool_storage = storage.pools.at(tokenA).at(tokenB).at(fee as u32);\n        let mut pool = pool_storage.read();\n\n        let mut observations_storage = storage.observations.at(tokenA).at(tokenB).at(fee as u32);\n        let mut observations = observations_storage.read();\n\n        let balance0Before =\n            Token::at(tokenA).get_balance_of_public(context.this_address()).call(&mut context);\n        let balance1Before =\n            Token::at(tokenB).get_balance_of_public(context.this_address()).call(&mut context);\n\n        let mut position_storage = storage.positions.at(tokenA).at(tokenB).at(positionKey);\n        let mut position = position_storage.read();\n        let tickSpacing = storage.feeAmountTickSpacing.at(fee as Field).read();\n\n        let mut tickUpperBitmap_storage = storage\n            .tickBitmap\n            .at(tokenA)\n            .at(tokenB)\n            .at(lte) // lte is the flag that sets the direction. When true, were selling token x and searching for the next initialized tick to the right of the current one\n            .at(tickUpper as Field)\n            .at(tickSpacing as Field);\n        let mut tickUpperBitmap = tickUpperBitmap_storage.read();\n\n        let mut tickLowerBitmap_storage = storage\n            .tickBitmap\n            .at(tokenA)\n            .at(tokenB)\n            .at(lte)\n            .at(tickLower as Field)\n            .at(tickSpacing as Field);\n        let mut tickLowerBitmap = tickLowerBitmap_storage.read();\n\n        let mut currentTick_storage =\n            storage.ticks.at(tokenA).at(tokenB).at(fee).at(pool.slot0.tick as Field);\n        let mut currentTick = currentTick_storage.read();\n\n        pool.checkTicks(finalLower, finalUpper);\n\n        let mut tickLower_storage =\n            storage.ticks.at(tokenA).at(tokenB).at(fee).at(tickLower as Field);\n        let mut theTickLower = tickLower_storage.read();\n\n        let mut tickUpper_storage =\n            storage.ticks.at(tokenA).at(tokenB).at(fee).at(tickUpper as Field);\n        let mut theTickUpper = tickUpper_storage.read();\n\n        let (amount0, amount1, updatedPosition, updatedTickLower, updatedTickUpper, updatedCurrentTick): (Field, Field, &mut Position, &mut Tick, &mut Tick, &mut Tick) = pool\n            .mint(\n                &mut tickLowerBitmap,\n                &mut tickUpperBitmap,\n                &mut observations,\n                &mut position,\n                context.block_number(),\n                &mut theTickLower,\n                &mut theTickUpper,\n                amount as Field,\n                tickSpacing as i32,\n                &mut currentTick,\n                balance0Before,\n                balance1Before,\n                getSqrtRatioAtTickUpper,\n                getSqrtRatioAtTickLower,\n            );\n\n        if (amount0 as u128 > 0 as u128) {\n            let _res = Token::at(tokenA)\n                .transfer_in_public(recipient, context.this_address(), (amount0) as u128, nonce)\n                .call(&mut context);\n        }\n\n        if (amount1 as u128 > 0 as u128) {\n            let _res = Token::at(tokenB)\n                .transfer_in_public(recipient, context.this_address(), (amount1) as u128, nonce)\n                .call(&mut context);\n        }\n\n        let balance0Now =\n            Token::at(tokenA).get_balance_of_public(context.this_address()).call(&mut context);\n        let balance1Now =\n            Token::at(tokenB).get_balance_of_public(context.this_address()).call(&mut context);\n\n        let mut _balance0Before = 0;\n        let mut _balance1Before = 0;\n        if ((amount0 as u128) > 0 as u128) {\n            _balance0Before = balance0Before;\n        }\n        if ((amount1 as u128) > 0 as u128) {\n            _balance1Before = balance1Before;\n        }\n        if ((amount0 as u128) > 0 as u128) {\n            assert((balance0Before as u128) + (amount0 as u128) <= (balance0Now as u128), \"M0\");\n        }\n        if ((amount1) as u128 > 0 as u128) {\n            assert((balance1Before as u128) + (amount1 as u128) <= (balance1Now as u128), \"M1\");\n        }\n\n        let upC = updatedCurrentTick;\n        let upL = updatedTickLower;\n        let upU = updatedTickUpper;\n\n        position_storage.write(position);\n        currentTick_storage.write(*upC);\n        tickLower_storage.write(*upL);\n        tickUpper_storage.write(*upU);\n\n        observations_storage.write(observations);\n        tickLowerBitmap_storage.write(tickLowerBitmap);\n        tickUpperBitmap_storage.write(tickUpperBitmap);\n\n        pool_storage.write(pool);\n\n        [amount0, amount1]\n    }\n\n    //  @inheritdoc IUniswapV3PoolOwnerActions\n    #[public]\n    fn collectProtocol(\n        tokenA: AztecAddress,\n        tokenB: AztecAddress,\n        fee: Field,\n        recipient: AztecAddress, // address\n        amount0Requested: u128, // uint128\n        amount1Requested: u128, // uint128\n        nonce: Field,\n    ) -> pub [u128; 2] {\n        let mut pool: Pair = FactoryV3::at(context.this_address())\n            .getPool(tokenA, tokenB, fee as u32)\n            .call(&mut context);\n\n        let mut amount0 = 0 as u128;\n        let mut amount1 = 0 as u128;\n\n        if (amount0Requested > pool.protocolFees.token0) {\n            amount0 = pool.protocolFees.token0;\n        } else {\n            amount0 = amount0Requested;\n        }\n\n        if (amount1Requested > pool.protocolFees.token1) {\n            amount1 = pool.protocolFees.token1;\n        } else {\n            amount1 = amount1Requested;\n        }\n\n        if (amount0 > 0 as u128) {\n            if (amount0 == pool.protocolFees.token0) {\n                // ensure that the slot is not cleared, for gas savings\n                amount0 = amount0 - 1 as u128;\n            };\n            pool.protocolFees.token0 = pool.protocolFees.token0 - amount0;\n\n            let _ = Token::at(tokenA)\n                .transfer_in_public(recipient, context.this_address(), amount0, nonce)\n                .call(&mut context);\n        }\n\n        if (amount1 > 0 as u128) {\n            if (amount1 == pool.protocolFees.token1) {\n                amount1 = amount1 - 1 as u128;\n            } // ensure that the slot is not cleared, for gas savings\n            pool.protocolFees.token1 = pool.protocolFees.token1 - amount1;\n\n            let _ = Token::at(tokenA)\n                .transfer_in_public(recipient, context.this_address(), amount0, nonce)\n                .call(&mut context);\n        }\n        [amount0, amount1]\n    }\n\n    // // @inheritdoc IUniswapV3PoolOwnerActions\n    // #[public]\n    // fn setFeeProtocol(\n    //     tokenA: AztecAddress,\n    //     tokenB: AztecAddress,\n    //     fee: Field,\n    //     feeProtocol0: u8, //uint8\n    //     feeProtocol1: u8 // uint8\n    //      ) {\n    //     assert(context.msg_sender() == storage.admin.read());\n    //     assert((feeProtocol0 == 0 | (feeProtocol0 >= 4 & feeProtocol0 <= 10)) & (feeProtocol1 == 0 | (feeProtocol1 >= 4 & feeProtocol1 <= 10)));\n\n    //     let pool_storage = storage.pools.at(tokenA).at(tokenB).at(fee as u32);\n    //     let mut pool = pool_storage.read();\n    //     let feeProtocolOld = pool.slot0.feeProtocol;\n    //     pool.slot0.feeProtocol = feeProtocol0 + (feeProtocol1 << 4);\n    // }\n\n    // #[public]\n    // fn _swap(\n    //     tokenA: AztecAddress,\n    //     tokenB: AztecAddress,\n    //     fee: Field,\n    //     recipient: AztecAddress, // address\n    //     zeroForOne: bool, // bool\n    //     amountSpecified: Field, // int256\n    //     sqrtPriceLimitX96: Field, // uint160\n    //     lte: bool,\n    //     nonce: Field,\n    // ) -> pub [Field; 2] {\n    //     let pool_storage = storage.pools.at(tokenA).at(tokenB).at(fee as u32);\n    //     let mut pair_data = pool_storage.read();\n    //     let tick = storage.ticks.at(tokenA).at(tokenB).at(pair_data.slot0.tick as Field).read();\n    //     let tickSpacing = storage.feeAmountTickSpacing.at(fee).read();\n\n    //     let mut bitmap = storage\n    //         .tickBitmap\n    //         .at(tokenA)\n    //         .at(tokenB)\n    //         .at(lte)\n    //         .at(tick.value as Field)\n    //         .at(tickSpacing as Field)\n    //         .read();\n    //     let mut observations = storage.observations.at(tokenA).at(tokenB).read();\n\n    //     let return_values = pair_data.swap(\n    //         &mut bitmap,\n    //         observations,\n    //         zeroForOne,\n    //         amountSpecified,\n    //         sqrtPriceLimitX96,\n    //         context.block_number(),\n    //         tickSpacing as i32,\n    //         tick,\n    //     );\n    //     // do the transfers and collect payment\n\n    //     let amount0 = return_values[0];\n    //     let amount1 = return_values[1];\n\n    //     if (zeroForOne) {\n    //         if (amount1 as u128 < 0 as u128) {\n    //             let _ = Token::at(tokenB)\n    //                 .transfer_in_public(\n    //                     recipient,\n    //                     context.this_address(),\n    //                     (-amount1) as u128,\n    //                     nonce,\n    //                 )\n    //                 .call(&mut context);\n    //         }\n\n    //         let balance0 =  Token::at(tokenA).get_balance_of_public(context.this_address()).call(&mut context);\n    //         let balance0Before = balance0 as u128;\n    //         assert(\n    //             (balance0Before + amount0 as u128) <= balance0 as u128,\n    //             \"IIA\",\n    //         );\n    //     } else {\n    //         if (amount0 as u128 < 0 as u128) {\n    //             let _ = Token::at(tokenA)\n    //                 .transfer_in_public(\n    //                     recipient,\n    //                     context.this_address(),\n    //                     (-amount0) as u128,\n    //                     nonce,\n    //                 )\n    //                 .call(&mut context);\n    //         }\n    //         let balance1 = Token::at(tokenB).get_balance_of_public(context.this_address()).call(&mut context);\n\n    //         let balance1Before = balance1;\n    //         assert(\n    //             (balance1Before as u128 + amount1 as u128)\n    //                 <= balance1 as u128,\n    //             \"IIA\",\n    //         );\n    //     }\n\n    //     pair_data.slot0.unlocked = true;\n    //     pool_storage.write(pair_data);\n\n    //     [amount0, amount1]\n    // }\n\n    // #[public]\n    // fn checkTickBitmap(\n    //     tokenA: AztecAddress,\n    //     tokenB: AztecAddress,\n    //     lte: bool,\n    //     tick: i32,\n    //     tickSpacing: i32,\n    // ) -> u32 {\n    //     let tickBitmap = storage\n    //         .tickBitmap\n    //         .at(tokenA)\n    //         .at(tokenB)\n    //         .at(lte)\n    //         .at(tick as Field)\n    //         .at(tickSpacing as Field)\n    //         .read();\n    //     tickBitmap.bitmap\n    // }\n\n    #[public]\n    fn set_rate(rate: Field, tokenA: AztecAddress, tokenB: AztecAddress, fee: u32) -> Field {\n        // @notice Set interest rate. That affects the dependence of AMM base price over time\n        // @param rate New rate in units of int(fraction * 1e18) per second\n        // @return rate_mul multiplier (e.g. 1.0 + integral(rate, dt))\n        assert(context.msg_sender() == storage.admin.read(), \"only admin\");\n        let mut pair =\n            FactoryV3::at(context.this_address()).getPool(tokenA, tokenB, fee).call(&mut context);\n        let rate_mul: U256 = pair._rate_mul(context.block_number());\n        pair.rate_mul = to_field(rate_mul);\n        pair.rate_time = context.block_number()as Field;\n        pair.rate = rate;\n        to_field(rate_mul)\n    }\n}\n"
    },
    "55": {
      "path": "/home/g/Documents/Projects/Cloak/fzuk/packages/factory/src/oracle.nr",
      "source": "use crate::fullMath::{MAX_U128, MAX_U160, mulDiv};\nuse crate::helpers::bitwise_shift_left;\nuse crate::pairV3::Pair;\nuse crate::tick::{Q128, Q192, Q64};\nuse crate::tickMath::getSqrtRatioAtTick;\nuse dep::aztec::{prelude::AztecAddress, protocol_types::traits::{Deserialize, Packable, Serialize}};\nuse dep::bignum::{BigNum, bignum::to_field, U256};\nuse std::meta::derive;\nuse dep::aztec::oracle::debug_log::{ debug_log, debug_log_format };\n\n// An observation is a slot that stores a recorded price. It stores a price, the timestamp when this price was recorded\n#[derive(Deserialize, Packable, Serialize)]\npub struct Observation {\n    // the block timestamp of the observation\n    blockTimestamp: u32, //uint32\n    // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized\n    tickCumulative: i64, //int56\n    // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized\n    secondsPerLiquidityCumulativeX128: Field, //uint160\n    // whether or not the observation is initialized\n    initialized: bool,\n}\n\nimpl Observation {\n    // @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values\n    // @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows\n    // @param last The specified observation to be transformed\n    // @param blockTimestamp The timestamp of the new observation\n    // @param tick The active tick at the time of the new observation\n    // @param liquidity The total in-range liquidity at the time of the new observation\n    // @return Observation The newly populated observation\n    fn transform(\n        &mut self,\n        last: &mut Observation,\n        blockTimestamp: u32, //uint32\n        tick: i32, //int24\n        liquidity: u128, //uint128\n    ) -> &mut Observation {\n        let delta = blockTimestamp - last.blockTimestamp;\n        let mut variable = 0 as u128;\n        if liquidity > 0 as u128 {\n            variable = liquidity;\n        } else {\n            variable = 1;\n        }\n\n        let observation = &mut Observation {\n            blockTimestamp: blockTimestamp,\n            tickCumulative: ((last.tickCumulative as i64) + (tick as i64) * (delta as i64)),\n            secondsPerLiquidityCumulativeX128: (\n                (last.secondsPerLiquidityCumulativeX128 as u128)\n                    + ((((2.pow_32(128 as Field)))*(128)) as u128 / variable)\n            ) as Field,\n            initialized: true,\n\n        };\n\n        observation\n    }\n\n    // @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array\n    // @param self The stored oracle array\n    // @param time The time of the oracle initialization, via block.timestamp truncated to uint32\n    // @return cardinality The number of populated elements in the oracle array\n    // @return cardinalityNext The new length of the oracle array, independent of population\n    fn initializeOracle(&mut self, time: u32) -> [u16; 2] {\n        self.blockTimestamp = time;\n        self.tickCumulative = 0;\n        self.secondsPerLiquidityCumulativeX128 = 0;\n        self.initialized = true;\n\n        [1, 1]\n    }\n\n    // @notice Writes an oracle observation to the array\n    // @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.\n    // If the index is at the end of the allowable array length (according to cardinality), and the next cardinality\n    // is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.\n    // @param self The stored oracle array\n    // @param index The index of the observation that was most recently written to the observations array\n    // @param blockTimestamp The timestamp of the new observation\n    // @param tick The active tick at the time of the new observation\n    // @param liquidity The total in-range liquidity at the time of the new observation\n    // @param cardinality The number of populated elements in the oracle array\n    // @param cardinalityNext The new length of the oracle array, independent of population\n    // @return indexUpdated The new index of the most recently written element in the oracle array\n    // @return cardinalityUpdated The new cardinality of the oracle array\n    fn write(\n        &mut self,\n        index: u16, // uint16\n        blockTimestamp: u32, // uint32\n        tick: i32, // int24\n        liquidity: u128, // uint128\n        cardinality: u16, // uint16\n        cardinalityNext: u16, // uint16\n    ) -> [u16; 2] {\n        let mut last = self;\n        let mut cardinalityUpdated = 0 as u16;\n        // early return if we've already written an observation this block\n        if (last.blockTimestamp == blockTimestamp) {\n            [index, cardinality]\n        } else {\n            // if the conditions are right, we can bump the cardinality\n            if ((cardinalityNext > cardinality) & (index == (cardinality - 1))) {\n                cardinalityUpdated = cardinalityNext;\n            } else {\n                cardinalityUpdated = cardinality;\n            }\n\n            let indexUpdated = (index + 1) % cardinalityUpdated;\n            self.transform(last, blockTimestamp, tick, liquidity);\n\n            [indexUpdated, cardinalityUpdated]\n        }\n    }\n\n    // @notice Prepares the oracle array to store up to `next` observations\n    // @param self The stored oracle array\n    // @param current The current next cardinality of the oracle array\n    // @param next The proposed next cardinality which will be populated in the oracle array\n    // @return next The next cardinality which will be populated in the oracle array\n    fn grow(\n        &mut self,\n        current: u16, // uint16\n        next: u16, // uint16\n    ) -> u16 {\n        assert(current > 0, \"I\");\n        // no-op if the passed next value isn't greater than the current next value\n        if (next <= current) {\n            current\n        } else {\n            // store in each slot to prevent fresh SSTOREs in swaps\n            // this data will not be used because the initialized boolean is still false\n            // for i in current .. next {\n            //     self[i].blockTimestamp = 1;\n            // }\n\n            next\n        }\n    }\n\n    // / @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\n    // / @dev Reverts if `secondsAgos` > oldest observation\n    // / @param self The stored oracle array\n    // / @param time The current block.timestamp\n    // / @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation\n    // / @param tick The current tick\n    // / @param index The index of the observation that was most recently written to the observations array\n    // / @param liquidity The current in-range pool liquidity\n    // / @param cardinality The number of populated elements in the oracle array\n    // / @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`\n    // / @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`\n    unconstrained fn observe(\n        &mut self,\n        observations: &mut [Observation; 256],\n        time: u32, // uint32\n        secondsAgos: [u32; 10000], // uint32\n        tick: i32, // int24\n        index: u16, // uint16\n        liquidity: u128, // uint128\n        cardinality: u16, // uint16\n    ) -> ([i64; 10000], [U256; 10000]) {\n        assert(cardinality > 0, \"I\");\n\n        let mut tickCumulatives: [i64; 10000] = [0; 10000];\n        let mut secondsPerLiquidityCumulativeX128s: [U256; 10000] = [U256::from(0); 10000];\n        for i in 0..secondsAgos.len() {\n            let (mut tc, mut sPl) = self.observeSingle(\n                observations,\n                time,\n                secondsAgos[i],\n                tick,\n                index,\n                liquidity,\n                cardinality,\n            );\n            tickCumulatives[i] = tc;\n            secondsPerLiquidityCumulativeX128s[i] = sPl;\n        }\n\n        (tickCumulatives, secondsPerLiquidityCumulativeX128s)\n    }\n\n    // @dev Reverts if an observation at or before the desired observation timestamp does not exist.\n    // If called with a timestamp falling between two observations, returns the counterfactual accumulator values\n    // at exactly the timestamp between the two observations.\n    // @param self The stored oracle array\n    // @param time The current block timestamp\n    // @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation\n    // @param tick The current tick\n    // @param index The index of the observation that was most recently written to the observations array\n    // @param liquidity The current in-range pool liquidity\n    // @param cardinality The number of populated elements in the oracle array\n    // @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`\n    // @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`\n    unconstrained fn observeSingle(\n        &mut self,\n        observations: &mut [Observation; 256],\n        time: u32, // uint32\n        secondsAgo: u32, // uint32\n        tick: i32, // int24\n        index: u16, // uint16\n        liquidity: u128, // uint128\n        cardinality: u16, // uint16\n    ) -> (i64, U256) {\n        if (secondsAgo == 0) {\n            let mut last = self;\n            if (last.blockTimestamp != time) {\n                last = self.transform(last, time, tick, liquidity);\n            }\n            (last.tickCumulative as i64, U256::from(last.secondsPerLiquidityCumulativeX128))\n        } else {\n            let mut target = time - secondsAgo;\n            let return_values = self.getSurroundingObservations(\n                observations,\n                time,\n                target,\n                tick,\n                index,\n                liquidity,\n                cardinality,\n            );\n            let beforeOrAt = return_values[0];\n            let atOrAfter = return_values[1];\n\n            if (target == beforeOrAt.blockTimestamp) {\n                // we're at the left boundary\n                (\n                    beforeOrAt.tickCumulative as i64,\n                    U256::from(beforeOrAt.secondsPerLiquidityCumulativeX128),\n                )\n            } else if (target == atOrAfter.blockTimestamp) {\n                // we're at the right boundary\n                (\n                    atOrAfter.tickCumulative as i64,\n                    U256::from(atOrAfter.secondsPerLiquidityCumulativeX128),\n                )\n            } else {\n                // we're in the middle\n                let observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;\n                let targetDelta = target - beforeOrAt.blockTimestamp;\n\n                (\n                    (\n                        beforeOrAt.tickCumulative\n                            + (\n                                (atOrAfter.tickCumulative - beforeOrAt.tickCumulative)\n                                    / (observationTimeDelta as i64)\n                            )\n                                * (targetDelta as i64)\n                    ) as i64,\n                    U256::from(\n                        (\n                            beforeOrAt.secondsPerLiquidityCumulativeX128\n                                + (\n                                    (\n                                        (\n                                            atOrAfter.secondsPerLiquidityCumulativeX128\n                                                - beforeOrAt.secondsPerLiquidityCumulativeX128\n                                        )\n                                            * targetDelta as Field\n                                    )\n                                        / observationTimeDelta as Field\n                                ) as Field\n                        ) as Field,\n                    ),\n                )\n            }\n        }\n    }\n\n    // @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied\n    // @dev Assumes there is at least 1 initialized observation.\n    // Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.\n    // @param self The stored oracle array\n    // @param time The current block.timestamp\n    // @param target The timestamp at which the reserved observation should be for\n    // @param tick The active tick at the time of the returned or simulated observation\n    // @param index The index of the observation that was most recently written to the observations array\n    // @param liquidity The total pool liquidity at the time of the call\n    // @param cardinality The number of populated elements in the oracle array\n    // @return beforeOrAt The observation which occurred at, or before, the given timestamp\n    // @return atOrAfter The observation which occurred at, or after, the given timestamp\n    unconstrained fn getSurroundingObservations(\n        &mut self,\n        observations: &mut [Observation; 256],\n        time: u32, // uint32\n        target: u32, // uint32\n        tick: i32, // int24\n        index: u16, // uint16\n        liquidity: u128, // uint128\n        cardinality: u16, // uint16\n    ) -> [&mut Observation; 2] {\n        // optimistically set before to the newest observation\n        let mut tempObs = observations[index as u32];\n        let mut beforeOrAt = &mut tempObs;\n        let mut atOrAfter = self;\n\n        // if the target is chronologically at or after the newest observation, we can early return\n        if (self.lte(time, beforeOrAt.blockTimestamp, target)) {\n            if (beforeOrAt.blockTimestamp == target) {\n                // if newest observation equals target, we're in the same block, so we can ignore atOrAfter\n                [beforeOrAt, atOrAfter]\n            } else {\n                // otherwise, we need to transform\n                [beforeOrAt, self.transform(beforeOrAt, target, tick, liquidity)]\n            }\n        } else {\n            let mut newObservations = observations;\n            // now, set before to the oldest observation\n            let mut tempObs = newObservations[((index + 1) % cardinality) as u32];\n            beforeOrAt = &mut tempObs;\n            if (!beforeOrAt.initialized) {\n                let mut tempObs = observations[0];\n                beforeOrAt = &mut tempObs;\n            }\n\n            // ensure that the target is chronologically at or after the oldest observation\n            assert(self.lte(time, beforeOrAt.blockTimestamp, target), \"OLD\");\n\n            let this = self;\n            // if we've reached this point, we have to binary search\n            self.binarySearch(observations, time, target, index, cardinality)\n        }\n    }\n\n    // @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.\n    // The result may be the same observation, or adjacent observations.\n    // @dev The answer must be contained in the array, used when the target is located within the stored observation\n    // boundaries: older than the most recent observation and younger, or the same age as, the oldest observation\n    // @param self The stored oracle array\n    // @param time The current block.timestamp\n    // @param target The timestamp at which the reserved observation should be for\n    // @param index The index of the observation that was most recently written to the observations array\n    // @param cardinality The number of populated elements in the oracle array\n    // @return beforeOrAt The observation recorded before, or at, the target\n    // @return atOrAfter The observation recorded at, or after, the target\n    unconstrained fn binarySearch(\n        &mut self,\n        observations:&mut [Observation; 256],\n        time: u32, // uint32\n        target: u32, // uint32\n        index: u16, // uint16\n        cardinality: u16, // uint16\n    ) -> [&mut Observation; 2] {\n        let mut l = (index + 1) % cardinality; // oldest observation\n        let mut r = l + cardinality - 1; // newest observation\n        let mut i = 0;\n\n        let mut beforeOrAt = self;\n        let mut atOrAfter = self;\n\n        for x in 0..256 {\n            i = (l + r) / 2;\n\n            let mut tempObs = observations[(i % cardinality) as u32];\n            beforeOrAt = &mut tempObs;\n\n            // we've landed on an uninitialized tick, keep searching higher (more recently)\n            if (!beforeOrAt.initialized) {\n                l = i + 1;\n                continue;\n            }\n\n            let mut tempObs = observations[((i + 1) % cardinality) as u32];\n            atOrAfter = &mut tempObs;\n            // atOrAfter = &mut observations[(i + 1) % cardinality];\n\n            let targetAtOrAfter = self.lte(time, beforeOrAt.blockTimestamp, target);\n\n            // check if we've found the answer!\n            if (targetAtOrAfter & self.lte(time, target, atOrAfter.blockTimestamp)) {\n                break;\n            }\n\n            if (!targetAtOrAfter) {\n                r = i - 1;\n            } else {\n                l = i + 1;\n            }\n        }\n        [beforeOrAt, atOrAfter]\n    }\n\n\n    fn lte(\n        &mut self,\n        time: u32, // uint32\n        a: u32, // uint32\n        b: u32, // uint32\n    ) -> bool {\n        // if there hasn't been overflow, no need to adjust\n        if (a <= time & b <= time) {\n            a <= b\n        } else {\n            let mut aAdjusted: Field = 0;\n\n            if a > time {\n                aAdjusted = a as Field;\n            } else {\n                aAdjusted = ((a as Field) + (2.pow_32(32)));\n            }\n\n            let mut bAdjusted: Field = 0;\n            if b > time {\n                bAdjusted = b as Field;\n            } else {\n                bAdjusted = ((b as Field) + (2.pow_32(32)));\n            }\n\n            aAdjusted as u32 <= bAdjusted as u32\n        }\n    }\n\n    /// @notice Calculates time-weighted means of tick and liquidity for a given pool\n    /// @param pool Address of the pool that we want to observe\n    /// @param secondsAgo Number of seconds in the past from which to calculate the time-weighted means\n    /// @return arithmeticMeanTick The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp\n    /// @return harmonicMeanLiquidity The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp\n    unconstrained fn consult(\n        &mut self,\n        currentTime: u32,\n        observations: &mut [Observation; 256],\n        pair: &mut Pair,\n        secondsAgo: u32,\n    ) -> (i32, u128) {\n        let mut pool = pair;\n        assert(secondsAgo != 0);\n\n        let mut secondsAgos: [u32; 10000] = [0; 10000];\n        secondsAgos[0] = secondsAgo;\n        let (tickCumulatives, secondsPerLiquidityCumX128s): ([i64; 10000], [U256; 10000]) =\n            pair.observe(observations, secondsAgos, currentTime);\n\n        let tickCumulativesDelta: i64 = tickCumulatives[1] - tickCumulatives[0];\n\n        let secondsPerLiquidityCumulativesDelta: U256 =\n            secondsPerLiquidityCumX128s[1] - secondsPerLiquidityCumX128s[0];\n\n        //  Compute arithmeticMeanTick (rounding down on negatives) ---\n        // Solidity: arithmeticMeanTick = int24(tickCumulativesDelta / secondsAgo);\n        // Then if negative and remainder != 0, decrement by 1 for floor division.\n        //\n        // Compute truncated division in i64\n        let mut arithmeticMeanTick: i32 = (tickCumulativesDelta as i64 / secondsAgo as i64) as i32;\n        //  Compute remainder\n        let rem: i64 = tickCumulativesDelta % secondsAgo as i64;\n\n        if ((tickCumulativesDelta < 0) & (rem != 0)) {\n            arithmeticMeanTick = arithmeticMeanTick - 1;\n        }\n\n        // We are multiplying here instead of shifting to ensure that harmonicMeanLiquidity doesn't overflow uint128\n        let secondsAgoX160 = U256::from(secondsAgo as Field) * U256::from(MAX_U160);\n        let harmonicMeanLiquidity = (\n            to_field(secondsAgoX160.udiv(bitwise_shift_left(\n                secondsPerLiquidityCumulativesDelta,\n                32 as u128,\n            )))\n        ) as u128;\n\n        (arithmeticMeanTick, harmonicMeanLiquidity)\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    fn getQuoteAtTick(\n        tick: i32,\n        base_amount: u128,\n        baseToken: AztecAddress,\n        quoteToken: AztecAddress,\n    ) -> Field {\n        let sqrtPriceX96: Field = getSqrtRatioAtTick(tick);\n        if U256::from(sqrtPriceX96) <= U256::from(MAX_U128 as Field) {\n            let ratio_x192: Field = sqrtPriceX96 * sqrtPriceX96;\n            mulDiv(ratio_x192, base_amount as Field, Q192)\n        } else {\n            let ratio_x128: Field = mulDiv(sqrtPriceX96, sqrtPriceX96, Q64 as Field);\n            mulDiv(ratio_x128, base_amount as Field, Q128)\n        }\n    }\n}\n"
    },
    "56": {
      "path": "/home/g/Documents/Projects/Cloak/fzuk/packages/factory/src/pairV3.nr",
      "source": "use crate::fullMath::MAX_U128;\nuse crate::fullMath::mulDiv;\nuse crate::liquidityMath::addDelta;\nuse crate::oracle::Observation;\nuse crate::position::Position;\nuse crate::sqrtPriceMath::{getAmount0Delta, getAmount1Delta};\nuse crate::stepComputations::StepComputations;\nuse crate::swapCache::SwapCache;\nuse crate::swapMath::computeSwapStep;\nuse crate::swapState::SwapState;\nuse crate::tick::{Q128, Tick};\nuse crate::tickBitmap::TickBitMap;\nuse crate::tickMath::{\n    getSqrtRatioAtTick, getTickAtSqrtRatio, MAX_SQRT_RATIO, MAX_TICK, MIN_SQRT_RATIO, MIN_TICK,\n};\nuse dep::aztec::{\n    prelude::AztecAddress,\n    protocol_types::traits::{Deserialize, Packable, Serialize, ToField},\n};\nuse dep::bignum::{BigNum, bignum::to_field, U256};\n\n//  pool by default can store only 1 observation, which gets overwritten each time a new price is recorded\n#[derive(Deserialize, Packable, Serialize)]\npub struct Slot0 {\n    // the current price\n    sqrtPriceX96: Field, // uint160\n    // the current tick\n    tick: i32, // int24\n    // the most-recently updated index of the observations array\n    observationIndex: u16, // uint16\n    // the current maximum number of observations that are being stored\n    observationCardinality: u16, // uint16\n    // the next maximum number of observations to store, triggered in observations.write\n    observationCardinalityNext: u16, // uint16\n    // the current protocol fee as a percentage of the swap fee taken on withdrawal\n    // represented as an integer denominator (1/x)%\n    // The size of protocol fees is expected to be determined by voters, but it must be between 1/4 and 1/10 (inclusive) of swap fees.\n    feeProtocol: u8, // uint8\n    // whether the pool is locked\n    unlocked: bool,\n}\n\n// accumulated protocol fees in token0/token1 units\n#[derive(Deserialize, Packable, Serialize)]\npub struct ProtocolFees {\n    token0: u128,\n    token1: u128,\n}\n\n#[derive(Deserialize, Packable, Serialize)]\npub struct Pair {\n    //  Collateral - tokenA -> y -> any coin\n    token0: AztecAddress,\n    //  Borrow - tokenB -> x -> typically stablecoin\n    token1: AztecAddress,\n    fee: u32,\n    tickSpacing: i32,\n    maxLiquidityPerTick: u128,\n    feeGrowthGlobal0X128: Field, // Tracks fees accumulated in token0\n    feeGrowthGlobal1X128: Field,\n    slot0: Slot0,\n    liquidity: u128,\n    protocolFees: ProtocolFees,\n    initiated: bool,\n    // Lending\n    // Factory -> Pair -> Policy -> DebtCandle -> PegKeeper -> Regulator -> Aggregator\n    // admin_fee: u32,\n    // base_price: Field,\n    // active_band: Field,\n    // max_oracle_dn_poq: Field, // # (A / (A - 1)) ** 50\n    // sqrt_band_ratio: Field, // sqrt(A / (A - 1)) - needs to be pre-calculated externally\n    // log_A_ratio: Field, //  log(A / (A - 1)) - needs to be pre-calculated externally\n    // A: Field,\n    // Aminus1: Field,\n    // A2: Field,\n    // Aminus12: Field,\n    rate: Field,\n    rate_mul: Field,\n    // time: u32,\n    rate_time: Field,\n    // loan_discount: Field, // Discount of the maximum loan size compare to get_x_down() value. This value defines the LTV.\n    // n_collaterals: Field,\n    // collateral_precision: u32, // Precision of collateral: we pass it because we want the blueprint to fit into bytecode\n    // borrowed_precision: u32,\n    // liquidation_discount: u32,\n}\n\nimpl Pair {\n    pub fn __init__(\n        &mut self,\n        tickSpacing: Field, // uint256\n        fee: Field, // uint256\n        collateral_token: AztecAddress, // Collateral\n        borrowed_token: AztecAddress, // borrowed_token\n    ) {\n        self.maxLiquidityPerTick = self.tickSpacingToMaxLiquidityPerTick(tickSpacing as i32);\n        self.token0 = collateral_token;\n        self.token1 = borrowed_token;\n        self.fee = fee as u32;\n        self.tickSpacing = tickSpacing as i32;\n    }\n\n    /// @notice Derives max liquidity per tick from given tick spacing\n    /// @dev Executed within the pool constructor\n    /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`\n    ///   e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...\n    /// @return The max liquidity per tick\n    pub fn tickSpacingToMaxLiquidityPerTick(&mut self, tickSpacing: i32) -> u128 {\n        let minTick = (MIN_TICK / tickSpacing) * tickSpacing;\n        let minTick = (MIN_TICK / tickSpacing) * tickSpacing;\n        let maxTick = (MAX_TICK / tickSpacing) * tickSpacing;\n        let numTicks = ((maxTick - minTick) / tickSpacing) + 1;\n\n        MAX_U128 / (numTicks as Field) as u128\n    }\n    /// @dev Common checks for valid tick inputs.\n    pub fn checkTicks(&mut self, tickLower: i32, tickUpper: i32) {\n        assert(tickLower < tickUpper, \"TLU\");\n        assert(tickLower >= MIN_TICK, \"TLM\");\n        assert(tickUpper <= MAX_TICK, \"TUM\");\n        // added the following to make sure no bad ticks are givved like 1234 and 1235 for tickSpacing 10\n        assert(tickLower % self.tickSpacing == 0 , \"TMS1\");\n        assert(tickUpper %  self.tickSpacing == 0, \"TMS2\");\n    }\n\n    /// @inheritdoc IUniswapV3PoolActions\n    /// @dev not locked because it initializes unlocked\n    /// Initialize the oracle array\n    fn initialize(\n        &mut self,\n        observation: &mut Observation,\n        blockTimestamp: u32,\n        sqrtPriceX96: Field, // uint160\n        tick: i32,\n    ) {\n        assert(self.slot0.sqrtPriceX96 == 0, \"AI\");\n\n        let return_values = observation.initializeOracle(blockTimestamp);\n        let cardinality = return_values[0];\n        let cardinalityNext = return_values[1];\n\n        self.slot0 = Slot0 {\n            sqrtPriceX96,\n            tick,\n            observationIndex: 0,\n            observationCardinality: cardinality,\n            observationCardinalityNext: cardinalityNext,\n            feeProtocol: 0,\n            unlocked: true,\n        };\n        self.initiated = true;\n    }\n\n    /// @inheritdoc IUniswapV3PoolDerivedState\n    unconstrained fn snapshotCumulativesInside(\n        &mut self,\n        observations: &mut [Observation; 256],\n        time: u32,\n        tickLower: Tick,\n        tickUpper: Tick,\n    ) -> [Field; 3] {\n        self.checkTicks(tickLower.value as i32, tickUpper.value as i32);\n\n        let tickCumulativeLower = 0 as i64; // int56\n        let tickCumulativeUpper = 0 as i64; // int56\n        let secondsPerLiquidityOutsideLowerX128 = 0; // uint160\n        let secondsPerLiquidityOutsideUpperX128 = 0; // uint160\n        let secondsOutsideLower = 0 as u32; // uint32\n        let secondsOutsideUpper = 0 as u32; // uint32\n        let initializedLower = false;\n        let tickCumulativeLower = tickLower.tickCumulativeOutside;\n        let secondsPerLiquidityOutsideLowerX128 = tickLower.secondsPerLiquidityOutsideX128;\n        let secondsOutsideLower = tickLower.secondsOutside;\n        let initializedLower = tickLower.initialized;\n        assert(initializedLower);\n\n        let initializedUpper = false;\n        let tickCumulativeUpper = tickUpper.tickCumulativeOutside;\n        let secondsPerLiquidityOutsideUpperX128 = tickUpper.secondsPerLiquidityOutsideX128;\n        let secondsOutsideUpper = tickUpper.secondsOutside;\n        let initializedUpper = tickUpper.initialized;\n        assert(initializedUpper);\n\n        let _slot0 = self.slot0;\n\n        if (_slot0.tick < tickLower.value as i32) {\n            [\n                (tickCumulativeLower - tickCumulativeUpper) as Field,\n                (secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128)\n                     as Field,\n                    (secondsOutsideLower - secondsOutsideUpper) as Field,\n                ]\n            } else if (_slot0.tick < tickUpper.value as i32) {\n                let mut observation = observations[(_slot0.observationIndex) as u32];\n                let (tc, sPl) = observation.observeSingle(\n                    observations,\n                    time,\n                    0,\n                    _slot0.tick,\n                    _slot0.observationIndex,\n                    self.liquidity,\n                    _slot0.observationCardinality,\n                );\n                let tickCumulative = tc;\n                let secondsPerLiquidityCumulativeX128 = sPl;\n                [\n                    (tickCumulative - tickCumulativeLower - tickCumulativeUpper) as Field,\n                    (\n                        to_field(secondsPerLiquidityCumulativeX128)\n                            - secondsPerLiquidityOutsideLowerX128\n                            - secondsPerLiquidityOutsideUpperX128\n                    ),\n                    (time - secondsOutsideLower - secondsOutsideUpper) as Field,\n                ]\n            } else {\n                [\n                    (tickCumulativeUpper - tickCumulativeLower) as Field,\n                    (secondsPerLiquidityOutsideUpperX128 - secondsPerLiquidityOutsideLowerX128),\n                    (secondsOutsideUpper - secondsOutsideLower) as Field,\n                ]\n            }\n        }\n\n    /// @inheritdoc IUniswapV3PoolDerivedState\n    unconstrained fn observe(\n        &mut self,\n        observations: &mut [Observation; 256],\n        secondsAgos: [u32; 10000],\n        time: u32,\n    ) -> ([i64; 10000], [U256; 10000]) {\n        let mut observation = observations[(self.slot0.observationIndex) as u32];\n        observation.observe(\n            observations,\n            time,\n            secondsAgos,\n            self.slot0.tick,\n            self.slot0.observationIndex,\n            self.liquidity,\n            self.slot0.observationCardinality,\n        )\n    }\n\n    /// @inheritdoc IUniswapV3PoolActions\n    fn increaseObservationCardinalityNext(\n        &mut self,\n        observations: [&mut Observation; 256],\n        observationCardinalityNext: u16,\n    ) {\n        let mut observation = observations[(self.slot0.observationIndex) as u32];\n        let observationCardinalityNextOld = self.slot0.observationCardinalityNext; // for the event\n        let observationCardinalityNextNew =\n            observation.grow(observationCardinalityNextOld, observationCardinalityNext);\n        self.slot0.observationCardinalityNext = observationCardinalityNextNew;\n    }\n\n    /// @dev Effect some changes to a position\n    /// @param params the position details and the change to the position's liquidity to effect\n    /// @return position a storage pointer referencing the position with the given owner and tick range\n    /// @return amount0 the amount of token0 owed to the pool, negative if the pool should pay the recipient\n    /// @return amount1 the amount of token1 owed to the pool, negative if the pool should pay the recipient\n    unconstrained fn _modifyPosition(\n        &mut self,\n        tickLowerBitMap: &mut TickBitMap,\n        tickUpperBitMap: &mut TickBitMap,\n        observations: &mut [Observation; 256],\n        position: &mut Position,\n        time: u32,\n        tickLower: &mut Tick,\n        tickUpper: &mut Tick,\n        liquidityDelta: Field,\n        isNegDelta: bool,\n        tickSpacing: i32,\n        currentTick: &mut Tick,\n        getSqrtRatioAtTickUpper: Field,\n        getSqrtRatioAtTickLower: Field,\n    ) -> (Field, Field, &mut Position, &mut Tick, &mut Tick, &mut Tick) {\n        let mut amount0 = 0;\n        let mut amount1 = 0;\n\n        let mut _slot0 = self.slot0;\n        let mut _slot0 = self.slot0;\n        let (updatedPosition, updatedTickLower, updatedTickUpper, updatedCurrentTick): (&mut Position, &mut Tick, &mut Tick, &mut Tick) = self\n            ._updatePosition(\n                tickLowerBitMap,\n                tickUpperBitMap,\n                observations,\n                position,\n                time,\n                tickLower,\n                tickUpper,\n                liquidityDelta as u128,\n                isNegDelta,\n                currentTick,\n                tickSpacing,\n            );\n\n        if ((liquidityDelta) as u128 != 0 as u128) {\n            if (_slot0.tick as i32 < tickLower.value) {\n                // current tick is below the passed range; liquidity can only become in range by crossing from left to\n                // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it\n                // Delta x\n                amount0 = getAmount0Delta(\n                    getSqrtRatioAtTickUpper,\n                    getSqrtRatioAtTickLower,\n                    liquidityDelta,\n                    true,\n                );\n            } else if (_slot0.tick as i32 < tickUpper.value) {\n                let mut observation = observations[(self.slot0.observationIndex) as u32];\n\n                // current tick is inside the passed range\n                let mut liquidityBefore = self.liquidity; // SLOAD for gas optimization\n                // write an oracle entry\n                let return_values = observation.write(\n                    _slot0.observationIndex,\n                    time,\n                    _slot0.tick,\n                    liquidityBefore,\n                    _slot0.observationCardinality,\n                    _slot0.observationCardinalityNext,\n                );\n                self.slot0.observationIndex = return_values[0];\n                self.slot0.observationCardinality = return_values[1];\n\n                // Delta x\n                amount0 = getAmount0Delta(\n                    _slot0.sqrtPriceX96,\n                    getSqrtRatioAtTickLower,\n                    liquidityDelta,\n                    false,\n                );\n                // Delta y\n                amount1 = getAmount1Delta(\n                    getSqrtRatioAtTickUpper,\n                    _slot0.sqrtPriceX96,\n                    liquidityDelta,\n                    false,\n                );\n                self.liquidity = addDelta(liquidityBefore, liquidityDelta as u128, isNegDelta);\n            } else {\n                // current tick is above the passed range; liquidity can only become in range by crossing from right to\n                // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it\n                amount1 = getAmount1Delta(\n                    getSqrtRatioAtTickLower,\n                    getSqrtRatioAtTickUpper,\n                    liquidityDelta,\n                    false,\n                );\n\n            }\n        }\n        (amount0, amount1, updatedPosition, updatedTickLower, updatedTickUpper, updatedCurrentTick)\n    }\n\n    /// @dev Gets and updates a position with the given liquidity delta\n    /// @param owner the owner of the position\n    /// @param tickLower the lower tick of the position's tick range\n    /// @param tickUpper the upper tick of the position's tick range\n    /// @param tick the current tick, passed to avoid sloads\n    unconstrained fn _updatePosition(\n        &mut self,\n        tickLowerBitmap: &mut TickBitMap,\n        tickUpperBitmap: &mut TickBitMap,\n        observations: &mut [Observation; 256],\n        position: &mut Position,\n        time: u32,\n        tickLower: &mut Tick, // int24\n        tickUpper: &mut Tick, // int24\n        liquidityDelta: u128, // int128\n        isNegDelta: bool, // since we can not store int128 we need this\n        currentTick: &mut Tick,\n        tickSpacing: i32,\n    ) -> (&mut Position, &mut Tick, &mut Tick, &mut Tick) {\n        let _feeGrowthGlobal0X128 = self.feeGrowthGlobal0X128; // SLOAD for gas optimization\n        let _feeGrowthGlobal1X128 = self.feeGrowthGlobal1X128; // SLOAD for gas optimization\n        // if we need to update the ticks, do it\n        let flippedLower = false;\n        let flippedUpper = false;\n        let mut observation = observations[(self.slot0.observationIndex) as u32];\n        if ((liquidityDelta) as u128 != 0 as u128) {\n            let (tc, sPl) = observation.observeSingle(\n                observations,\n                time,\n                0,\n                self.slot0.tick,\n                self.slot0.observationIndex,\n                self.liquidity,\n                self.slot0.observationCardinality,\n            );\n\n            let tickCumulative = tc;\n            let secondsPerLiquidityCumulativeX128 = sPl;\n\n            let flippedLower = currentTick.update(\n                self.slot0.tick as i32,\n                liquidityDelta,\n                isNegDelta,\n                _feeGrowthGlobal0X128,\n                _feeGrowthGlobal1X128,\n                to_field(secondsPerLiquidityCumulativeX128),\n                tickCumulative,\n                time,\n                false,\n                self.maxLiquidityPerTick,\n            );\n            let flippedUpper = currentTick.update(\n                self.slot0.tick as i32,\n                liquidityDelta,\n                isNegDelta,\n                _feeGrowthGlobal0X128,\n                _feeGrowthGlobal1X128,\n                to_field(secondsPerLiquidityCumulativeX128),\n                tickCumulative,\n                time,\n                true,\n                self.maxLiquidityPerTick,\n            );\n            if (flippedLower) {\n                tickLowerBitmap.flipTick(tickLower.value, tickSpacing);\n                // TODO update bitmap\n            }\n            if (flippedUpper) {\n                tickUpperBitmap.flipTick(tickUpper.value, tickSpacing);\n                // TODO update bitmap\n            }\n        }\n        let return_values = currentTick.getFeeGrowthInside(\n            tickLower,\n            tickUpper,\n            _feeGrowthGlobal0X128,\n            _feeGrowthGlobal1X128,\n        );\n        let feeGrowthInside0X128 = return_values[0];\n        let feeGrowthInside1X128 = return_values[1];\n\n        position.update(liquidityDelta, isNegDelta, feeGrowthInside0X128, feeGrowthInside1X128);\n\n        // clear any tick data that is no longer needed\n        if (isNegDelta) {\n            if (flippedLower) {\n                currentTick.clear();\n            }\n            if (flippedUpper) {\n                currentTick.clear();\n            }\n        }\n\n        (position, tickLower, tickUpper, currentTick)\n    }\n\n    // @inheritdoc IUniswapV3PoolActions\n    // @dev noDelegateCall is applied indirectly via _modifyPosition\n    pub(crate) unconstrained fn mint(\n        &mut self,\n        tickLowerBitmap: &mut TickBitMap,\n        tickUpperBitmap: &mut TickBitMap,\n        observations: &mut [Observation; 256],\n        position: &mut Position,\n        time: u32,\n        tickLower: &mut Tick,\n        tickUpper: &mut Tick,\n        amount: Field,\n        tickSpacing: i32,\n        currentTick: &mut Tick,\n        balance0Before: Field,\n        balance1Before: Field,\n        getSqrtRatioAtTickUpper: Field,\n        getSqrtRatioAtTickLower: Field,\n    ) -> (Field, Field, &mut Position, &mut Tick, &mut Tick, &mut Tick) {\n        assert((amount) as u128 > 0 as u128);\n        let (amount0, amount1, updatedPosition, updatedTickLower, updatedTickUpper, updatedCurrentTick) = self\n            ._modifyPosition(\n                tickLowerBitmap,\n                tickUpperBitmap,\n                observations,\n                position,\n                time,\n                tickLower,\n                tickUpper,\n                amount,\n                false,\n                tickSpacing,\n                currentTick,\n                getSqrtRatioAtTickUpper,\n                getSqrtRatioAtTickLower,\n            );\n\n\n        (amount0, amount1, updatedPosition, updatedTickLower, updatedTickUpper, updatedCurrentTick)\n    }\n\n    /// @inheritdoc IUniswapV3PoolDerivedState\n    unconstrained fn swap(\n        &mut self,\n        tickBitMap: &mut TickBitMap,\n        observations: &mut [Observation; 256],\n        zeroForOne: bool, // bool\n        amountSpecified: Field, // int256\n        isNegDelta: bool,\n        sqrtPriceLimitX96: Field, // uint160,\n        time: u32,\n        tickSpacing: i32,\n        tick: Tick,\n    ) -> [Field; 2] {\n        assert(amountSpecified != 0, \"AS\");\n\n        let slot0Start = self.slot0;\n        let mut observation = observations[(self.slot0.observationIndex) as u32];\n\n        assert(slot0Start.unlocked, \"LOK\");\n        if (zeroForOne) {\n            assert(\n                sqrtPriceLimitX96 as u128 < slot0Start.sqrtPriceX96 as u128\n                    & sqrtPriceLimitX96 as u128 > MIN_SQRT_RATIO as u128,\n                \"SPL\",\n            );\n        } else {\n            assert(\n                sqrtPriceLimitX96 as u128 > slot0Start.sqrtPriceX96 as u128\n                    & sqrtPriceLimitX96 as u128 < MIN_SQRT_RATIO as u128,\n                \"SPL\",\n            );\n        }\n        self.slot0.unlocked = false;\n\n        let mut feeProtocol = 0;\n        if (zeroForOne) {\n            feeProtocol = slot0Start.feeProtocol % 16;\n        } else {\n            feeProtocol = (slot0Start.feeProtocol >> 4);\n        }\n        let mut cache = SwapCache {\n            liquidityStart: self.liquidity,\n            blockTimestamp: time,\n            feeProtocol,\n            secondsPerLiquidityCumulativeX128: 0,\n            tickCumulative: 0,\n            computedLatestObservation: false,\n        };\n\n        let mut exactInput = amountSpecified as u128 > 0 as u128;\n\n        let mut feeGrowthGlobalX128 = 0;\n        if (zeroForOne) {\n            feeGrowthGlobalX128 = self.feeGrowthGlobal0X128;\n        } else {\n            feeGrowthGlobalX128 = self.feeGrowthGlobal1X128;\n        }\n\n        let mut state = SwapState {\n            amountSpecifiedRemaining: amountSpecified,\n            amountCalculated: 0,\n            sqrtPriceX96: slot0Start.sqrtPriceX96,\n            tick: slot0Start.tick,\n            feeGrowthGlobalX128,\n            protocolFee: 0 as u128,\n            liquidity: cache.liquidityStart,\n        };\n\n        // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit\n        let mut counter = 0;\n        for i in 0..counter {\n            let mut step = StepComputations {\n                sqrtPriceStartX96: 0,\n                tickNext: 0,\n                initialized: false,\n                sqrtPriceNextX96: 0,\n                amountIn: 0,\n                amountOut: 0,\n                feeAmount: 0,\n            };\n\n            if ((state.amountSpecifiedRemaining != 0) & (state.sqrtPriceX96 != sqrtPriceLimitX96)) {\n                counter = counter + 1;\n\n                step.sqrtPriceStartX96 = state.sqrtPriceX96;\n\n                let (next , initialized ) = tickBitMap.nextInitializedTickWithinOneWord(\n                    state.tick,\n                    tickSpacing,\n                    zeroForOne,\n                );\n\n                step.tickNext = next as i32;\n                step.initialized = initialized;\n\n                // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds\n                if (step.tickNext as u128 < MIN_TICK as u128) {\n                    step.tickNext = MIN_TICK as i32;\n                } else if (step.tickNext as u128 > MAX_TICK as u128) {\n                    step.tickNext = MAX_TICK as i32;\n                }\n                // get the price for the next tick\n                step.sqrtPriceNextX96 = getSqrtRatioAtTick(step.tickNext);\n\n                // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted\n                let mut inLimit = false;\n                if (zeroForOne) {\n                    inLimit = step.sqrtPriceNextX96 as u128 < sqrtPriceLimitX96 as u128;\n                } else {\n                    inLimit = step.sqrtPriceNextX96 as u128 > sqrtPriceLimitX96 as u128;\n                }\n                let mut sqrtRatioTargetX96 = 0;\n                if (inLimit) {\n                    sqrtRatioTargetX96 = sqrtPriceLimitX96;\n                } else {\n                    sqrtRatioTargetX96 = step.sqrtPriceNextX96;\n                }\n                let result: [Field; 4] = computeSwapStep(\n                    state.sqrtPriceX96,\n                    sqrtRatioTargetX96,\n                    state.liquidity,\n                    state.amountSpecifiedRemaining,\n                    self.fee,\n                );\n                state.sqrtPriceX96 = result[0];\n                step.amountIn = result[1];\n                step.amountOut = result[2];\n                step.feeAmount = result[3];\n                if (exactInput) {\n                    state.amountSpecifiedRemaining =\n                        state.amountSpecifiedRemaining - (step.amountIn + step.feeAmount) as Field;\n                    state.amountCalculated = state.amountCalculated - step.amountOut as Field;\n                } else {\n                    state.amountSpecifiedRemaining =\n                        state.amountSpecifiedRemaining + step.amountOut as Field;\n                    state.amountCalculated =\n                        state.amountCalculated + (step.amountIn + step.feeAmount) as Field;\n                }\n                // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee\n                if (cache.feeProtocol as u128 > 0 as u128) {\n                    let mut delta = step.feeAmount / cache.feeProtocol as Field;\n                    step.feeAmount = step.feeAmount - delta;\n                    state.protocolFee = state.protocolFee + delta as u128;\n                }\n                // update global fee tracker\n                if (state.liquidity > 0 as u128) {\n                    state.feeGrowthGlobalX128 = state.feeGrowthGlobalX128\n                        + mulDiv(step.feeAmount, Q128 as Field, state.liquidity as Field);\n                }\n                // shift tick if we reached the next price\n                if (state.sqrtPriceX96 as u128 == step.sqrtPriceNextX96 as u128) {\n                    // if the tick is initialized, run the tick transition\n                    if (step.initialized) {\n                        // check for the placeholder value, which we replace with the actual value the first time the swap\n                        // crosses an initialized tick\n                        if (!cache.computedLatestObservation) {\n                            let (tc, sPl) = observation.observeSingle(\n                                observations,\n                                cache.blockTimestamp,\n                                0,\n                                slot0Start.tick,\n                                slot0Start.observationIndex,\n                                cache.liquidityStart,\n                                slot0Start.observationCardinality,\n                            );\n\n                            cache.tickCumulative = tc;\n                            cache.secondsPerLiquidityCumulativeX128 = to_field(sPl);\n\n                            cache.computedLatestObservation = true;\n                        }\n                        let mut growth1 = 0;\n                        let mut growth2 = 0;\n                        if (zeroForOne) {\n                            growth1 = state.feeGrowthGlobalX128;\n                        } else {\n                            growth1 = self.feeGrowthGlobal0X128;\n                        }\n\n                        if (zeroForOne) {\n                            growth2 = self.feeGrowthGlobal1X128;\n                        } else {\n                            growth2 = state.feeGrowthGlobalX128;\n                        }\n\n                        let mut theTick = tick;\n                        let mut tickNext = theTick.update(\n                            step.tickNext, // tickCurrent The current tick\n                            amountSpecified as u128, //  liquidityDelta: int256(amount).toInt128()\n                            isNegDelta,\n                            self.feeGrowthGlobal0X128,\n                            self.feeGrowthGlobal1X128,\n                            cache.secondsPerLiquidityCumulativeX128,\n                            cache.tickCumulative,\n                            time,\n                            false,\n                            self.maxLiquidityPerTick,\n                        );\n\n                        let mut tickNext = theTick; //after update\n                        let mut liquidityNet = theTick.cross(\n                            &mut tickNext,\n                            growth1,\n                            growth2,\n                            cache.secondsPerLiquidityCumulativeX128,\n                            cache.tickCumulative,\n                            cache.blockTimestamp,\n                        );\n                        // if we're moving leftward, we interpret liquidityNet as the opposite sign\n                        // safe because liquidityNet cannot be type(int128).min\n                        if (zeroForOne) {\n                            liquidityNet = (-(liquidityNet as Field)) as u128;\n                        };\n                        state.liquidity = addDelta(state.liquidity, liquidityNet, isNegDelta);\n                    }\n\n                    if (zeroForOne) {\n                        state.tick = step.tickNext - 1;\n                    } else {\n                        state.tick = step.tickNext;\n                    }\n                } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {\n                    // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n                    state.tick = getTickAtSqrtRatio(state.sqrtPriceX96);\n                }\n            }\n        }\n        // update tick and write an oracle entry if the tick change\n        if (state.tick != slot0Start.tick) {\n            let return_values = observation.write(\n                slot0Start.observationIndex,\n                cache.blockTimestamp,\n                slot0Start.tick,\n                cache.liquidityStart,\n                slot0Start.observationCardinality,\n                slot0Start.observationCardinalityNext,\n            );\n\n            let observationIndex = return_values[0];\n            let observationCardinality = return_values[1];\n\n            self.slot0.sqrtPriceX96 = state.sqrtPriceX96;\n            self.slot0.tick = state.tick;\n            self.slot0.observationIndex = observationIndex;\n            self.slot0.observationCardinality = observationCardinality;\n        } else {\n            // otherwise just update the price\n            self.slot0.sqrtPriceX96 = state.sqrtPriceX96;\n        }\n        // update liquidity if it changed\n        if (cache.liquidityStart != state.liquidity) {\n            self.liquidity = state.liquidity;\n        }\n        // update fee growth global and, if necessary, protocol fees\n        // overflow is acceptable, protocol has to withdraw before it hits type(uint128).max fees\n        if (zeroForOne) {\n            self.feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;\n            if (state.protocolFee > 0 as u128) {\n                self.protocolFees.token0 += state.protocolFee;\n            }\n        } else {\n            self.feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;\n            if (state.protocolFee > 0 as u128) {\n                self.protocolFees.token1 += state.protocolFee;\n            }\n        }\n\n        let mut amount0 = 0;\n        let mut amount1 = 0;\n        if (zeroForOne == exactInput) {\n            amount0 = amountSpecified - state.amountSpecifiedRemaining;\n            amount1 = state.amountCalculated;\n        } else {\n            amount0 = state.amountCalculated;\n            amount1 = amountSpecified - state.amountSpecifiedRemaining;\n        }\n\n        [amount0, amount1]\n    }\n\n    /// @inheritdoc IUniswapV3PoolActions\n    /// @dev noDelegateCall is applied indirectly via _modifyPosition\n    unconstrained fn burn(\n        &mut self,\n        tickLower: &mut Tick, // int24\n        tickUpper: &mut Tick, // int24\n        amount: Field, // uint128\n        tickLowerBitmap: &mut TickBitMap,\n        tickUpperBitmap: &mut TickBitMap,\n        observations: &mut [Observation; 256],\n        position: &mut Position,\n        time: u32,\n        recipient: AztecAddress,\n        tickSpacing: i32,\n        tick: &mut Tick,\n        getSqrtRatioAtTickUpper: Field,\n        getSqrtRatioAtTickLower: Field,\n    ) -> (Field, Field, &mut Position, &mut Tick, &mut Tick, &mut Tick) {\n        let (amount0, amount1, updatedPosition, updatedTickLower, updatedTickUpper, updatedCurrentTick) = self\n            ._modifyPosition(\n                tickLowerBitmap,\n                tickUpperBitmap,\n                observations,\n                position,\n                time,\n                tickLower,\n                tickUpper,\n                amount,\n                true,\n                tickSpacing,\n                tick,\n                getSqrtRatioAtTickUpper,\n                getSqrtRatioAtTickLower,\n            );\n\n        if (amount0 as u128 > 0 as u128 | amount1 as u128 > 0 as u128) {\n            position.tokensOwed0 = position.tokensOwed0 + amount0 as u128;\n            position.tokensOwed1 = position.tokensOwed1 + amount1 as u128;\n        }\n\n        (amount0, amount1, updatedPosition, updatedTickLower, updatedTickUpper, updatedCurrentTick)\n    }\n\n    //     // // *****************************LENDING **********************************\n    pub fn set_rate(&mut self, rate: Field, currentTime: u32) -> Field {\n        // \"\"\"\n        // @notice Set interest rate. That affects the dependence of AMM base price over time\n        // @param rate New rate in units of int(fraction * 1e18) per second\n        // @return rate_mul multiplier (e.g. 1.0 + integral(rate, dt))\n        // \"\"\"\n        let rate_mul = self._rate_mul(currentTime);\n        self.rate_mul = to_field(rate_mul);\n        self.rate_time = currentTime as Field;\n        self.rate = rate;\n\n        to_field(rate_mul)\n    }\n\n    pub fn get_rate_mul(&mut self, currentTime: u32) -> U256 {\n        // \"\"\"\n        // @notice Rate multiplier which is 1.0 + integral(rate, dt)\n        // @return Rate multiplier in units where 1.0 == 1e18\n        // \"\"\"\n        self._rate_mul(currentTime)\n    }\n\n    pub fn _rate_mul(&mut self, currentTime: u32) -> U256 {\n        // \"\"\"\n        // @notice Rate multiplier which is 1.0 + integral(rate, dt)\n        // @return Rate multiplier in units where 1.0 == 1e18\n        // \"\"\"\n        U256::from(self.rate_mul)\n            * (\n                U256::from(1000000000000000000)\n                    + U256::from(self.rate)\n                        * (U256::from(currentTime as Field) - U256::from(self.rate_time))\n            )\n                .udiv(U256::from(1000000000000000000))\n    }\n}\n"
    },
    "57": {
      "path": "/home/g/Documents/Projects/Cloak/fzuk/packages/factory/src/position.nr",
      "source": "use dep::aztec::{prelude::AztecAddress, protocol_types::traits::{Deserialize, Packable, Serialize}};\nuse std::meta::derive;\n\nuse crate::liquidityMath::{addDelta};\nuse crate::fullMath::{mulDivRoundingUp, mulDiv};\nuse crate::tick::{Q128};\n\n#[derive(Deserialize, Packable, Serialize)]\npub struct Position {\n        // the amount of liquidity owned by this position\n        liquidity: u128, // uint128\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed\n        // total accumulated fees per unit of liquidity (that is, fee amount divided by the pool liquidity).\n        feeGrowthInside0LastX128: Field, // uint256\n        feeGrowthInside1LastX128: Field, // uint256\n        // the fees owed to the position owner in token0/token1\n        tokensOwed0: u128, // uint128\n        tokensOwed1: u128 // uint128\n}\n\n\nimpl Position {\n    /// @notice Credits accumulated fees to a user's position\n    /// @param self The individual position to update\n    /// @param liquidityDelta The change in pool liquidity as a result of the position update\n    /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\n    /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\n    fn update(\n        &mut self,\n        liquidityDelta: u128 , // int128\n        isNegDelta: bool,\n        feeGrowthInside0X128: Field , // uint256\n        feeGrowthInside1X128: Field // uint256\n    ) {\n        let mut liquidityNext = 0 as u128;\n        if (liquidityDelta as u128 == 0 as u128) {\n            assert(self.liquidity > 0 as u128, \"NP\"); // disallow pokes for 0 liquidity positions\n            liquidityNext = self.liquidity;\n        } else {\n            liquidityNext = addDelta(self.liquidity, liquidityDelta as u128, isNegDelta);\n        }\n\n        // calculate accumulated fees\n        let tokensOwed0 =\n           (\n                mulDiv(\n                    (feeGrowthInside0X128 - self.feeGrowthInside0LastX128) as Field,\n                    self.liquidity as Field,\n                    Q128 as Field\n                )\n            )  as u128;\n\n        let tokensOwed1 =\n             (\n                mulDiv(\n                    (feeGrowthInside1X128 - self.feeGrowthInside1LastX128) as Field,\n                    self.liquidity  as Field,\n                    Q128 as Field\n                )\n            )  as u128;\n\n        // // update the position\n        if (liquidityDelta as u128 != 0 as u128){\n            self.liquidity = liquidityNext;\n        } \n        self.feeGrowthInside0LastX128 = feeGrowthInside0X128;\n        self.feeGrowthInside1LastX128 = feeGrowthInside1X128;\n        if (tokensOwed0 >  0 as u128 | tokensOwed1 >  0 as u128) {\n            // overflow is acceptable, have to withdraw before you hit type(uint128).max fees\n            self.tokensOwed0 += tokensOwed0;\n            self.tokensOwed1 += tokensOwed1;\n        }\n    }\n}"
    },
    "58": {
      "path": "/home/g/Documents/Projects/Cloak/fzuk/packages/factory/src/sqrtPriceMath.nr",
      "source": "use crate::fullMath::{MAX_U160, mulDiv, mulDivRoundingUp};\nuse crate::helpers::modulo;\nuse crate::tick::{Q128, Q96, RESOLUTION};\nuse crate::tick::Q160;\nuse crate::unsafeMath::divRoundingUp;\nuse dep::bignum::{BigNum, bignum::to_field, U256};\n// @notice Gets the next sqrt price given a delta of token0\n// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n// price less in order to not send too much output.\n// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta\n// @param liquidity The amount of usable liquidity\n// @param amount How much of token0 to add or remove from virtual reserves\n// @param add Whether to add or remove the amount of token0\n// @return The price after adding or removing amount, depending on add\nfn getNextSqrtPriceFromAmount0RoundingUp(\n    sqrtPX96: Field, // uint160\n    liquidity: u128,\n    amount: Field, // uint256\n    add: bool,\n) -> Field {\n    // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n    if ((amount) as u128 == 0 as u128) {\n        sqrtPX96\n    } else {\n        let numerator1 = U256::from((liquidity << RESOLUTION) as Field);\n        if (add) {\n            let mut product: U256 = (U256::from(amount) * U256::from(sqrtPX96));\n\n            if ((product.udiv(U256::from(amount))) == U256::from(sqrtPX96)) {\n                let denominator = numerator1 + product;\n                if (denominator >= numerator1) {\n                    // always fits in 160 bits\n                    let result = mulDivRoundingUp(\n                        to_field(numerator1),\n                        sqrtPX96 as Field,\n                        to_field(denominator),\n                    );\n                    to_field(modulo(U256::from(result), U256::from(Q160)))\n                } else {\n                    let result = divRoundingUp(\n                        to_field(numerator1),\n                        to_field(((numerator1 / U256::from(sqrtPX96)) + (U256::from(amount)))),\n                    );\n                    to_field(modulo(U256::from(result), U256::from(Q160)))\n                }\n            } else {\n                let result = divRoundingUp(\n                    to_field(numerator1),\n                    to_field(numerator1 / (U256::from(sqrtPX96)) + (U256::from(amount))),\n                );\n                to_field(modulo(U256::from(result), U256::from(Q160)))\n            }\n        } else {\n            let mut product = (U256::from(amount) * U256::from(sqrtPX96));\n            // if the product overflows, we know the denominator underflows\n            // in addition, we must check that the denominator does not underflow\n            assert(\n                (product.udiv(U256::from(amount)) == U256::from(sqrtPX96)) & numerator1 > product,\n            );\n\n            let denominator = numerator1 - product;\n            let result = mulDivRoundingUp(to_field(numerator1), sqrtPX96, to_field(denominator));\n            to_field(modulo(U256::from(result), U256::from(Q160)))\n        }\n    }\n}\n\n/// @notice Gets the next sqrt price given a delta of token1\n/// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n/// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n/// price less in order to not send too much output.\n/// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n/// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta\n/// @param liquidity The amount of usable liquidity\n/// @param amount How much of token1 to add, or remove, from virtual reserves\n/// @param add Whether to add, or remove, the amount of token1\n/// @return The price after adding or removing `amount`\nfn getNextSqrtPriceFromAmount1RoundingDown(\n    sqrtPX96: Field, // uint160\n    liquidity: u128, // uint128\n    amount: U256, // uint256\n    add: bool,\n) -> Field {\n    // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n    // in both cases, avoid a mulDiv for most inputs\n    let mut quotient = 0 as Field;\n    if (add) {\n        if to_field(amount) as u128 <= (MAX_U160) as u128 {\n            quotient = to_field(\n                (amount * U256::from(Q96)).udiv(U256::from(liquidity as Field)),\n            );\n        } else {\n            quotient = (mulDiv(to_field(amount), Q96, liquidity as Field));\n        }\n\n        to_field(modulo(U256::from(sqrtPX96 + quotient), U256::from(Q160)))\n    } else {\n        if amount <= U256::from(MAX_U160) {\n            quotient = (divRoundingUp((to_field(amount) * Q96), liquidity as Field));\n        } else {\n            quotient = (mulDivRoundingUp(to_field(amount), Q96, liquidity as Field));\n        }\n\n        assert(U256::from(sqrtPX96) > U256::from(quotient), \"sqrtPX96 > quotient fails\");\n\n        // always fits 160 bits - u160 = u256 % (1 << 160)\n        to_field(modulo(U256::from(sqrtPX96 - quotient), U256::from(Q160)))\n    }\n}\n\n/// @notice Gets the next sqrt price given an output amount of token0 or token1\n/// @dev Throws if price or liquidity are 0 or the next price is out of bounds\n/// @param sqrtPX96 The starting price before accounting for the output amount\n/// @param liquidity The amount of usable liquidity\n/// @param amountOut How much of token0, or token1, is being swapped out\n/// @param zeroForOne Whether the amount out is token0 or token1\n/// @return sqrtQX96 The price after removing the output amount of token0 or token1\nfn getNextSqrtPriceFromOutput(\n    sqrtPX96: Field, // uint160\n    liquidity: u128, // uint128\n    amountOut: Field, // uint256\n    zeroForOne: bool, // bool\n) -> Field {\n    assert((sqrtPX96) as u128 > 0 as u128);\n    assert(liquidity > 0 as u128);\n\n    // round to make sure that we pass the target price\n    if (zeroForOne) {\n        getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, U256::from(amountOut), false)\n    } else {\n        getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false)\n    }\n}\n\n// @notice Gets the amount0 delta between two prices\n// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n// @param sqrtRatioAX96 A sqrt price\n// @param sqrtRatioBX96 Another sqrt price\n// @param liquidity The amount of usable liquidity\n// @param roundUp Whether to round the amount up or down\n// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices\n\nfn getAmount0Delta(\n    sqrtRatioAX96: Field, // uint160\n    sqrtRatioBX96: Field, // uint160\n    liquidity: Field,\n    roundUp: bool,\n) -> Field {\n    let mut _sqrtRatioAX96 = sqrtRatioAX96;\n    let mut _sqrtRatioBX96: Field = sqrtRatioBX96;\n\n    if ((sqrtRatioAX96 as u128) > (sqrtRatioBX96 as u128)) {\n        _sqrtRatioAX96 = sqrtRatioBX96;\n        _sqrtRatioBX96 = sqrtRatioAX96;\n    }\n    let numerator1 = (liquidity as u128) << RESOLUTION;\n    let numerator2 = _sqrtRatioBX96 - _sqrtRatioAX96;\n\n    assert((_sqrtRatioAX96) as u128 > 0 as u128);\n\n    if (roundUp) {\n        divRoundingUp(\n            mulDivRoundingUp(numerator1 as Field, numerator2, _sqrtRatioBX96),\n            _sqrtRatioAX96,\n        )\n    } else {\n        let result = mulDiv(numerator1 as Field, numerator2, _sqrtRatioBX96) / _sqrtRatioAX96;\n        result\n    }\n}\n\n// @notice Gets the amount1 delta between two prices\n// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n// @param sqrtRatioAX96 A sqrt price\n// @param sqrtRatioBX96 Another sqrt price\n// @param liquidity The amount of usable liquidity\n// @param roundUp Whether to round the amount up, or down\n// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices\nfn getAmount1Delta(\n    sqrtRatioAX96: Field, // uint160\n    sqrtRatioBX96: Field, // uint160\n    liquidity: Field,\n    roundUp: bool,\n) -> Field {\n    let mut _sqrtRatioAX96 = sqrtRatioAX96;\n    let mut _sqrtRatioBX96 = sqrtRatioBX96;\n\n    if ((sqrtRatioAX96 as u128) > (sqrtRatioBX96 as u128)) {\n        _sqrtRatioAX96 = sqrtRatioBX96;\n        _sqrtRatioBX96 = sqrtRatioAX96;\n    }\n\n    let mut result = 0;\n    if (roundUp) {\n        result = mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, Q96);\n    } else {\n        result = mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, Q96);\n    }\n    result\n}\n\n/// @notice Gets the next sqrt price given an input amount of token0 or token1\n/// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\n/// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\n/// @param liquidity The amount of usable liquidity\n/// @param amountIn How much of token0, or token1, is being swapped in\n/// @param zeroForOne Whether the amount in is token0 or token1\n/// @return sqrtQX96 The price after adding the input amount to token0 or token1\nfn getNextSqrtPriceFromInput(\n    sqrtPX96: Field, // uint160\n    liquidity: u128, // uint128\n    amountIn: Field, // uint256\n    zeroForOne: bool,\n) -> Field {\n    assert((sqrtPX96 as u128) > 0 as u128);\n    assert(liquidity > 0 as u128);\n\n    // round to make sure that we don't pass the target price\n    if (zeroForOne) {\n        getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\n    } else {\n        getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, U256::from(amountIn), true)\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "75": {
      "path": "/home/g/Documents/Projects/Cloak/fzuk/packages/factory/src/tick.nr",
      "source": "use dep::aztec::{protocol_types::traits::{Deserialize, Packable, Serialize}};\nuse std::meta::derive;\nuse crate::liquidityMath::addDelta;\nuse crate::tickMath::{MAX_TICK, MIN_TICK};\n\nglobal RESOLUTION: u8 = 96;\nglobal Q1: u8 = 2; \nglobal Q2: u8 = 4; \nglobal Q4: u8 = 16; \nglobal Q8: u32 = 256; \nglobal Q16: u32 = 65536; \nglobal Q32: u64 = 4294967296; \nglobal Q64: u128 = 18446744073709551616; \nglobal Q96: Field = 0x1000000000000000000000000; // uint256\nglobal Q128: Field = 0x100000000000000000000000000000000;\nglobal Q160: Field = 0x10000000000000000000000000000000000000000;\nglobal Q192: Field =  0x1000000000000000000000000000000000000000000000000;\n\n// The liquidityGross value represents the gross value of liquidity\n// referencing the tick. This is important for the edge case that\n// one position ends at a Tick and a second position with exactly\n// the same liquidity value would start at the Tick.\n// In this case liquidityNet would be 0 but liquidityGross would\n// still have a value, which ensures that the Tick is not deleted\n// from the Pool.\n\n#[derive(Deserialize, Packable, Serialize)]\npub struct Tick {\n    value: i32,\n    // the total position liquidity that references this tick\n    liquidityGross: u128, // uint128\n    // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\n    liquidityNet: u128, // int128\n    // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n    // only has relative meaning, not absolute _ the value depends on when the tick is initialized\n    feeGrowthOutside0X128: Field, // uint256\n    feeGrowthOutside1X128: Field, // uint256\n    // // the cumulative tick value on the other side of the tick\n    tickCumulativeOutside: i64, // int56\n    // // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n    // // only has relative meaning, not absolute _ the value depends on when the tick is initialized\n    secondsPerLiquidityOutsideX128: Field, // uint160\n    // // the seconds spent on the other side of the tick (relative to the current tick)\n    // // only has relative meaning, not absolute _ the value depends on when the tick is initialized\n    secondsOutside: u32, // uint32\n    // // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0\n    // // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks\n    initialized: bool, // bool\n}\n\n\nimpl Tick {\n    /// @notice Retrieves fee growth data\n    /// @param tickLower The lower tick boundary of the position\n    /// @param tickUpper The upper tick boundary of the position\n    /// @param tickCurrent The current tick\n    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n    /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\n    /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\n    fn getFeeGrowthInside(\n        &mut self,\n        tickLower: &mut Tick,\n        tickUpper: &mut Tick,\n        feeGrowthGlobal0X128: Field,\n        feeGrowthGlobal1X128: Field,\n    ) -> [Field; 2] {\n        // calculate fee growth below\n        let mut feeGrowthBelow0X128 = 0;\n        let mut feeGrowthBelow1X128 = 0;\n        if (self.value >= tickLower.value) {\n            feeGrowthBelow0X128 = tickLower.feeGrowthOutside0X128;\n            feeGrowthBelow1X128 = tickLower.feeGrowthOutside1X128;\n        } else {\n            feeGrowthBelow0X128 = feeGrowthGlobal0X128 - tickLower.feeGrowthOutside0X128;\n            feeGrowthBelow1X128 = feeGrowthGlobal1X128 - tickLower.feeGrowthOutside1X128;\n        }\n\n        // // calculate fee growth above\n        let mut feeGrowthAbove0X128 = 0;\n        let mut feeGrowthAbove1X128 = 0;\n        if (self.value < tickUpper.value) {\n            feeGrowthAbove0X128 = tickUpper.feeGrowthOutside0X128;\n            feeGrowthAbove1X128 = tickUpper.feeGrowthOutside1X128;\n        } else {\n            feeGrowthAbove0X128 = feeGrowthGlobal0X128 - tickUpper.feeGrowthOutside0X128;\n            feeGrowthAbove1X128 = feeGrowthGlobal1X128 - tickUpper.feeGrowthOutside1X128;\n        }\n\n        let feeGrowthInside0X128 = feeGrowthGlobal0X128 - feeGrowthBelow0X128 - feeGrowthAbove0X128;\n        let feeGrowthInside1X128 = feeGrowthGlobal1X128 - feeGrowthBelow1X128 - feeGrowthAbove1X128;\n\n        [feeGrowthInside0X128, feeGrowthInside1X128]\n    }\n\n    /// It now returns a flipped flag, which is set to true when liquidity is added to an empty tick or when entire liquidity is removed from a tick.\n    /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa\n    /// @param self The mapping containing all tick information for initialized ticks\n    /// @param tick The tick that will be updated\n    /// @param tickCurrent The current tick\n    /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)\n    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n    /// @param secondsPerLiquidityCumulativeX128 The all-time seconds per max(1, liquidity) of the pool\n    /// @param tickCumulative The tick * time elapsed since the pool was first initialized\n    /// @param time The current block timestamp cast to a uint32\n    /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick\n    /// @param maxLiquidity The maximum liquidity allocation for a single tick\n    /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa\n    fn update(\n        &mut self,\n        tickCurrent: i32,\n        liquidityDelta: u128,\n        isNegDelta: bool,\n        feeGrowthGlobal0X128: Field,\n        feeGrowthGlobal1X128: Field,\n        secondsPerLiquidityCumulativeX128: Field,\n        tickCumulative: i64,\n        time: u32,\n        upper: bool,\n        maxLiquidity: u128,\n    ) -> bool {\n        let liquidityGrossBefore = self.liquidityGross;\n        let liquidityGrossAfter = addDelta(liquidityGrossBefore, liquidityDelta, isNegDelta);\n\n        assert(liquidityGrossAfter <= maxLiquidity, \"LO\");\n\n        let flipped = (liquidityGrossAfter == 0 as u128)\n            != (liquidityGrossBefore == 0 as u128);\n\n        if (liquidityGrossBefore == 0 as u128) {\n            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick\n            if (self.value <= tickCurrent ) {\n                self.feeGrowthOutside0X128 = feeGrowthGlobal0X128;\n                self.feeGrowthOutside1X128 = feeGrowthGlobal1X128;\n                self.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128;\n                self.tickCumulativeOutside = tickCumulative;\n                self.secondsOutside = time;\n            }\n            self.initialized = true;\n        }\n\n        self.liquidityGross = liquidityGrossAfter;\n\n        // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)\n        if (upper) {\n            self.liquidityNet = self.liquidityNet -((liquidityDelta));\n        } else {\n            self.liquidityNet = self.liquidityNet + ((liquidityDelta));\n        }\n\n        flipped\n    }\n\n    /// @notice Clears tick data\n    /// @param self The mapping containing all initialized tick information for initialized ticks\n    /// @param tick The tick that will be cleared\n    fn clear(&mut self) {\n        self.value = 0;\n        self.liquidityGross = 0 as u128 ;\n        self.liquidityNet =0 as u128;\n        self.feeGrowthOutside0X128 = 0;\n        self.feeGrowthOutside1X128 = 0;\n        self.tickCumulativeOutside = 0;\n        self.secondsPerLiquidityOutsideX128 = 0;\n        self.secondsOutside = 0 as u32;\n        self.initialized = false;\n    }\n\n    /// @notice Transitions to next tick as needed by price movement\n    /// @param self The mapping containing all tick information for initialized ticks\n    /// @param tick The destination tick of the transition\n    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n    /// @param secondsPerLiquidityCumulativeX128 The current seconds per liquidity\n    /// @param tickCumulative The tick * time elapsed since the pool was first initialized\n    /// @param time The current block.timestamp\n    /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)\n    fn cross(\n        &mut self,\n        tick: &mut Tick,\n        feeGrowthGlobal0X128: Field, //uint256\n        feeGrowthGlobal1X128: Field, //uint256\n        secondsPerLiquidityCumulativeX128: Field, //uint160\n        tickCumulative: i64, //int56\n        time: u32, //uint32\n    ) -> u128 {\n        tick.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - tick.feeGrowthOutside0X128;\n        tick.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - tick.feeGrowthOutside1X128;\n        tick.secondsPerLiquidityOutsideX128 =\n            secondsPerLiquidityCumulativeX128 - tick.secondsPerLiquidityOutsideX128;\n        tick.tickCumulativeOutside = tickCumulative - tick.tickCumulativeOutside;\n        tick.secondsOutside = time - tick.secondsOutside;\n\n        tick.liquidityNet\n    }\n}\n"
    },
    "76": {
      "path": "/home/g/Documents/Projects/Cloak/fzuk/packages/factory/src/tickBitmap.nr",
      "source": "use dep::aztec::{prelude::AztecAddress, protocol_types::traits::{Deserialize, Packable, Serialize}};\nuse std::meta::derive;\n\nuse crate::bitMath::{leastSignificantBit, mostSignificantBit};\n\n// accumulated protocol fees in token0/token1 units\n#[derive(Deserialize, Packable, Serialize)]\npub struct TickBitMap {\n    bitmap: u32,\n    wordPos: i16,\n    bitPos: u8,\n}\n\nimpl TickBitMap {\n\n    /// @param tick The tick for which to compute the position\n    /// @return wordPos The key in the mapping containing the word in which the bit is stored\n    /// @return bitPos The bit position in the word where the flag is stored\n    //  uses this technique to store the information about initialized ticks,\n    // that is ticks with some liquidity. When a flag is set (1), the tick has liquidity;\n    // when a flag is not set (0), the tick is not initialized. Lets look at the implementation.\n    fn _getPosition(&mut self, tick: i32) -> [i16; 2] {\n        let wordPos = (tick >> 8);\n        // index\n        // https://uniswapv3book.com/milestone_2/images/tick_bitmap.png\n        let bitPos = (tick % 256) as u8; // 0%256=0, 1%256=1, ...255%256=255, 256%256=0,\n\n        [wordPos as i16, bitPos as i16]\n    }\n\n    /// @notice Flips the initialized state for a given tick from false to true, or vice versa\n    /// @param self The mapping in which to flip the tick\n    /// @param tick The tick to flip\n    /// @param tickSpacing The spacing between usable ticks\n    fn flipTick(&mut self, tick: i32, tickSpacing: i32) -> TickBitMap {\n        assert(tick % tickSpacing == 0); // ensure that the tick is spaced\n        let mut mask = 1 << self.bitPos;\n        let newBitmap = (self.bitmap as u32) ^ (mask);\n\n        let theBitMap =\n            TickBitMap { bitmap: newBitmap, wordPos: self.wordPos, bitPos: self.bitPos };\n        theBitMap\n    }\n\n    /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either\n    /// to the left (less than or equal to) or right (greater than) of the given tick\n    /// @param self The mapping in which to compute the next initialized tick\n    /// @param tick The starting tick\n    /// @param tickSpacing The spacing between usable ticks\n    /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)\n    /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick\n    /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks\n    fn nextInitializedTickWithinOneWord(\n        &mut self,\n        tick: i32,\n        tickSpacing: i32,\n        lte: bool,\n    ) -> (Field, bool) {\n        let mut compressed = tick / tickSpacing;\n        if (tick < 0 & (tick % tickSpacing != 0)) {\n            compressed = compressed - 1; // round towards negative infinity\n        }\n\n        let mut next = 0;\n        let mut initialized = false;\n        if (lte) {\n            let return_values = self._getPosition(compressed);\n            let wordPos = return_values[0];\n            let bitPos = return_values[1];\n            // all the 1s at or to the right of the current bitPos\n            // TODO: unlike uniswap we had to cast into u8 investigate the reason!\n            let mask = (1 << bitPos as u8) - 1 + (1 << bitPos as u8);\n            let masked = self.bitmap as u32 & mask;\n\n            // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word\n            initialized = masked != 0;\n            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n            if (initialized) {\n                let mostSignificant = mostSignificantBit(masked as Field);\n                next = (compressed - (bitPos as i32 - mostSignificant as i32)) * tickSpacing;\n            } else {\n                next = (compressed - bitPos as i32) * tickSpacing;\n            }\n        } else {\n            // start from the word of the next tick, since the current tick state doesn't matter\n            let return_values = self._getPosition(compressed + 1);\n            let wordPos = return_values[0];\n            let bitPos = return_values[1];\n            // all the 1s at or to the left of the bitPos\n            // let mask = ~((1 << bitPos) - 1);\n            let mask = 0;\n            let masked = (self.bitmap as u32) & mask;\n\n            // if there are no initialized ticks to the left of the current tick, return leftmost in the word\n            initialized = masked != 0;\n            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n            if (initialized) {\n                let leastSignificant = leastSignificantBit(masked as Field);\n                next = (compressed + 1 + (leastSignificant as i32 - bitPos as i32)) * tickSpacing;\n            } else {\n                next = (compressed - bitPos as i32) * tickSpacing;\n            }\n        }\n        (next as Field, initialized )\n    }\n}\n"
    },
    "78": {
      "path": "/home/g/Documents/Projects/Cloak/fzuk/packages/factory/src/unsafeMath.nr",
      "source": "use dep::bignum::{BigNum, bignum::to_field, U256};\n\nfn divRoundingUp(x: Field, y: Field) -> Field {\n    let quotient: U256 = U256::from(x).udiv(U256::from(y));\n    let remainder: U256 = unsafe { U256::from(x).__sub((quotient.__mul(U256::from(y)))) };\n\n    // If there's any nonzero remainder, add one to round up.\n    if to_field(remainder) as u32 == 0 as u32 {\n        to_field(quotient)\n    } else {\n        to_field(quotient) + 1\n    }\n}\n"
    },
    "90": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "91": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{\n    gas::GasOpts, private_context::PrivateContext, public_context::PublicContext,\n    returns_hash::ReturnsHash,\n};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\nuse crate::test::helpers::cheatcodes;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateStaticCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<N>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateStaticCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateStaticVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateStaticVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PublicCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicStaticCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicStaticVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicStaticVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for UtilityCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T, let N: u32> UtilityCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for UtilityVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T, let N: u32> UtilityVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\npub trait TXEPublicCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field);\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicStaticVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\npub trait TXEPrivateCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field);\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n\n        let (_end_side_effect_counter, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns: T = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_end_side_effect_counter, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateStaticVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\npub trait TXEUtilityCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self) -> T;\n}\n\nimpl<let M: u32, T, let N: u32> TXEUtilityCallInterface<T, N> for UtilityCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self) -> T {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let returns_hash = crate::oracle::simulate_utility_function::simulate_utility_function(\n            self.get_contract_address(),\n            self.get_selector(),\n            args_hash,\n        );\n\n        let returns: T = ReturnsHash::new(returns_hash).get_preimage();\n        returns\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEUtilityCallInterface<T, N> for UtilityVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self) -> T {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let returns_hash = crate::oracle::simulate_utility_function::simulate_utility_function(\n            self.get_contract_address(),\n            self.get_selector(),\n            args_hash,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n        returns\n    }\n}\n"
    },
    "98": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        include_by_timestamp::IncludeByTimestamp,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: IncludeByTimestamp,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: IncludeByTimestamp::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp =\n            IncludeByTimestamp::min_with_u64(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: IncludeByTimestamp::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "99": {
      "path": "/home/g/nargo/github.com/AztecProtocol/aztec-packages/v1.2.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> u128 {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> u128 {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    }
  }
}
